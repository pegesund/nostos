# expect: 0
# PostgreSQL prepared statement tests
# REQUIRES: PostgreSQL running at localhost with user/password: postgres/postgres

test_basic_prepare_query(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE prep_test1 (id INT, name TEXT)", [])
    Pg.execute(conn, "INSERT INTO prep_test1 VALUES ($1, $2)", [1, "alice"])
    Pg.execute(conn, "INSERT INTO prep_test1 VALUES ($1, $2)", [2, "bob"])

    # Prepare a query
    Pg.prepare(conn, "get_by_id", "SELECT id, name FROM prep_test1 WHERE id = $1")

    # Execute prepared query
    rows = Pg.queryPrepared(conn, "get_by_id", [1])
    assert_eq(length(rows), 1)
    row = head(rows)
    assert_eq(head(row), 1)
    assert_eq(head(tail(row)), "alice")

    # Execute again with different params
    rows2 = Pg.queryPrepared(conn, "get_by_id", [2])
    assert_eq(length(rows2), 1)
    row2 = head(rows2)
    assert_eq(head(row2), 2)
    assert_eq(head(tail(row2)), "bob")

    # Deallocate
    Pg.deallocate(conn, "get_by_id")

    # Cleanup
    Pg.execute(conn, "DROP TABLE prep_test1", [])
    ()
}

test_basic_prepare_execute(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE prep_test2 (id INT, value INT)", [])

    # Prepare an insert statement
    Pg.prepare(conn, "insert_row", "INSERT INTO prep_test2 VALUES ($1, $2)")

    # Execute multiple times
    Pg.executePrepared(conn, "insert_row", [1, 100])
    Pg.executePrepared(conn, "insert_row", [2, 200])
    Pg.executePrepared(conn, "insert_row", [3, 300])

    # Verify
    rows = Pg.query(conn, "SELECT COUNT(*) FROM prep_test2", [])
    assert_eq(head(head(rows)), 3)

    # Deallocate
    Pg.deallocate(conn, "insert_row")

    # Cleanup
    Pg.execute(conn, "DROP TABLE prep_test2", [])
    ()
}

test_prepare_in_transaction(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE prep_test3 (id INT, name TEXT)", [])

    # Prepare statements
    Pg.prepare(conn, "insert_name", "INSERT INTO prep_test3 VALUES ($1, $2)")
    Pg.prepare(conn, "get_all", "SELECT * FROM prep_test3 ORDER BY id")

    # Use prepared statements in transaction
    Pg.begin(conn)
    Pg.executePrepared(conn, "insert_name", [1, "first"])
    Pg.executePrepared(conn, "insert_name", [2, "second"])
    Pg.commit(conn)

    # Verify
    rows = Pg.queryPrepared(conn, "get_all", [])
    assert_eq(length(rows), 2)

    # Deallocate
    Pg.deallocate(conn, "insert_name")
    Pg.deallocate(conn, "get_all")

    # Cleanup
    Pg.execute(conn, "DROP TABLE prep_test3", [])
    ()
}

test_prepare_rollback(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE prep_test4 (id INT)", [])

    # Prepare statement
    Pg.prepare(conn, "insert_id", "INSERT INTO prep_test4 VALUES ($1)")

    # Insert outside transaction
    Pg.executePrepared(conn, "insert_id", [1])

    # Insert in transaction then rollback
    Pg.begin(conn)
    Pg.executePrepared(conn, "insert_id", [2])
    Pg.executePrepared(conn, "insert_id", [3])
    Pg.rollback(conn)

    # Verify only first row remains
    rows = Pg.query(conn, "SELECT COUNT(*) FROM prep_test4", [])
    assert_eq(head(head(rows)), 1)

    # Deallocate
    Pg.deallocate(conn, "insert_id")

    # Cleanup
    Pg.execute(conn, "DROP TABLE prep_test4", [])
    ()
}

test_multiple_prepared_statements(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE prep_test5 (id INT, name TEXT, active BOOL)", [])

    # Prepare multiple statements
    Pg.prepare(conn, "insert_user", "INSERT INTO prep_test5 VALUES ($1, $2, $3)")
    Pg.prepare(conn, "get_active", "SELECT id, name FROM prep_test5 WHERE active = $1")
    Pg.prepare(conn, "update_status", "UPDATE prep_test5 SET active = $1 WHERE id = $2")

    # Insert data
    Pg.executePrepared(conn, "insert_user", [1, "alice", true])
    Pg.executePrepared(conn, "insert_user", [2, "bob", false])
    Pg.executePrepared(conn, "insert_user", [3, "charlie", true])

    # Query active users
    active_users = Pg.queryPrepared(conn, "get_active", [true])
    assert_eq(length(active_users), 2)

    # Update bob to active
    Pg.executePrepared(conn, "update_status", [true, 2])

    # Query again
    active_users2 = Pg.queryPrepared(conn, "get_active", [true])
    assert_eq(length(active_users2), 3)

    # Deallocate all
    Pg.deallocate(conn, "insert_user")
    Pg.deallocate(conn, "get_active")
    Pg.deallocate(conn, "update_status")

    # Cleanup
    Pg.execute(conn, "DROP TABLE prep_test5", [])
    ()
}

test_deallocate_not_found(conn) = {
    # Try to deallocate non-existent statement
    result = try Pg.deallocate(conn, "nonexistent_statement") catch
        ("deallocate_error", msg) -> "caught"
        _ -> "unexpected"
    end
    assert_eq(result, "caught")
    ()
}

test_query_prepared_not_found(conn) = {
    # Try to query with non-existent prepared statement
    result = try Pg.queryPrepared(conn, "nonexistent", []) catch
        ("query_error", msg) -> "caught"
        _ -> "unexpected"
    end
    assert_eq(result, "caught")
    ()
}

main() = {
    conn = Pg.connect("host=localhost user=postgres password=postgres")

    test_basic_prepare_query(conn)
    test_basic_prepare_execute(conn)
    test_prepare_in_transaction(conn)
    test_prepare_rollback(conn)
    test_multiple_prepared_statements(conn)
    test_deallocate_not_found(conn)
    test_query_prepared_not_found(conn)

    Pg.close(conn)
    0
}
