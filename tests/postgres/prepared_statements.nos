# expect: 0
# PostgreSQL prepared statement tests
# REQUIRES: PostgreSQL running at localhost with user/password: postgres/postgres

test_basic_prepare_query(conn) = {
    # Create temp table and insert with SQL literals
    Pg.execute(conn, "CREATE TEMP TABLE prep_test1 (id INT, name TEXT)", [])
    Pg.execute(conn, "INSERT INTO prep_test1 VALUES (1, 'alice')", [])
    Pg.execute(conn, "INSERT INTO prep_test1 VALUES (2, 'bob')", [])

    # Prepare a query
    Pg.prepare(conn, "get_by_id", "SELECT id FROM prep_test1 WHERE id = $1")

    # Execute prepared query - only select id (homogeneous result)
    rows = Pg.queryPrepared(conn, "get_by_id", [1])
    assert_eq(length(rows), 1)
    assert_eq(head(rows).0, 1)

    # Execute again with different params
    rows2 = Pg.queryPrepared(conn, "get_by_id", [2])
    assert_eq(length(rows2), 1)
    assert_eq(head(rows2).0, 2)

    # Deallocate
    Pg.deallocate(conn, "get_by_id")

    # Cleanup
    Pg.execute(conn, "DROP TABLE prep_test1", [])
}

test_basic_prepare_execute(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE prep_test2 (id INT, value INT)", [])

    # Prepare an insert statement
    Pg.prepare(conn, "insert_row", "INSERT INTO prep_test2 VALUES ($1, $2)")

    # Execute multiple times
    Pg.executePrepared(conn, "insert_row", [1, 100])
    Pg.executePrepared(conn, "insert_row", [2, 200])
    Pg.executePrepared(conn, "insert_row", [3, 300])

    # Verify
    rows = Pg.query(conn, "SELECT COUNT(*) FROM prep_test2", [])
    assert_eq(head(rows).0, 3)

    # Deallocate
    Pg.deallocate(conn, "insert_row")

    # Cleanup
    Pg.execute(conn, "DROP TABLE prep_test2", [])
}

test_prepare_in_transaction(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE prep_test3 (id INT, name TEXT)", [])

    # Prepare statements - use only id for insert to keep params homogeneous
    Pg.prepare(conn, "insert_id", "INSERT INTO prep_test3 (id, name) VALUES ($1, 'name')")
    Pg.prepare(conn, "get_count", "SELECT COUNT(*) FROM prep_test3")

    # Use prepared statements in transaction
    Pg.begin(conn)
    Pg.executePrepared(conn, "insert_id", [1])
    Pg.executePrepared(conn, "insert_id", [2])
    Pg.commit(conn)

    # Verify
    rows = Pg.queryPrepared(conn, "get_count", [])
    assert_eq(head(rows).0, 2)

    # Deallocate
    Pg.deallocate(conn, "insert_id")
    Pg.deallocate(conn, "get_count")

    # Cleanup
    Pg.execute(conn, "DROP TABLE prep_test3", [])
}

test_prepare_rollback(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE prep_test4 (id INT)", [])

    # Prepare statement
    Pg.prepare(conn, "insert_id", "INSERT INTO prep_test4 VALUES ($1)")

    # Insert outside transaction
    Pg.executePrepared(conn, "insert_id", [1])

    # Insert in transaction then rollback
    Pg.begin(conn)
    Pg.executePrepared(conn, "insert_id", [2])
    Pg.executePrepared(conn, "insert_id", [3])
    Pg.rollback(conn)

    # Verify only first row remains
    rows = Pg.query(conn, "SELECT COUNT(*) FROM prep_test4", [])
    assert_eq(head(rows).0, 1)

    # Deallocate
    Pg.deallocate(conn, "insert_id")

    # Cleanup
    Pg.execute(conn, "DROP TABLE prep_test4", [])
}

test_multiple_prepared_statements_part1(conn) = {
    # Test prepared statements with Int parameters
    Pg.execute(conn, "CREATE TEMP TABLE prep_test5a (id INT, category INT)", [])
    Pg.execute(conn, "INSERT INTO prep_test5a VALUES (1, 1), (2, 2), (3, 1)", [])

    Pg.prepare(conn, "get_category_count", "SELECT COUNT(*) FROM prep_test5a WHERE category = $1")
    rows1 = Pg.queryPrepared(conn, "get_category_count", [1])
    assert_eq(head(rows1).0, 2)

    rows2 = Pg.queryPrepared(conn, "get_category_count", [2])
    assert_eq(head(rows2).0, 1)

    Pg.deallocate(conn, "get_category_count")
    Pg.execute(conn, "DROP TABLE prep_test5a", [])
}

test_multiple_prepared_statements_part2(conn) = {
    # Test prepared statements with Int parameters
    Pg.execute(conn, "CREATE TEMP TABLE prep_test5b (id INT, value INT)", [])
    Pg.execute(conn, "INSERT INTO prep_test5b VALUES (1, 100), (2, 200)", [])

    Pg.prepare(conn, "update_by_id", "UPDATE prep_test5b SET value = value + 1 WHERE id = $1")
    Pg.executePrepared(conn, "update_by_id", [1])

    rows = Pg.query(conn, "SELECT value FROM prep_test5b WHERE id = 1", [])
    assert_eq(head(rows).0, 101)

    Pg.deallocate(conn, "update_by_id")
    Pg.execute(conn, "DROP TABLE prep_test5b", [])
}

test_deallocate_not_found(conn) = {
    # Try to deallocate non-existent statement
    result = try {
        Pg.deallocate(conn, "nonexistent_statement")
        "success"
    } catch {
        ("deallocate_error", msg) -> "caught"
        _ -> "unexpected"
    }
    assert_eq(result, "caught")
}

test_query_prepared_not_found(conn) = {
    # Try to query with non-existent prepared statement
    result = try {
        Pg.queryPrepared(conn, "nonexistent", [])
        "success"
    } catch {
        ("query_error", msg) -> "caught"
        _ -> "unexpected"
    }
    assert_eq(result, "caught")
}

main() = {
    conn = Pg.connect("host=localhost user=postgres password=postgres")

    test_basic_prepare_query(conn)
    test_basic_prepare_execute(conn)
    test_prepare_in_transaction(conn)
    test_prepare_rollback(conn)
    test_multiple_prepared_statements_part1(conn)
    test_multiple_prepared_statements_part2(conn)
    test_deallocate_not_found(conn)
    test_query_prepared_not_found(conn)

    Pg.close(conn)
    0
}
