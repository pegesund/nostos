# expect: 0
# PostgreSQL exception handling tests
# REQUIRES: PostgreSQL running at localhost with user/password: postgres/postgres

test_query_syntax_error(conn) = {
    # Catch SQL syntax error with pattern match
    # Use Ok/Err to have consistent return type
    result = try { Ok(Pg.query(conn, "SELEC INVALID SYNTAX", [])) } catch {
        ("query_error", msg) -> Err(msg)
        e -> Err("unexpected: " ++ show(e))
    }
    # Result should be an error containing error info
    match result {
        Err(msg) -> assert(msg.length() > 0)
        Ok(_) -> assert(false)  # Should have thrown
    }
}

test_query_missing_table(conn) = {
    # Catch missing table error
    result = try { Ok(Pg.query(conn, "SELECT * FROM nonexistent_table_xyz_123", [])) } catch {
        ("query_error", msg) -> Err(msg)
        e -> Err("unexpected")
    }
    match result {
        Err(msg) -> assert(msg.length() > 0)
        Ok(_) -> assert(false)
    }
}

test_execute_syntax_error(conn) = {
    # Catch SQL syntax error in execute
    # Return empty string on success, error message on failure
    result = try {
        Pg.execute(conn, "INSER INTO foo VALUES (1)", [])
        ""
    } catch {
        ("execute_error", msg) -> msg
        e -> "unexpected"
    }
    assert(result.length() > 0)
}

test_no_exception_on_success(conn) = {
    # Verify no exception on valid query
    result = try { Pg.query(conn, "SELECT 42", []) } catch { (kind, msg) -> [] }
    # Should be [[42]] not error
    assert_eq(head(result).0, 42)
}

test_exception_pattern_match_kind(conn) = {
    # Can pattern match on error kind
    # Return "success" if no error, otherwise the error kind
    kind = try {
        Pg.query(conn, "INVALID", [])
        "success"
    } catch {
        ("query_error", _) -> "query"
        ("execute_error", _) -> "execute"
        ("connection_error", _) -> "connection"
        _ -> "unknown"
    }
    assert_eq(kind, "query")
}

test_exception_catch_all(conn) = {
    # Catch any error with tuple pattern
    # Return empty string on success, formatted error on failure
    result = try {
        Pg.query(conn, "BAD SQL", [])
        ""
    } catch { (kind, msg) -> kind ++ ": " ++ msg }
    # Should start with "query_error: "
    assert(result.length() > 12)
}

test_nested_try_catch(conn) = {
    # Nested try-catch blocks
    outer = try {
        inner = try {
            Pg.query(conn, "BAD SQL", [])
            "inner success"
        } catch {
            ("query_error", _) -> "inner caught"
            _ -> "inner unknown"
        }
        inner
    } catch {
        _ -> "outer caught"
    }
    # Inner catch should handle it
    assert_eq(outer, "inner caught")
}

main() = {
    conn = Pg.connect("host=localhost user=postgres password=postgres")

    test_query_syntax_error(conn)
    test_query_missing_table(conn)
    test_execute_syntax_error(conn)
    test_no_exception_on_success(conn)
    test_exception_pattern_match_kind(conn)
    test_exception_catch_all(conn)
    test_nested_try_catch(conn)

    Pg.close(conn)
    0
}
