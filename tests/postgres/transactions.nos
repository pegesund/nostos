# expect: 0
# PostgreSQL transaction tests
# REQUIRES: PostgreSQL running at localhost with user/password: postgres/postgres

test_basic_commit(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test (id INT, value TEXT)", [])

    # Begin transaction
    Pg.begin(conn)

    # Insert in transaction
    Pg.execute(conn, "INSERT INTO tx_test VALUES ($1, $2)", [1, "one"])
    Pg.execute(conn, "INSERT INTO tx_test VALUES ($1, $2)", [2, "two"])

    # Commit
    Pg.commit(conn)

    # Verify data persisted
    rows = Pg.query(conn, "SELECT * FROM tx_test ORDER BY id", [])
    assert_eq(length(rows), 2)
    assert_eq(head(head(rows)), 1)

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test", [])
    ()
}

test_basic_rollback(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test2 (id INT, value TEXT)", [])

    # Insert initial data (outside transaction)
    Pg.execute(conn, "INSERT INTO tx_test2 VALUES ($1, $2)", [1, "one"])

    # Begin transaction
    Pg.begin(conn)

    # Insert more data
    Pg.execute(conn, "INSERT INTO tx_test2 VALUES ($1, $2)", [2, "two"])
    Pg.execute(conn, "INSERT INTO tx_test2 VALUES ($1, $2)", [3, "three"])

    # Rollback - should undo the inserts
    Pg.rollback(conn)

    # Verify only original data remains
    rows = Pg.query(conn, "SELECT * FROM tx_test2", [])
    assert_eq(length(rows), 1)
    assert_eq(head(head(rows)), 1)

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test2", [])
    ()
}

test_transaction_isolation(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test3 (counter INT)", [])
    Pg.execute(conn, "INSERT INTO tx_test3 VALUES ($1)", [0])

    # Begin transaction
    Pg.begin(conn)

    # Update in transaction
    Pg.execute(conn, "UPDATE tx_test3 SET counter = counter + 1", [])

    # Verify update visible within transaction
    r1 = Pg.query(conn, "SELECT counter FROM tx_test3", [])
    assert_eq(head(head(r1)), 1)

    # Commit
    Pg.commit(conn)

    # Verify persisted
    r2 = Pg.query(conn, "SELECT counter FROM tx_test3", [])
    assert_eq(head(head(r2)), 1)

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test3", [])
    ()
}

test_rollback_on_error(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test4 (id INT PRIMARY KEY)", [])

    # Begin transaction
    Pg.begin(conn)

    # Insert first row
    Pg.execute(conn, "INSERT INTO tx_test4 VALUES ($1)", [1])

    # Try to insert duplicate (will fail) - catch the error
    result = try Pg.execute(conn, "INSERT INTO tx_test4 VALUES ($1)", [1]) catch
        ("execute_error", msg) -> "error"
        _ -> "unexpected"
    end
    assert_eq(result, "error")

    # Rollback the failed transaction
    Pg.rollback(conn)

    # Verify table is empty (first insert was rolled back too)
    rows = Pg.query(conn, "SELECT * FROM tx_test4", [])
    assert_eq(length(rows), 0)

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test4", [])
    ()
}

test_nested_operations(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test5 (id INT, name TEXT)", [])

    # Transaction with multiple operations
    Pg.begin(conn)

    Pg.execute(conn, "INSERT INTO tx_test5 VALUES ($1, $2)", [1, "alice"])
    Pg.execute(conn, "INSERT INTO tx_test5 VALUES ($1, $2)", [2, "bob"])
    Pg.execute(conn, "UPDATE tx_test5 SET name = $1 WHERE id = $2", ["ALICE", 1])
    Pg.execute(conn, "DELETE FROM tx_test5 WHERE id = $1", [2])

    Pg.commit(conn)

    # Verify final state
    rows = Pg.query(conn, "SELECT * FROM tx_test5", [])
    assert_eq(length(rows), 1)
    row = head(rows)
    assert_eq(head(row), 1)
    assert_eq(head(tail(row)), "ALICE")

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test5", [])
    ()
}

# ===== Pg.transaction helper tests =====

test_transaction_helper_commit(conn) = {
    # Test Pg.transaction with successful commit
    Pg.execute(conn, "CREATE TEMP TABLE tx_helper1 (id INT, name TEXT)", [])

    result = Pg.transaction(conn, () => {
        Pg.execute(conn, "INSERT INTO tx_helper1 VALUES ($1, $2)", [1, "alice"])
        Pg.execute(conn, "INSERT INTO tx_helper1 VALUES ($1, $2)", [2, "bob"])
        "success"
    })
    assert_eq(result, "success")

    rows = Pg.query(conn, "SELECT COUNT(*) FROM tx_helper1", [])
    assert_eq(head(head(rows)), 2)

    Pg.execute(conn, "DROP TABLE tx_helper1", [])
    ()
}

test_transaction_helper_user_exception(conn) = {
    # Test Pg.transaction with user exception - auto rollback
    Pg.execute(conn, "CREATE TEMP TABLE tx_helper2 (id INT)", [])

    result = try Pg.transaction(conn, () => {
        Pg.execute(conn, "INSERT INTO tx_helper2 VALUES ($1)", [1])
        throw("user error")
        ()
    }) catch
        e -> "caught"
    end
    assert_eq(result, "caught")

    # Should have rolled back
    rows = Pg.query(conn, "SELECT COUNT(*) FROM tx_helper2", [])
    assert_eq(head(head(rows)), 0)

    Pg.execute(conn, "DROP TABLE tx_helper2", [])
    ()
}

test_transaction_helper_sql_error(conn) = {
    # Test Pg.transaction with SQL error - auto rollback
    Pg.execute(conn, "CREATE TEMP TABLE tx_helper3 (id INT)", [])
    Pg.execute(conn, "INSERT INTO tx_helper3 VALUES ($1)", [100])

    result = try Pg.transaction(conn, () => {
        Pg.execute(conn, "INSERT INTO tx_helper3 VALUES ($1)", [200])
        Pg.query(conn, "INVALID SQL SYNTAX", [])
        ()
    }) catch
        ("query_error", msg) -> "sql_error"
        e -> "other"
    end
    assert_eq(result, "sql_error")

    # Should have rolled back (only original row remains)
    rows = Pg.query(conn, "SELECT COUNT(*) FROM tx_helper3", [])
    assert_eq(head(head(rows)), 1)

    Pg.execute(conn, "DROP TABLE tx_helper3", [])
    ()
}

test_transaction_helper_return_value(conn) = {
    # Test that Pg.transaction returns the closure result
    Pg.execute(conn, "CREATE TEMP TABLE tx_helper4 (id INT, value INT)", [])

    result = Pg.transaction(conn, () => {
        Pg.execute(conn, "INSERT INTO tx_helper4 VALUES ($1, $2)", [1, 42])
        rows = Pg.query(conn, "SELECT value FROM tx_helper4 WHERE id = $1", [1])
        head(head(rows))
    })
    assert_eq(result, 42)

    Pg.execute(conn, "DROP TABLE tx_helper4", [])
    ()
}

main() = {
    conn = Pg.connect("host=localhost user=postgres password=postgres")

    test_basic_commit(conn)
    test_basic_rollback(conn)
    test_transaction_isolation(conn)
    test_rollback_on_error(conn)
    test_nested_operations(conn)

    # Pg.transaction helper tests
    test_transaction_helper_commit(conn)
    test_transaction_helper_user_exception(conn)
    test_transaction_helper_sql_error(conn)
    test_transaction_helper_return_value(conn)

    Pg.close(conn)
    0
}
