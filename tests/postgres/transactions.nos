# expect: 0
# PostgreSQL transaction tests
# REQUIRES: PostgreSQL running at localhost with user/password: postgres/postgres

test_basic_commit(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test (id INT, value TEXT)", [])

    # Begin transaction
    Pg.begin(conn)

    # Insert in transaction using SQL literals
    Pg.execute(conn, "INSERT INTO tx_test VALUES (1, 'one')", [])
    Pg.execute(conn, "INSERT INTO tx_test VALUES (2, 'two')", [])

    # Commit
    Pg.commit(conn)

    # Verify data persisted - count rows
    rows = Pg.query(conn, "SELECT COUNT(*) FROM tx_test", [])
    assert_eq(head(rows).0, 2)

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test", [])
}

test_basic_rollback(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test2 (id INT, value TEXT)", [])

    # Insert initial data (outside transaction)
    Pg.execute(conn, "INSERT INTO tx_test2 VALUES (1, 'one')", [])

    # Begin transaction
    Pg.begin(conn)

    # Insert more data
    Pg.execute(conn, "INSERT INTO tx_test2 VALUES (2, 'two')", [])
    Pg.execute(conn, "INSERT INTO tx_test2 VALUES (3, 'three')", [])

    # Rollback - should undo the inserts
    Pg.rollback(conn)

    # Verify only original data remains
    rows = Pg.query(conn, "SELECT COUNT(*) FROM tx_test2", [])
    assert_eq(head(rows).0, 1)

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test2", [])
}

test_transaction_isolation(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test3 (counter INT)", [])
    Pg.execute(conn, "INSERT INTO tx_test3 VALUES (0)", [])

    # Begin transaction
    Pg.begin(conn)

    # Update in transaction
    Pg.execute(conn, "UPDATE tx_test3 SET counter = counter + 1", [])

    # Verify update visible within transaction
    r1 = Pg.query(conn, "SELECT counter FROM tx_test3", [])
    assert_eq(head(r1).0, 1)

    # Commit
    Pg.commit(conn)

    # Verify persisted
    r2 = Pg.query(conn, "SELECT counter FROM tx_test3", [])
    assert_eq(head(r2).0, 1)

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test3", [])
}

test_rollback_on_error(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test4 (id INT PRIMARY KEY)", [])

    # Begin transaction
    Pg.begin(conn)

    # Insert first row
    Pg.execute(conn, "INSERT INTO tx_test4 VALUES (1)", [])

    # Try to insert duplicate (will fail) - catch the error
    result = try {
        Pg.execute(conn, "INSERT INTO tx_test4 VALUES ($1)", [1])
        "success"
    } catch {
        ("execute_error", msg) -> "error"
        _ -> "unexpected"
    }
    assert_eq(result, "error")

    # Rollback the failed transaction
    Pg.rollback(conn)

    # Verify table is empty (first insert was rolled back too)
    rows = Pg.query(conn, "SELECT * FROM tx_test4", [])
    assert_eq(length(rows), 0)

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test4", [])
}

test_nested_operations(conn) = {
    # Create temp table
    Pg.execute(conn, "CREATE TEMP TABLE tx_test5 (id INT, name TEXT)", [])

    # Transaction with multiple operations using SQL literals
    Pg.begin(conn)

    Pg.execute(conn, "INSERT INTO tx_test5 VALUES (1, 'alice')", [])
    Pg.execute(conn, "INSERT INTO tx_test5 VALUES (2, 'bob')", [])
    Pg.execute(conn, "UPDATE tx_test5 SET name = 'ALICE' WHERE id = 1", [])
    Pg.execute(conn, "DELETE FROM tx_test5 WHERE id = 2", [])

    Pg.commit(conn)

    # Verify final state - just count
    rows = Pg.query(conn, "SELECT COUNT(*) FROM tx_test5", [])
    assert_eq(head(rows).0, 1)

    # Cleanup
    Pg.execute(conn, "DROP TABLE tx_test5", [])
}

# ===== Pg.transaction helper tests =====

test_transaction_helper_commit(conn) = {
    # Test Pg.transaction with successful commit
    Pg.execute(conn, "CREATE TEMP TABLE tx_helper1 (id INT, name TEXT)", [])

    result = Pg.transaction(conn, () => {
        Pg.execute(conn, "INSERT INTO tx_helper1 VALUES (1, 'alice')", [])
        Pg.execute(conn, "INSERT INTO tx_helper1 VALUES (2, 'bob')", [])
        "success"
    })
    assert_eq(result, "success")

    rows = Pg.query(conn, "SELECT COUNT(*) FROM tx_helper1", [])
    assert_eq(head(rows).0, 2)

    Pg.execute(conn, "DROP TABLE tx_helper1", [])
}

test_transaction_helper_user_exception(conn) = {
    # Test Pg.transaction with user exception - auto rollback
    Pg.execute(conn, "CREATE TEMP TABLE tx_helper2 (id INT)", [])

    result = try {
        Pg.transaction(conn, () => {
            Pg.execute(conn, "INSERT INTO tx_helper2 VALUES (1)", [])
            throw("user error")
            ()
        })
        "success"
    } catch {
        e -> "caught"
    }
    assert_eq(result, "caught")

    # Should have rolled back
    rows = Pg.query(conn, "SELECT COUNT(*) FROM tx_helper2", [])
    assert_eq(head(rows).0, 0)

    Pg.execute(conn, "DROP TABLE tx_helper2", [])
}

test_transaction_helper_sql_error(conn) = {
    # Test Pg.transaction with SQL error - auto rollback
    Pg.execute(conn, "CREATE TEMP TABLE tx_helper3 (id INT)", [])
    Pg.execute(conn, "INSERT INTO tx_helper3 VALUES (100)", [])

    result = try {
        Pg.transaction(conn, () => {
            Pg.execute(conn, "INSERT INTO tx_helper3 VALUES (200)", [])
            Pg.query(conn, "INVALID SQL SYNTAX", [])
            ()
        })
        "success"
    } catch {
        ("query_error", msg) -> "sql_error"
        e -> "other"
    }
    assert_eq(result, "sql_error")

    # Should have rolled back (only original row remains)
    rows = Pg.query(conn, "SELECT COUNT(*) FROM tx_helper3", [])
    assert_eq(head(rows).0, 1)

    Pg.execute(conn, "DROP TABLE tx_helper3", [])
}

test_transaction_helper_return_value(conn) = {
    # Test that Pg.transaction returns the closure result
    Pg.execute(conn, "CREATE TEMP TABLE tx_helper4 (id INT, value INT)", [])

    result = Pg.transaction(conn, () => {
        Pg.execute(conn, "INSERT INTO tx_helper4 VALUES (1, 42)", [])
        rows = Pg.query(conn, "SELECT value FROM tx_helper4 WHERE id = 1", [])
        head(rows).0
    })
    assert_eq(result, 42)

    Pg.execute(conn, "DROP TABLE tx_helper4", [])
}

main() = {
    conn = Pg.connect("host=localhost user=postgres password=postgres")

    test_basic_commit(conn)
    test_basic_rollback(conn)
    test_transaction_isolation(conn)
    test_rollback_on_error(conn)
    test_nested_operations(conn)

    # Pg.transaction helper tests
    test_transaction_helper_commit(conn)
    test_transaction_helper_user_exception(conn)
    test_transaction_helper_sql_error(conn)
    test_transaction_helper_return_value(conn)

    Pg.close(conn)
    0
}
