# expect: 0
# Higher-order functions with named/default params

# Function returning function with defaults
curry(f, x = 0) = y => f(x, y)
add(a, b) = a + b
test1() = curry(add)(5) == 5
test2() = curry(add, 10)(5) == 15
test3() = curry(add, x: 20)(5) == 25

# Apply function once or with initial value
applyOnce(f, x = 0) = f(x)
test4() = applyOnce(x => x + 1) == 1
test5() = applyOnce(x => x + 1, 5) == 6
test6() = applyOnce(x => x * 2, x: 10) == 20

# Compose with defaults
pipe(f = x => x, g = x => x) = x => g(f(x))
test7() = pipe()(5) == 5
test8() = pipe(x => x + 1)(5) == 6
test9() = pipe(x => x + 1, x => x * 2)(5) == 12
test10() = pipe(g: x => x + 100)(5) == 105

# Fold with default operation
foldWith(lst, op = (a, b) => a + b, init = 0) = lst.fold(init, op)
test11() = foldWith([1, 2, 3, 4]) == 10
test12() = foldWith([1, 2, 3, 4], (a, b) => a * b, 1) == 24
test13() = foldWith([1, 2, 3], init: 100) == 106
test14() = foldWith([2, 3, 4], op: (a, b) => a * b, init: 1) == 24

# Partial application simulator
partial(f, fixed = 0) = (a, b) => f(fixed, a, b)
tripleAdd(a, b, c) = a + b + c
test15() = partial(tripleAdd)(2, 3) == 5
test16() = partial(tripleAdd, 10)(2, 3) == 15

# Map with default transform
mapWith(lst, f = x => x) = lst.map(f)
test17() = mapWith([1, 2, 3]) == [1, 2, 3]
test18() = mapWith([1, 2, 3], x => x * 2) == [2, 4, 6]
test19() = mapWith([1, 2], f: x => x + 10) == [11, 12]

main() = {
    results = [test1(), test2(), test3(), test4(), test5(), test6(),
               test7(), test8(), test9(), test10(), test11(), test12(),
               test13(), test14(), test15(), test16(), test17(), test18(), test19()]
    passed = results.filter(r => r)
    if length(passed) == 19 then 0 else 1
}
