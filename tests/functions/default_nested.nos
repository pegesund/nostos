# expect: 0
# Nested function calls with defaults

# Simple chain
add(a, b = 0) = a + b
mul(a, b = 1) = a * b

# Nested call using defaults
test1() = add(mul(5)) == 5          # mul(5,1) = 5, add(5,0) = 5
test2() = add(mul(5, 2)) == 10      # mul(5,2) = 10, add(10,0) = 10
test3() = add(mul(5), 3) == 8       # mul(5,1) = 5, add(5,3) = 8
test4() = add(mul(5, 2), 3) == 13   # mul(5,2) = 10, add(10,3) = 13

# Deeply nested
test5() = add(add(add(1))) == 1     # add(add(add(1,0),0),0)
test6() = mul(mul(mul(2))) == 2     # mul(mul(mul(2,1),1),1)
test7() = add(mul(add(2, 3), 2)) == 10  # add(2,3)=5, mul(5,2)=10, add(10,0)=10

# Named params in nested calls
test8() = add(a: mul(a: 3, b: 4), b: 2) == 14  # mul=12, add(12,2)=14
test9() = mul(b: 3, a: add(b: 5, a: 2)) == 21  # add=7, mul(7,3)=21

# Function returning function with defaults
makeAdder(n = 0) = x => x + n
test10() = makeAdder()(5) == 5
test11() = makeAdder(10)(5) == 15
test12() = makeAdder(n: 20)(3) == 23

# Chained function applications
applyTwice(f, x = 0) = f(f(x))
test13() = applyTwice(x => x + 1) == 2
test14() = applyTwice(x => x + 1, 5) == 7
test15() = applyTwice(x => x * 2, x: 3) == 12

main() = {
    results = [test1(), test2(), test3(), test4(), test5(),
               test6(), test7(), test8(), test9(), test10(),
               test11(), test12(), test13(), test14(), test15()]
    passed = results.filter(r => r)
    if length(passed) == 15 then 0 else 1
}
