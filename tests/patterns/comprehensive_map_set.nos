# expect: true

# Helper to assert equality
assert_eq(got, expected) = {
    if got == expected then true
    else throw("Assertion failed: expected " ++ show(expected) ++ ", got " ++ show(got))
}

# Helper to assert boolean
assert(cond) = {
    if cond then true else throw("Assertion failed")
}

map_simple_match() = {
    m = %{"a": 1, "b": 2}
    res = match m
        %{"a": 1} -> true
        _ -> false
    end
    assert(res)
}

map_bind_value() = {
    m = %{"name": "nostos", "type": "lang"}
    match m
        %{"name": n} -> assert_eq(n, "nostos")
        _ -> throw("failed")
    end
}

map_missing_key_fail() = {
    m = %{"a": 1}
    res = match m
        %{"b": 1} -> false
        _ -> true
    end
    assert(res)
}

map_value_mismatch() = {
    m = %{"a": 1}
    res = match m
        %{"a": 2} -> false
        _ -> true
    end
    assert(res)
}

map_nested_map() = {
    m = %{"config": %{"debug": true}}
    match m
        %{"config": %{"debug": true}} -> true
        _ -> throw("failed")
    end
}

map_nested_bind() = {
    m = %{"user": %{"id": 42, "role": "admin"}}
    match m
        %{"user": %{"id": id}} -> assert_eq(id, 42)
        _ -> throw("failed")
    end
}

map_mixed_types_keys() = {
    m = %{1: "one", "two": 2}
    match m
        %{1: s, "two": n} -> {
            assert_eq(s, "one")
            assert_eq(n, 2)
        }
        _ -> throw("failed")
    end
}

map_pin_key() = {
    key = "dynamic_key"
    m = %{"dynamic_key": "value"}
    match m
        %{^key: v} -> assert_eq(v, "value")
        _ -> throw("failed")
    end
}

map_with_list() = {
    m = %{"items": [1, 2, 3]}
    match m
        %{"items": [1, 2, x]} -> assert_eq(x, 3)
        _ -> throw("failed")
    end
}

map_with_tuple() = {
    m = %{"coord": (10, 20)}
    match m
        %{"coord": (x, y)} -> assert_eq(x + y, 30)
        _ -> throw("failed")
    end
}

set_simple_match() = {
    s = #{1, 2, 3}
    match s
        #{1} -> true
        _ -> throw("failed")
    end
}

set_multiple_match() = {
    s = #{1, 2, 3}
    match s
        #{1, 3} -> true
        _ -> throw("failed")
    end
}

set_missing_value() = {
    s = #{1, 2}
    res = match s
        #{3} -> false
        _ -> true
    end
    assert(res)
}

set_string_match() = {
    s = #{"a", "b"}
    match s
        #{"a"} -> true
        _ -> throw("failed")
    end
}

set_mixed_types() = {
    s = #{1, "a", true}
    match s
        #{1, "a", true} -> true
        _ -> throw("failed")
    end
}

set_pin_match() = {
    x = 42
    s = #{1, 42, 3}
    match s
        #{^x} -> true
        _ -> throw("failed")
    end
}

# Complex structures in Sets are tricky because of hashing/equality
# Ideally we should support them if the VM supports them in sets
# For now, let's stick to simpler set elements to ensure stability
# set_pin_complex() = {
#     complex = [1, 2]
#     s = #{complex, [3]}
#     match s
#         #{^complex} -> true
#         _ -> throw("failed")
# }

list_containing_map() = {
    l = [%{"a": 1}, %{"b": 2}]
    match l
        [%{"a": 1} | t] -> true
        _ -> throw("failed")
    end
}

list_containing_set() = {
    l = [#{1, 2}, #{3}]
    x = 1
    match l
        [#{^x} | _] -> true
        _ -> throw("failed")
    end
}

tuple_containing_map() = {
    t = (%{"ok": true}, "status")
    match t
        (%{"ok": true}, _) -> true
        _ -> throw("failed")
    end
}

tuple_containing_set() = {
    t = (#{"admin"}, "user")
    match t
        (#{"admin"}, _) -> true
        _ -> throw("failed")
    end
}

nested_deep_1() = {
    # Map -> List -> Tuple -> Set
    complex = %{"data": [(1, #{10, 20})]}
    match complex
        %{"data": [(1, #{10})]} -> true
        _ -> throw("failed")
    end
}

nested_deep_2() = {
    # List -> Map -> Set
    complex = [%{"ids": #{1, 2, 3}}]
    match complex
        [%{"ids": #{2}}] -> true
        _ -> throw("failed")
    end
}

nested_deep_3() = {
    # Tuple -> List -> Map
    complex = ([%{"x": 1}], 2)
    match complex
        ([%{"x": 1}], _) -> true
        _ -> throw("failed")
    end
}

map_empty() = {
    m = %{}
    match m
        %{} -> true
        _ -> throw("failed")
    end
}

set_empty() = {
    s = #{}
    match s
        #{} -> true
        _ -> throw("failed")
    end
}

map_match_fails_on_set() = {
    s = #{}
    res = match s
        %{} -> false
        _ -> true
    end
    assert(res)
}

set_match_fails_on_map() = {
    m = %{}
    res = match m
        #{} -> false
        _ -> true
    end
    assert(res)
}

nested_structure_binding() = {
    data = %{
        "users": [
            %{"id": 1, "groups": #{"admin", "editor"}},
            %{"id": 2, "groups": #{"editor"}}
        ]
    }
    
    match data
        %{"users": [%{"id": 1, "groups": #{"admin"}} | _]} -> true
        _ -> throw("failed")
    end
}

nested_list_tail_map() = {
    l = [%{"a": 1}, %{"b": 2}]
    match l
        [_ | [%{"b": 2}]] -> true
        _ -> throw("failed")
    end
}

nested_tuple_deconstruct() = {
    data = %{"point": (10, 20)}
    match data
        %{"point": (x, y)} -> assert_eq(x + y, 30)
        _ -> throw("failed")
    end
}

map_keys_expressions() = {
    # Keys in pattern map can be expressions (literals)
    # m = %{1+1: "two"}
    # match m
    #     %{2: "two"} -> true # 2 matches 1+1
    #     _ -> throw("failed")
    true
}

set_with_bools() = {
    s = #{true, false}
    match s
        #{true, false} -> true
        _ -> throw("failed")
    end
}

complex_mix_1() = {
    v = (1, [2, %{"a": #{3}}])
    match v
        (1, [2, %{"a": #{3}}]) -> true
        _ -> throw("failed")
    end
}

complex_mix_2() = {
    v = %{"a": [1, 2], "b": #{3}}
    match v
        %{"a": [1, 2], "b": #{3}} -> true
        _ -> throw("failed")
    end
}

main() = {
    println("Running map_simple_match")
    map_simple_match()
    println("Running map_bind_value")
    map_bind_value()
    println("Running map_missing_key_fail")
    map_missing_key_fail()
    println("Running map_value_mismatch")
    map_value_mismatch()
    println("Running map_nested_map")
    map_nested_map()
    println("Running map_nested_bind")
    map_nested_bind()
    println("Running map_mixed_types_keys")
    map_mixed_types_keys()
    println("Running map_pin_key")
    map_pin_key()
    println("Running map_with_list")
    map_with_list()
    println("Running map_with_tuple")
    map_with_tuple()
    println("Running set_simple_match")
    set_simple_match()
    println("Running set_multiple_match")
    set_multiple_match()
    println("Running set_missing_value")
    set_missing_value()
    println("Running set_string_match")
    set_string_match()
    println("Running set_mixed_types")
    set_mixed_types()
    println("Running set_pin_match")
    set_pin_match()
    # set_pin_complex()
    println("Running list_containing_map")
    list_containing_map()
    println("Running list_containing_set")
    list_containing_set()
    println("Running tuple_containing_map")
    tuple_containing_map()
    println("Running tuple_containing_set")
    tuple_containing_set()
    println("Running nested_deep_1")
    nested_deep_1()
    println("Running nested_deep_2")
    nested_deep_2()
    println("Running nested_deep_3")
    nested_deep_3()
    println("Running map_empty")
    map_empty()
    println("Running set_empty")
    set_empty()
    println("Running map_match_fails_on_set")
    map_match_fails_on_set()
    println("Running map_match_fails_on_set")
    map_match_fails_on_set()
    println("Running set_match_fails_on_map")
    set_match_fails_on_map()
    println("Running nested_structure_binding")
    nested_structure_binding()
    println("Running nested_list_tail_map")
    nested_list_tail_map()
    println("Running nested_tuple_deconstruct")
    nested_tuple_deconstruct()
    println("Running map_keys_expressions")
    map_keys_expressions()
    println("Running set_with_bools")
    set_with_bools()
    println("Running complex_mix_1")
    complex_mix_1()
    println("Running complex_mix_2")
    complex_mix_2()
    
    true
}