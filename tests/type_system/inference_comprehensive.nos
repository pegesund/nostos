# expect: 0
# Comprehensive type inference tests

# === Basic Inference ===

# 1. Integer literal
test1() = { x = 42; x }

# 2. Float literal
test2() = { x = 3.14; x }

# 3. String literal
test3() = { x = "hello"; x }

# 4. Boolean literal
test4() = { x = true; x }

# 5. List of integers
test5() = { x = [1, 2, 3]; x }

# 6. Empty list with usage context
test6() = { x = []; y = 1 :: x; y }

# 7. Tuple inference
test7() = { x = (1, "two", 3.0); x }

# 8. Map literal
test8() = { x = %{"a": 1, "b": 2}; x }

# 9. Set literal
test9() = { x = #{1, 2, 3}; x }

# 10. Option Some
test10() = { x = Some(42); x }

# 11. Option None with context
test11() = { x = if true then Some(1) else None(); x }

# === Arithmetic Inference ===

# 12. Add integers
test12() = { x = 1; y = 2; x + y }

# 13. Add floats
test13() = { x = 1.0; y = 2.0; x + y }

# 14. Mixed int/float (coercion)
test14() = { x = 1; y = 2.0; x + y }

# 15. Chained arithmetic
test15() = { a = 1; b = 2; c = 3; a + b * c }

# === Function Return Type Inference ===

# 16. Return type from expression
double(x) = x * 2

# 17. Return type from conditional
abs(x) = if x < 0 then -x else x

# 18. Return type from match
describeNum(n) = match n {
    0 -> "zero"
    1 -> "one"
    _ -> "many"
}

# === Closure Inference ===

# 19. Simple closure
test19() = {
    f = x => x + 1
    f(5)
}

# 20. Closure with multiple args
test20() = {
    f = (x, y) => x + y
    f(3, 4)
}

# 21. Closure capturing variable
test21() = {
    a = 10
    f = x => x + a
    f(5)
}

# 22. Closure returning closure
test22() = {
    makeAdder = n => (x => x + n)
    add5 = makeAdder(5)
    add5(10)
}

# 23. Closure in map
test23() = {
    nums = [1, 2, 3]
    doubled = nums.map(x => x * 2)
    doubled
}

# 24. Closure in filter
test24() = {
    nums = [1, 2, 3, 4, 5]
    evens = nums.filter(x => x % 2 == 0)
    evens
}

# 25. Closure in fold
test25() = {
    nums = [1, 2, 3, 4]
    sum = foldr(nums, 0, (x, acc) => acc + x)
    sum
}

# 26. Nested closures
test26() = {
    outer = x => {
        inner = y => x + y
        inner(10)
    }
    outer(5)
}

# === Generic Function Inference ===

# 27. Identity function
identity(x) = x

test27() = identity(42)

# 28. Pair creation
makePair(a, b) = (a, b)

test28() = makePair(1, "one")

# 29. First of pair
first(pair) = match pair { (a, _) -> a }

test29() = first((1, 2))

# 30. Generic with constraint
maxVal[T: Ord](a: T, b: T) -> T = if a > b then a else b

test30() = maxVal(10, 20)

# 31. Generic with Num constraint
triple[T: Num](x: T) -> T = x + x + x

test31() = triple(7)

# === Record Inference ===

type Point = { x: Int, y: Int }
type Person = { name: String, age: Int }

# 32. Record construction
test32() = { p = Point(3, 4); p }

# 33. Record field access
test33() = { p = Point(3, 4); p.x + p.y }

# 34. Record in function
distance(p: Point) = p.x * p.x + p.y * p.y

test34() = distance(Point(3, 4))

# 35. Record update (functional)
moveRight(p: Point) = Point(p.x + 1, p.y)

test35() = moveRight(Point(0, 0)).x

# === Variant Inference ===

type Shape = Circle(Int) | Rectangle(Int, Int) | Square(Int)

# 36. Variant construction
test36() = { s = Circle(5); s }

# 37. Variant in match
area(s: Shape) = match s {
    Circle(r) -> r * r * 3
    Rectangle(w, h) -> w * h
    Square(side) -> side * side
}

test37() = area(Rectangle(3, 4))

# 38. Variant returned from function
defaultShape() = Square(1)

test38() = area(defaultShape())

# === Trait Method Inference ===

trait Describable
    describe(self) -> String
end

Point: Describable
    describe(self) = "Point(" ++ show(self.x) ++ ", " ++ show(self.y) ++ ")"
end

# 39. Trait method call
test39() = Point(1, 2).describe()

# 40. Generic with custom trait
describeIt[T: Describable](x: T) -> String = x.describe()

test40() = describeIt(Point(5, 5))

# === Higher-Order Function Inference ===

# 41. Function as argument
applyTwice(f, x) = f(f(x))

test41() = applyTwice(x => x + 1, 0)

# 42. Function returning function
compose(f, g) = x => f(g(x))

test42() = {
    addOne = x => x + 1
    double = x => x * 2
    addOneThenDouble = compose(double, addOne)
    addOneThenDouble(5)
}

# 43. Partial application simulation
add(x, y) = x + y

test43() = {
    add5 = y => add(5, y)
    add5(10)
}

# === Complex Inference Scenarios ===

# 44. List of functions
test44() = {
    funcs = [x => x + 1, x => x * 2, x => x - 3]
    funcs
}

# 45. Nested data structures
test45() = {
    data = [%{"name": "Alice", "scores": [90, 85, 92]},
            %{"name": "Bob", "scores": [78, 82, 88]}]
    data
}

# 46. Chain of method calls
test46() = {
    nums = [1, 2, 3, 4, 5]
        .map(x => x * 2)
        .filter(x => x > 4)
    result = foldr(nums, 0, (x, acc) => x + acc)
    result
}

# 47. Option chaining - using match since Option.map has issues
test47() = {
    x = Some(5)
    match x {
        Some(n) -> Some(n * 2)
        None() -> None()
    }
}

# 48. Recursive function type inference
factorial(n) = if n <= 1 then 1 else n * factorial(n - 1)

test48() = factorial(5)

# 49. Mutual recursion type inference
isEven(n) = if n == 0 then true else isOdd(n - 1)
isOdd(n) = if n == 0 then false else isEven(n - 1)

test49() = isEven(10)

# 50. Complex closure with record
test50() = {
    people = [Person("Alice", 30), Person("Bob", 25), Person("Charlie", 35)]
    oldest = foldr(people, Person("", 0), (p, acc) => if p.age > acc.age then p else acc)
    oldest.name
}

# 51. Lambda with pattern matching simulation
test51() = {
    pairs = [(1, "a"), (2, "b"), (3, "c")]
    keys = pairs.map(p => match p { (k, _) -> k })
    keys
}

# 52. Closure modifying captured mutable
test52() = {
    nums = [1, 2, 3]
    doubled = nums.map(x => x * 2)
    tripled = nums.map(x => x * 3)
    (doubled, tripled)
}

# 53. Inference through multiple lets
test53() = {
    a = 1
    b = a + 1
    c = b + 1
    d = c + 1
    e = d + 1
    e
}

# 54. Type from comparison result
test54() = {
    x = 5
    y = 10
    isLess = x < y
    isLess
}

# 55. String operations inference
test55() = {
    s = "hello"
    upper = String.toUpper(s)
    len = String.length(s)
    (upper, len)
}

# === Run all tests ===

main() = {
    # Basic inference
    assert_eq(42, test1())
    assert_eq(3.14, test2())
    assert_eq("hello", test3())
    assert_eq(true, test4())
    assert_eq([1, 2, 3], test5())
    assert_eq([1], test6())
    assert_eq((1, "two", 3.0), test7())
    m = %{"a": 1}
    assert_eq(1, Map.get(m, "a"))
    assert_eq(true, Set.contains(#{1, 2, 3}, 2))
    assert_eq(Some(42), test10())
    assert_eq(Some(1), test11())

    # Arithmetic
    assert_eq(3, test12())
    assert_eq(3.0, test13())
    assert_eq(3.0, test14())
    assert_eq(7, test15())

    # Functions
    assert_eq(10, double(5))
    assert_eq(5, abs(-5))
    assert_eq("zero", describeNum(0))

    # Closures
    assert_eq(6, test19())
    assert_eq(7, test20())
    assert_eq(15, test21())
    assert_eq(15, test22())
    assert_eq([2, 4, 6], test23())
    assert_eq([2, 4], test24())
    assert_eq(10, test25())
    assert_eq(15, test26())

    # Generics
    assert_eq(42, test27())
    assert_eq((1, "one"), test28())
    assert_eq(1, test29())
    assert_eq(20, test30())
    assert_eq(21, test31())

    # Records
    assert_eq(3, test32().x)
    assert_eq(7, test33())
    assert_eq(25, test34())
    assert_eq(1, test35())

    # Variants
    assert_eq(12, test37())
    assert_eq(1, test38())

    # Traits
    assert_eq("Point(1, 2)", test39())
    assert_eq("Point(5, 5)", test40())

    # Higher-order
    assert_eq(2, test41())
    assert_eq(12, test42())
    assert_eq(15, test43())

    # Complex
    assert_eq(24, test46())
    assert_eq(Some(10), test47())
    assert_eq(120, test48())
    assert_eq(true, test49())
    assert_eq("Charlie", test50())
    assert_eq([1, 2, 3], test51())
    assert_eq(5, test53())
    assert_eq(true, test54())
    assert_eq(5, String.length("hello"))

    0
}
