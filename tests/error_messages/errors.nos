# Error Message Test Cases
# This file contains realistic error scenarios to test and improve error messages

# =============================================================================
# CATEGORY 1: Type Mismatches (10 cases)
# =============================================================================

# 1. Adding incompatible types
# test1() = 1 + "hello"

# 2. Mixed types in list
# test2() = [1, 2, "three", 4]

# 3. Wrong return type
# test3() -> Int = "hello"

# 4. Wrong argument type
# add(a: Int, b: Int) = a + b
# test4() = add(1, "two")

# 5. Condition not boolean
# test5() = if 42 then 1 else 2

# 6. List operation with wrong type
# test6() = [1, 2, 3].map(x => x ++ "!")

# 7. Wrong field type in record
# type Point = {x: Int, y: Int}
# test7() = Point(x: "hello", y: 2)

# 8. Comparing incompatible types
# test8() = "hello" > 5

# 9. Pattern match type mismatch
# test9() = match "hello" { 1 -> "one" }

# 10. If branches return different types
# test10() = if true then 1 else "two"


# =============================================================================
# CATEGORY 2: Undefined Variables/Functions (10 cases)
# =============================================================================

# 11. Simple undefined variable
# test11() = x

# 12. Undefined function call
# test12() = foo(1, 2)

# 13. Undefined in method chain
# test13() = x.map(y => y * 2)

# 14. Undefined in condition
# test14() = if flag then 1 else 2

# 15. Undefined in match
# test15() = match val { 1 -> "one" }

# 16. Typo in variable name
# test16() = { count = 10; coutn + 1 }

# 17. Undefined method on list
# test17() = [1, 2, 3].foo()

# 18. Undefined field access
# test18() = { p = (1, 2); p.z }

# 19. Undefined in lambda
# test19() = [1,2,3].map(x => x + y)

# 20. Undefined type constructor
# test20() = Foo(1, 2)


# =============================================================================
# CATEGORY 3: Function Arity Errors (8 cases)
# =============================================================================

# 21. Too few arguments
# add(a, b) = a + b
# test21() = add(1)

# 22. Too many arguments
# double(x) = x * 2
# test22() = double(1, 2)

# 23. No arguments when expected
# greet(name) = "Hello, " ++ name
# test23() = greet()

# 24. Arguments when none expected
# answer() = 42
# test24() = answer(1)

# 25. Wrong arity in method call
# test25() = [1,2,3].map()

# 26. Wrong arity in lambda
# test26() = [1,2,3].fold(0)

# 27. Partial application attempt (not supported)
# test27() = { f = add(1); f(2) }

# 28. Constructor with wrong arity
# type Box[T] = Box(T)
# test28() = Box(1, 2)


# =============================================================================
# CATEGORY 4: Syntax Errors (12 cases)
# =============================================================================

# 29. Missing closing brace
# test29() = { x = 1

# 30. Missing closing paren
# test30() = (1 + 2

# 31. Missing closing bracket
# test31() = [1, 2, 3

# 32. Missing equals in binding
# test32() = { x 10 }

# 33. Missing then in if
# test33() = if true 1 else 2

# 34. Missing arrow in match
# test34() = match x { 1 "one" }

# 35. Double operators
# test35() = 1 ++ 2

# 36. Trailing comma in tuple
# test36() = (1, 2,)

# 37. Empty block
# test37() = { }

# 38. Empty match
# test38() = match x { }

# 39. Missing body after =
# test39() =

# 40. Invalid character
# test40() = 1 @ 2


# =============================================================================
# CATEGORY 5: Pattern Matching Errors (8 cases)
# =============================================================================

# 41. Non-exhaustive match (missing cases)
# type Color = Red | Green | Blue
# test41(c: Color) = match c { Red -> 1 }

# 42. Duplicate pattern
# test42(x) = match x { 1 -> "a", 1 -> "b" }

# 43. Wrong pattern structure
# test43((a, b, c)) = a  # called with 2-tuple

# 44. Guard without pattern variable
# test44(x) = match x { _ when y > 0 -> 1 }

# 45. Invalid record pattern
# type Point = {x: Int, y: Int}
# test45(Point{z}) = z

# 46. Wrong variant pattern
# type Option[T] = Some(T) | None
# test46(opt) = match opt { Just(x) -> x }

# 47. List pattern on non-list
# test47((x | xs)) = x  # expects tuple, not list

# 48. Missing pattern variable
# test48() = match (1, 2) { (a, ) -> a }


# =============================================================================
# CATEGORY 6: Type Definition Errors (6 cases)
# =============================================================================

# 49. Duplicate type name
# type Foo = {x: Int}
# type Foo = {y: Int}

# 50. Recursive type without indirection
# type Bad = {next: Bad}

# 51. Unknown type in definition
# type Wrapper = {value: UnknownType}

# 52. Invalid type parameter
# type Box[t] = Box(t)  # lowercase type param

# 53. Duplicate field name
# type Bad = {x: Int, x: String}

# 54. Duplicate constructor name
# type Bad = Foo | Foo


# =============================================================================
# CATEGORY 7: Method/Field Access Errors (6 cases)
# =============================================================================

# 55. Field access on non-record
# test55() = { x = 42; x.foo }

# 56. Method without parens
# test56() = "hello".length

# 57. Index out of bounds (runtime)
# test57() = [1, 2, 3][10]

# 58. Negative index
# test58() = [1, 2, 3][-1]

# 59. Wrong tuple index
# test59() = (1, 2).5

# 60. Chained methods on wrong type
# test60() = 42.map(x => x).filter(x => x)


# Test runner - uncomment individual tests to check error messages
main() = {
    println("Error message testing")
}
