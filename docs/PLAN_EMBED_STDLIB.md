# Plan: Embed stdlib in Binary

## Goal

Create a standalone Nostos binary that includes the stdlib, eliminating the need for separate installers or stdlib directories. The binary extracts stdlib to `~/.nostos/stdlib/` on first run if not present.

## Benefits

- Single binary distribution - no installer needed
- Works on any machine without setup
- Still allows users to override with custom stdlib
- Cache system continues to work as-is

## Implementation Steps

### Step 1: Add build.rs to embed stdlib files

Create `crates/cli/build.rs`:

```rust
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=../../stdlib");

    let stdlib_dir = Path::new("../../stdlib");
    let out_dir = std::env::var("OUT_DIR").unwrap();

    let mut entries = Vec::new();
    collect_nos_files(stdlib_dir, stdlib_dir, &mut entries);

    // Generate embedded stdlib module
    let mut code = String::from("pub const EMBEDDED_STDLIB: &[(&str, &str)] = &[\n");
    for (rel_path, content) in &entries {
        // Escape the content properly
        code.push_str(&format!("    ({:?}, {:?}),\n", rel_path, content));
    }
    code.push_str("];\n");

    // Also embed CORE_MODULES if it exists
    let core_modules_path = stdlib_dir.join("CORE_MODULES");
    if core_modules_path.exists() {
        let content = fs::read_to_string(&core_modules_path).unwrap_or_default();
        code.push_str(&format!("\npub const EMBEDDED_CORE_MODULES: &str = {:?};\n", content));
    } else {
        code.push_str("\npub const EMBEDDED_CORE_MODULES: &str = \"\";\n");
    }

    fs::write(Path::new(&out_dir).join("embedded_stdlib.rs"), code).unwrap();
}

fn collect_nos_files(base: &Path, dir: &Path, entries: &mut Vec<(String, String)>) {
    if let Ok(read_dir) = fs::read_dir(dir) {
        for entry in read_dir.flatten() {
            let path = entry.path();
            if path.is_dir() {
                collect_nos_files(base, &path, entries);
            } else if path.extension().map_or(false, |e| e == "nos") {
                if let Ok(content) = fs::read_to_string(&path) {
                    let rel_path = path.strip_prefix(base).unwrap();
                    entries.push((rel_path.to_string_lossy().to_string(), content));
                }
            }
        }
    }
}
```

### Step 2: Include generated code in main.rs

Add to `crates/cli/src/main.rs`:

```rust
// Include the embedded stdlib generated by build.rs
include!(concat!(env!("OUT_DIR"), "/embedded_stdlib.rs"));
```

### Step 3: Add extraction function

Add to `crates/cli/src/main.rs`:

```rust
/// Extract embedded stdlib to ~/.nostos/stdlib/ if not present
fn ensure_stdlib_extracted() -> Option<PathBuf> {
    let home = dirs::home_dir()?;
    let stdlib_dir = home.join(".nostos").join("stdlib");

    // Check if stdlib already exists and has files
    if stdlib_dir.is_dir() {
        let has_files = fs::read_dir(&stdlib_dir)
            .map(|mut d| d.next().is_some())
            .unwrap_or(false);
        if has_files {
            return Some(stdlib_dir);
        }
    }

    // Extract embedded stdlib
    println!("Extracting stdlib to {}...", stdlib_dir.display());

    for (rel_path, content) in EMBEDDED_STDLIB {
        let file_path = stdlib_dir.join(rel_path);
        if let Some(parent) = file_path.parent() {
            fs::create_dir_all(parent).ok()?;
        }
        fs::write(&file_path, content).ok()?;
    }

    // Write CORE_MODULES
    if !EMBEDDED_CORE_MODULES.is_empty() {
        fs::write(stdlib_dir.join("CORE_MODULES"), EMBEDDED_CORE_MODULES).ok()?;
    }

    println!("Stdlib extracted successfully.");
    Some(stdlib_dir)
}
```

### Step 4: Modify find_stdlib_path()

Update `find_stdlib_path()` to call extraction as fallback:

```rust
fn find_stdlib_path() -> Option<PathBuf> {
    // First, check local directories (for development)
    let candidates = vec![
        PathBuf::from("stdlib"),
        PathBuf::from("../stdlib"),
    ];

    for candidate in &candidates {
        if candidate.is_dir() {
            return Some(candidate.clone());
        }
    }

    // Try relative to executable
    if let Ok(mut p) = std::env::current_exe() {
        p.pop();
        p.pop();
        p.pop();
        p.push("stdlib");
        if p.is_dir() {
            return Some(p);
        }
    }

    // Check home directory
    if let Some(home) = dirs::home_dir() {
        let home_stdlib = home.join(".nostos").join("stdlib");
        if home_stdlib.is_dir() {
            return Some(home_stdlib);
        }
    }

    // Last resort: extract embedded stdlib
    ensure_stdlib_extracted()
}
```

### Step 5: Handle --build-cache with embedded stdlib

The `--build-cache` command should work with the extracted stdlib. No changes needed if extraction happens first.

### Step 6: Add version check for stdlib updates

To handle stdlib updates between versions, add a version marker:

```rust
// In build.rs, also generate:
pub const STDLIB_VERSION: &str = env!("CARGO_PKG_VERSION");

// In ensure_stdlib_extracted(), check version:
let version_file = stdlib_dir.join(".version");
let current_version = fs::read_to_string(&version_file).unwrap_or_default();
if current_version.trim() == STDLIB_VERSION {
    return Some(stdlib_dir); // Already up to date
}

// Extract and update version
// ... extraction code ...
fs::write(&version_file, STDLIB_VERSION).ok()?;
```

## Files to Modify

| File | Changes |
|------|---------|
| `crates/cli/build.rs` | New file - embeds stdlib at compile time |
| `crates/cli/Cargo.toml` | Add `build = "build.rs"` |
| `crates/cli/src/main.rs` | Add `include!()`, `ensure_stdlib_extracted()`, modify `find_stdlib_path()` |

## Testing Plan

1. Build release: `cargo build --release`
2. Copy binary to temp location: `cp target/release/nostos /tmp/nostos-test`
3. Clear any existing stdlib: `rm -rf ~/.nostos/stdlib`
4. Run: `/tmp/nostos-test` - should extract stdlib automatically
5. Run again: `/tmp/nostos-test` - should use extracted stdlib (no extraction message)
6. Run hello world: `echo 'main() = println("Hello")' | /tmp/nostos-test /dev/stdin`
7. Build cache: `/tmp/nostos-test --build-cache` - should work with extracted stdlib

## Binary Size Impact

Estimated stdlib size: ~200-300KB of source code
Compressed in binary: ~50-100KB additional to binary size

This is acceptable for the convenience of standalone distribution.

## Future Considerations

- Could add `--extract-stdlib <path>` flag for manual extraction
- Could add `--use-embedded-stdlib` to skip extraction and use in-memory
- Could compress embedded stdlib with `include_bytes!` + runtime decompression
