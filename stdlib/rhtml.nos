# RHtml - Reactive HTML
#
# Same API as Html, but with component boundaries for reactive updates.
# Use RHtml(...) syntax like Html(...) - tag names are auto-resolved.

# The RNode type (HTML tree)
pub type RNode =
    | Element(String, List[(String, String)], List[RNode])
    | Text(String)
    | Raw(String)
    | Empty
    | Component(String)  # just the name, content comes from renderers

# Component tree - reflects hierarchy of components with their IDs
pub type ComponentTree =
    | CNode(String, List[ComponentTree])  # name, children

# Result of an RHtml render
# tree: the HTML tree with Component placeholders
# deps: reactive record ID -> component names that read it
# components: component hierarchy
# renderers: component name -> render function (returns RHtmlResult)
# changedIds: reactive record IDs that were modified during this render
pub type RHtmlResult = { tree: RNode, deps: Map[Int, List[String]], components: List[ComponentTree], renderers: Map[String, () -> RHtmlResult], changedIds: List[Int] }

# === wrapNode helper ===
# Creates an RHtmlResult from an RNode (for internal use)
# Users should use RHtml(...) macro which handles tag name transformation

pub wrapNode(node: RNode) = RHtmlResult(tree: node, deps: %{}, components: [], renderers: %{}, changedIds: [])

# === Attribute helpers ===

pub attr(name: String, value: String) = (name, value)

# Filter out empty attribute values and merge with extra attrs
pub filterEmptyAttrs(attrs: List[(String, String)]) =
    attrs.filter(attr => attr.1 != "")

pub buildAttrs(named: List[(String, String)], extra: List[(String, String)]) =
    filterEmptyAttrs(named) ++ extra

# === Text and special ===

pub text(str: String) = Text(str)
pub raw(str: String) = Raw(str)
pub empty() = Empty

# === Component ===
# component(name, renderFn) is handled specially by the compiler
# It stores the function, calls it, merges deps, and returns Component(name)
# This stub is for type checking only
pub component(name: String, renderFn: () -> RHtmlResult) = Component(name)

# === Tag functions with named parameters ===
# Each tag supports:
#   - Old style: tag(children) or tag(attrs, children)
#   - New style: tag(children, class: "...", id: "...", ...)

# --- Container elements with common attrs ---

pub div(children: List[RNode], class = "", id = "", style = "", dataTestid = "", attrs = []) =
    Element("div", buildAttrs([("class", class), ("id", id), ("style", style), ("data-testid", dataTestid)], attrs), children)
pub div(str: String, class = "", id = "", style = "", dataTestid = "", attrs = []) =
    Element("div", buildAttrs([("class", class), ("id", id), ("style", style), ("data-testid", dataTestid)], attrs), [Text(str)])

pub span(children: List[RNode], class = "", id = "", style = "", dataTestid = "", attrs = []) =
    Element("span", buildAttrs([("class", class), ("id", id), ("style", style), ("data-testid", dataTestid)], attrs), children)
pub span(str: String, class = "", id = "", style = "", dataTestid = "", attrs = []) =
    Element("span", buildAttrs([("class", class), ("id", id), ("style", style), ("data-testid", dataTestid)], attrs), [Text(str)])

pub p(children: List[RNode], class = "", id = "", style = "", dataTestid = "", attrs = []) =
    Element("p", buildAttrs([("class", class), ("id", id), ("style", style), ("data-testid", dataTestid)], attrs), children)
pub p(str: String, class = "", id = "", style = "", dataTestid = "", attrs = []) =
    Element("p", buildAttrs([("class", class), ("id", id), ("style", style), ("data-testid", dataTestid)], attrs), [Text(str)])

# --- Headings ---

pub h1(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("h1", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub h1(str: String, class = "", id = "", style = "", attrs = []) =
    Element("h1", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), [Text(str)])

pub h2(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("h2", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub h2(str: String, class = "", id = "", style = "", attrs = []) =
    Element("h2", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), [Text(str)])

pub h3(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("h3", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub h3(str: String, class = "", id = "", style = "", attrs = []) =
    Element("h3", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), [Text(str)])

pub h4(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("h4", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub h4(str: String, class = "", id = "", style = "", attrs = []) =
    Element("h4", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), [Text(str)])

pub h5(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("h5", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub h5(str: String, class = "", id = "", style = "", attrs = []) =
    Element("h5", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), [Text(str)])

pub h6(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("h6", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub h6(str: String, class = "", id = "", style = "", attrs = []) =
    Element("h6", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), [Text(str)])

# --- Lists ---

pub ul(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("ul", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub ol(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("ol", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)

pub li(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("li", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub li(str: String, class = "", id = "", style = "", attrs = []) =
    Element("li", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), [Text(str)])

# --- Tables ---

pub table(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("table", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub thead(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("thead", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub tbody(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("tbody", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub tr(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("tr", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)

pub th(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("th", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub th(str: String, class = "", id = "", style = "", attrs = []) =
    Element("th", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), [Text(str)])

pub td(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("td", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub td(str: String, class = "", id = "", style = "", attrs = []) =
    Element("td", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), [Text(str)])

# --- Semantic elements ---

pub nav(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("nav", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub header(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("header", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub footer(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("footer", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub section(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("section", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub article(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("article", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub aside(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("aside", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)
pub main(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("main", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)

pub html(children: List[RNode], attrs = []) = Element("html", attrs, children)
pub headEl(children: List[RNode], attrs = []) = Element("head", attrs, children)
pub body(children: List[RNode], class = "", id = "", style = "", attrs = []) =
    Element("body", buildAttrs([("class", class), ("id", id), ("style", style)], attrs), children)

# --- Form elements ---

# Form with novalidate option to disable HTML5 validation
pub form(children: List[RNode], action = "", method = "", class = "", id = "", novalidate = "", dataAction = "", attrs = []) =
    Element("form", buildAttrs([("action", action), ("method", method), ("class", class), ("id", id), ("novalidate", novalidate), ("data-action", dataAction)], attrs), children)

pub button(children: List[RNode], btnType = "", class = "", id = "", onclick = "", disabled = "", dataAction = "", dataTestid = "", attrs = []) =
    Element("button", buildAttrs([("type", btnType), ("class", class), ("id", id), ("onclick", onclick), ("disabled", disabled), ("data-action", dataAction), ("data-testid", dataTestid)], attrs), children)
pub button(str: String, btnType = "", class = "", id = "", onclick = "", disabled = "", dataAction = "", dataTestid = "", attrs = []) =
    Element("button", buildAttrs([("type", btnType), ("class", class), ("id", id), ("onclick", onclick), ("disabled", disabled), ("data-action", dataAction), ("data-testid", dataTestid)], attrs), [Text(str)])

pub label(children: List[RNode], forId = "", class = "", id = "", attrs = []) =
    Element("label", buildAttrs([("for", forId), ("class", class), ("id", id)], attrs), children)
pub label(str: String, forId = "", class = "", id = "", attrs = []) =
    Element("label", buildAttrs([("for", forId), ("class", class), ("id", id)], attrs), [Text(str)])

# Textarea with HTML5 validation attributes
pub textarea(str: String, name = "", placeholder = "", rows = "", cols = "", class = "", id = "", required = "", minLength = "", maxLength = "", dataOnchange = "", dataOninput = "", attrs = []) =
    Element("textarea", buildAttrs([("name", name), ("placeholder", placeholder), ("rows", rows), ("cols", cols), ("class", class), ("id", id), ("required", required), ("minlength", minLength), ("maxlength", maxLength), ("data-onchange", dataOnchange), ("data-oninput", dataOninput)], attrs), [Text(str)])

# Select with required attribute
pub select(children: List[RNode], name = "", class = "", id = "", required = "", dataOnchange = "", dataTestid = "", attrs = []) =
    Element("select", buildAttrs([("name", name), ("class", class), ("id", id), ("required", required), ("data-onchange", dataOnchange), ("data-testid", dataTestid)], attrs), children)

pub option(str: String, value = "", selected = "", attrs = []) =
    Element("option", buildAttrs([("value", value), ("selected", selected)], attrs), [Text(str)])

# --- Text formatting ---

pub title(str: String) = Element("title", [], [Text(str)])
pub strong(str: String, class = "", id = "", attrs = []) =
    Element("strong", buildAttrs([("class", class), ("id", id)], attrs), [Text(str)])
pub em(str: String, class = "", id = "", attrs = []) =
    Element("em", buildAttrs([("class", class), ("id", id)], attrs), [Text(str)])
pub code(str: String, class = "", id = "", attrs = []) =
    Element("code", buildAttrs([("class", class), ("id", id)], attrs), [Text(str)])
pub pre(str: String, class = "", id = "", attrs = []) =
    Element("pre", buildAttrs([("class", class), ("id", id)], attrs), [Text(str)])
pub small(str: String, class = "", id = "", attrs = []) =
    Element("small", buildAttrs([("class", class), ("id", id)], attrs), [Text(str)])

# --- Self-closing tags ---

pub br() = Element("br", [], [])
pub hr(class = "", id = "", attrs = []) =
    Element("hr", buildAttrs([("class", class), ("id", id)], attrs), [])

pub img(src = "", alt = "", width = "", height = "", class = "", id = "", attrs = []) =
    Element("img", buildAttrs([("src", src), ("alt", alt), ("width", width), ("height", height), ("class", class), ("id", id)], attrs), [])

# Input with HTML5 validation attributes
# required: "required" to make field required
# minLength/maxLength: min/max character length
# pattern: regex pattern for validation
# min/max: for number inputs
pub input(inputType = "", name = "", value = "", placeholder = "", class = "", id = "", checked = "", disabled = "", readonly = "", required = "", minLength = "", maxLength = "", pattern = "", min = "", max = "", dataOnchange = "", dataOninput = "", dataTestid = "", attrs = []) =
    Element("input", buildAttrs([("type", inputType), ("name", name), ("value", value), ("placeholder", placeholder), ("class", class), ("id", id), ("checked", checked), ("disabled", disabled), ("readonly", readonly), ("required", required), ("minlength", minLength), ("maxlength", maxLength), ("pattern", pattern), ("min", min), ("max", max), ("data-onchange", dataOnchange), ("data-oninput", dataOninput), ("data-testid", dataTestid)], attrs), [])

pub meta(name = "", content = "", charset = "", attrs = []) =
    Element("meta", buildAttrs([("name", name), ("content", content), ("charset", charset)], attrs), [])

pub linkTag(rel = "", href = "", linkType = "", attrs = []) =
    Element("link", buildAttrs([("rel", rel), ("href", href), ("type", linkType)], attrs), [])

# --- Links ---

pub a(children: List[RNode], href = "", target = "", class = "", id = "", attrs = []) =
    Element("a", buildAttrs([("href", href), ("target", target), ("class", class), ("id", id)], attrs), children)
pub a(str: String, href = "", target = "", class = "", id = "", attrs = []) =
    Element("a", buildAttrs([("href", href), ("target", target), ("class", class), ("id", id)], attrs), [Text(str)])

# --- Script tag for raw JavaScript ---

# Script block for embedding JavaScript
# The content is NOT escaped - it's inserted as-is
# Named scriptBlock to avoid conflict with html.script(src) for external scripts
pub scriptBlock(js: String, attrs = []) = Element("script", attrs, [Raw(js)])

# --- JavaScript Action Helpers ---
# These generate rweb.sendAction() calls for use in onclick, oninput, etc.

# Escape a string for use in JavaScript string literals
pub escapeJsChar(c: Char) = match c {
    '\'' -> "\\'"
    '"' -> "\\\""
    '\\' -> "\\\\"
    '\n' -> "\\n"
    '\r' -> "\\r"
    '\t' -> "\\t"
    _ -> String.from_chars([c])
}

pub escapeJsChars(chars: List[Char]) = match chars {
    [] -> ""
    [c | rest] -> escapeJsChar(c) ++ escapeJsChars(rest)
}

pub escapeJs(s: String) = escapeJsChars(String.chars(s))

# Generate rweb.sendAction() call with no params
# Usage: button("Ping", onclick: action("ping"))
# Output: rweb.sendAction('ping', {})
pub action(name: String) =
    "rweb.sendAction('" ++ escapeJs(name) ++ "', {})"

# Generate rweb.sendAction() call with static params (values known at render time)
# Usage: button("Delete", onclick: action("delete", %{"id" -> "42"}))
# Output: rweb.sendAction('delete', {id: '42'})
pub actionParamToJs(key: String, value: String) =
    "'" ++ escapeJs(key) ++ "': '" ++ escapeJs(value) ++ "'"

pub actionParamsToJs(params: List[(String, String)]) = match params {
    [] -> ""
    [(k, v)] -> actionParamToJs(k, v)
    [(k, v) | rest] -> actionParamToJs(k, v) ++ ", " ++ actionParamsToJs(rest)
}

pub action(name: String, params: Map[String, String]) =
    "rweb.sendAction('" ++ escapeJs(name) ++ "', {" ++ actionParamsToJs(Map.toList(params)) ++ "})"

# Generate rweb.sendAction() call with dynamic JS expressions (evaluated in browser)
# Usage: button("Search", onclick: actionJs("search", [("query", "document.getElementById('q').value")]))
# Output: rweb.sendAction('search', {query: document.getElementById('q').value})
# Note: The values are JS expressions, NOT quoted strings
pub actionJsParamToJs(key: String, jsExpr: String) =
    "'" ++ escapeJs(key) ++ "': " ++ jsExpr

pub actionJsParamsToJs(params: List[(String, String)]) = match params {
    [] -> ""
    [(k, v)] -> actionJsParamToJs(k, v)
    [(k, v) | rest] -> actionJsParamToJs(k, v) ++ ", " ++ actionJsParamsToJs(rest)
}

pub actionJs(name: String, jsParams: List[(String, String)]) =
    "rweb.sendAction('" ++ escapeJs(name) ++ "', {" ++ actionJsParamsToJs(jsParams) ++ "})"

# Generic element constructor
pub el(tag: String, attrs: List[(String, String)], children: List[RNode]) = Element(tag, attrs, children)

# === Rendering ===

# Render RHtmlResult - uses renderers map for component content
pub renderRHtml(result: RHtmlResult) = {
    buf = Buffer.new()
    renderToBuffer(result.tree, result.renderers, buf)
    Buffer.toString(buf)
}

# Render RNode directly (no component support)
pub renderRNode(rhtml: RNode) = {
    buf = Buffer.new()
    renderToBuffer(rhtml, %{}, buf)
    Buffer.toString(buf)
}

pub renderToBuffer(rhtml: RNode, renderers: Map[String, () -> RHtmlResult], buf) = match rhtml {
    Element(tag, attrs, children) -> {
        Buffer.append(buf, "<")
        Buffer.append(buf, tag)
        renderAttrs(attrs, buf)
        if isSelfClosing(tag) then {
            Buffer.append(buf, " />")
        } else {
            Buffer.append(buf, ">")
            renderChildrenToBuffer(children, renderers, buf)
            Buffer.append(buf, "</")
            Buffer.append(buf, tag)
            Buffer.append(buf, ">")
        }
    }
    Text(s) -> Buffer.append(buf, escapeHtml(s))
    Raw(s) -> Buffer.append(buf, s)
    Empty -> ()
    Component(name) -> {
        Buffer.append(buf, "<div id=\"")
        Buffer.append(buf, name)
        Buffer.append(buf, "\" data-component=\"true\">")
        # Look up and call the render function for this component
        if Map.contains(renderers, name) then {
            renderFn = Map.get(renderers, name)
            childResult = renderFn()
            renderToBuffer(childResult.tree, childResult.renderers, buf)
        } else ()
        Buffer.append(buf, "</div>")
    }
}

pub renderChildrenToBuffer(children: List[RNode], renderers: Map[String, () -> RHtmlResult], buf) = match children {
    [] -> ()
    [child | rest] -> {
        renderToBuffer(child, renderers, buf)
        renderChildrenToBuffer(rest, renderers, buf)
    }
}

pub renderAttrs(attrs: List[(String, String)], buf) = match attrs {
    [] -> ()
    [(name, value) | rest] -> {
        Buffer.append(buf, " ")
        Buffer.append(buf, name)
        Buffer.append(buf, "=\"")
        Buffer.append(buf, escapeHtml(value))
        Buffer.append(buf, "\"")
        renderAttrs(rest, buf)
    }
}

pub isSelfClosing(tag: String) = match tag {
    "br" -> true
    "hr" -> true
    "img" -> true
    "input" -> true
    "meta" -> true
    "link" -> true
    _ -> false
}

pub escapeChar(c: Char) = match c {
    '<' -> "&lt;"
    '>' -> "&gt;"
    '&' -> "&amp;"
    '"' -> "&quot;"
    '\'' -> "&#39;"
    _ -> String.from_chars([c])
}

pub escapeHtmlChars(chars: List[Char]) = match chars {
    [] -> ""
    [c | rest] -> escapeChar(c) ++ escapeHtmlChars(rest)
}

pub escapeHtml(str: String) = escapeHtmlChars(String.chars(str))

# === State Transition Helpers ===

# Get component names affected by a reactive record change
pub affectedComponents(deps: Map[Int, List[String]], recordId: Int) =
    if Map.contains(deps, recordId) then Map.get(deps, recordId)
    else []

# Helper: check if list contains string
pub listContainsStr(list: List[String], s: String) = match list {
    [] -> false
    [x | rest] -> if x == s then true else listContainsStr(rest, s)
}

# Helper: add item to list if not present
pub addUniqueStr(items: List[String], acc: List[String]) = match items {
    [] -> acc
    [x | rest] ->
        if listContainsStr(acc, x) then addUniqueStr(rest, acc)
        else addUniqueStr(rest, [x | acc])
}

# Helper: union of two lists (no duplicates)
pub unionStrLists(a: List[String], b: List[String]) = addUniqueStr(b, a)

# Collect affected components from multiple records
pub collectAffectedHelper(deps: Map[Int, List[String]], ids: List[Int], acc: List[String]) = match ids {
    [] -> acc
    [id | rest] -> {
        affected = affectedComponents(deps, id)
        collectAffectedHelper(deps, rest, unionStrLists(acc, affected))
    }
}

# Get components affected by multiple record changes (union)
pub affectedComponentsMulti(deps: Map[Int, List[String]], recordIds: List[Int]) =
    collectAffectedHelper(deps, recordIds, [])

# Helper: check if any item from list1 is in list2
pub anyInList(list1: List[String], list2: List[String]) = match list1 {
    [] -> false
    [x | rest] -> if listContainsStr(list2, x) then true else anyInList(rest, list2)
}

# Build ancestry map from component trees
pub buildAncestryMap(trees, ancestors, acc) = match trees {
    [] -> acc
    [CNode(name, children) | rest] -> {
        newAcc = Map.insert(acc, name, ancestors)
        newAncestors = [name | ancestors]
        childAcc = buildAncestryMap(children, newAncestors, newAcc)
        buildAncestryMap(rest, ancestors, childAcc)
    }
}

# Filter list of affected names to only keep outermost
pub filterAffectedList(affected: List[String], ancestryMap: Map[String, List[String]], acc: List[String]) = match affected {
    [] -> acc
    [name | rest] -> {
        ancestors = if Map.contains(ancestryMap, name) then Map.get(ancestryMap, name) else []
        hasAffectedAncestor = anyInList(ancestors, affected)
        if hasAffectedAncestor then filterAffectedList(rest, ancestryMap, acc)
        else filterAffectedList(rest, ancestryMap, [name | acc])
    }
}

# Filter affected components to only the outermost ones
pub filterOutermost(affected, components) = {
    ancestryMap = buildAncestryMap(components, [], %{})
    filterAffectedList(affected, ancestryMap, [])
}

# === Update State ===

# Re-render a list of component names, collecting results
# Each render function is called with the component name on the render stack
# so that deps are tracked correctly
pub reRenderComponents(names, renderers, acc) = match names {
    [] -> acc
    [name | rest] ->
        if Map.contains(renderers, name) then {
            renderFn = Map.get(renderers, name)
            # Push component name to render stack for dep tracking
            RenderStack.push(name)
            result = renderFn()
            RenderStack.pop()
            reRenderComponents(rest, renderers, [(name, result) | acc])
        } else reRenderComponents(rest, renderers, acc)
}

# Helper for integer lists (for deps keys)
pub listContainsInt(list, n) = match list {
    [] -> false
    [x | rest] -> if x == n then true else listContainsInt(rest, n)
}

pub addUniqueInt(items, acc) = match items {
    [] -> acc
    [x | rest] ->
        if listContainsInt(acc, x) then addUniqueInt(rest, acc)
        else addUniqueInt(rest, [x | acc])
}

pub unionIntLists(a, b) = addUniqueInt(b, a)

# Merge two deps maps (union the component lists for each key)
pub mergeDeps(deps1, deps2, keys, acc) = match keys {
    [] -> acc
    [key | rest] -> {
        list1 = if Map.contains(deps1, key) then Map.get(deps1, key) else []
        list2 = if Map.contains(deps2, key) then Map.get(deps2, key) else []
        merged = unionStrLists(list1, list2)
        mergeDeps(deps1, deps2, rest, Map.insert(acc, key, merged))
    }
}

# Merge deps from a single re-rendered component
pub mergeSingleDeps(baseDeps, componentResult) = {
    newDeps = componentResult.deps
    allKeys = unionIntLists(Map.keys(baseDeps), Map.keys(newDeps))
    mergeDeps(baseDeps, newDeps, allKeys, %{})
}

# Merge renderers: second map overwrites first for same keys
pub mergeRenderers(r1, r2, keys, acc) = match keys {
    [] -> acc
    [key | rest] ->
        if Map.contains(r2, key) then
            mergeRenderers(r1, r2, rest, Map.insert(acc, key, Map.get(r2, key)))
        else if Map.contains(r1, key) then
            mergeRenderers(r1, r2, rest, Map.insert(acc, key, Map.get(r1, key)))
        else
            mergeRenderers(r1, r2, rest, acc)
}

# Merge renderers from a single re-rendered component
pub mergeSingleRenderers(baseRenderers, componentResult) = {
    newRenderers = componentResult.renderers
    allKeys = unionStrLists(Map.keys(baseRenderers), Map.keys(newRenderers))
    mergeRenderers(baseRenderers, newRenderers, allKeys, %{})
}

# Build map from component name to its new children (from re-rendered results)
pub buildChildrenMap(reRendered, acc) = match reRendered {
    [] -> acc
    [(name, result) | rest] ->
        buildChildrenMap(rest, Map.insert(acc, name, result.components))
}

# Update component trees: replace children of re-rendered components
pub updateTrees(trees, childrenMap) = match trees {
    [] -> []
    [CNode(name, children) | rest] ->
        if Map.contains(childrenMap, name) then {
            # This component was re-rendered, use its new children
            newChildren = Map.get(childrenMap, name)
            [CNode(name, newChildren) | updateTrees(rest, childrenMap)]
        } else {
            # Recurse into children
            [CNode(name, updateTrees(children, childrenMap)) | updateTrees(rest, childrenMap)]
        }
}

# Remove component names from a deps list
pub removeFromList(toRemove, list) = match list {
    [] -> []
    [x | rest] ->
        if listContainsStr(toRemove, x) then removeFromList(toRemove, rest)
        else [x | removeFromList(toRemove, rest)]
}

# Remove affected components from all deps entries
pub removeFromDeps(deps, toRemove, keys, acc) = match keys {
    [] -> acc
    [key | rest] -> {
        components = Map.get(deps, key)
        filtered = removeFromList(toRemove, components)
        removeFromDeps(deps, toRemove, rest, Map.insert(acc, key, filtered))
    }
}

# === Component Cleanup (for removed subcomponents) ===

# Collect all component names from a tree (including descendants)
pub collectComponentNames(trees, acc) = match trees {
    [] -> acc
    [CNode(name, children) | rest] -> {
        withName = [name | acc]
        withChildren = collectComponentNames(children, withName)
        collectComponentNames(rest, withChildren)
    }
}

# Get old children for a component from the component tree
pub getOldChildren(componentName, trees) = match trees {
    [] -> []
    [CNode(name, children) | rest] ->
        if name == componentName then children
        else {
            # Check in children recursively
            found = getOldChildren(componentName, children)
            match found {
                [] -> getOldChildren(componentName, rest)
                _ -> found
            }
        }
}

# Find components that were removed (in old but not in new)
pub findRemovedNames(oldNames, newNames, acc) = match oldNames {
    [] -> acc
    [name | rest] ->
        if listContainsStr(newNames, name) then findRemovedNames(rest, newNames, acc)
        else findRemovedNames(rest, newNames, [name | acc])
}

# Remove keys from a map
pub removeFromMap(map, keysToRemove) = match keysToRemove {
    [] -> map
    [key | rest] -> removeFromMap(Map.remove(map, key), rest)
}

# Find all removed components when re-rendering a list of components
# Returns list of all component names that should be cleaned up
pub findAllRemovedComponents(reRendered, componentTree, acc) = match reRendered {
    [] -> acc
    [(name, result) | rest] -> {
        # Get old children from original tree
        oldChildren = getOldChildren(name, componentTree)
        oldNames = collectComponentNames(oldChildren, [])

        # Get new children from re-rendered result
        newChildren = result.components
        newNames = collectComponentNames(newChildren, [])

        # Find names in old but not in new
        removed = findRemovedNames(oldNames, newNames, [])

        findAllRemovedComponents(rest, componentTree, unionStrLists(acc, removed))
    }
}

# Merge all deps and renderers from re-rendered results
pub mergeAllResults(baseDeps, baseRenderers, reRendered) = match reRendered {
    [] -> (baseDeps, baseRenderers)
    [(_, result) | rest] -> {
        newDeps = mergeSingleDeps(baseDeps, result)
        newRenderers = mergeSingleRenderers(baseRenderers, result)
        mergeAllResults(newDeps, newRenderers, rest)
    }
}

# Main state update function
pub updateState(state, changedRecordIds) = {
    affected = affectedComponentsMulti(state.deps, changedRecordIds)
    outermost = filterOutermost(affected, state.components)
    reRendered = reRenderComponents(outermost, state.renderers, [])

    # Find components that were removed during re-render
    removedComponents = findAllRemovedComponents(reRendered, state.components, [])

    # Components to clean from deps: affected + removed
    allToClean = unionStrLists(affected, removedComponents)
    cleanedDeps = removeFromDeps(state.deps, allToClean, Map.keys(state.deps), %{})

    # Remove stale renderers for removed components
    cleanedRenderers = removeFromMap(state.renderers, removedComponents)

    # Merge new deps and renderers from re-rendered results
    (mergedDeps, mergedRenderers) = mergeAllResults(cleanedDeps, cleanedRenderers, reRendered)

    # Update component tree
    childrenMap = buildChildrenMap(reRendered, %{})
    newComponents = updateTrees(state.components, childrenMap)

    # Use record update syntax to create new RHtmlResult with updated fields
    # changedIds is cleared since we just processed these changes
    RHtmlResult(state, deps: mergedDeps, components: newComponents, renderers: mergedRenderers, changedIds: [])
}

