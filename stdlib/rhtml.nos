# RHtml - Reactive HTML
#
# Same API as Html, but with component boundaries for reactive updates.
# Use RHtml(...) syntax like Html(...) - tag names are auto-resolved.

# The RNode type (HTML tree)
type RNode =
    | Element(String, List[(String, String)], List[RNode])
    | Text(String)
    | Raw(String)
    | Empty
    | Component(String)  # just the name, content comes from renderers

# Component tree - reflects hierarchy of components with their IDs
type ComponentTree =
    | CNode(String, List[ComponentTree])  # name, children

# Result of an RHtml render
# tree: the HTML tree with Component placeholders
# deps: reactive record ID -> component names that read it
# components: component hierarchy
# renderers: component name -> render function (returns RHtmlResult)
# changedIds: reactive record IDs that were modified during this render
type RHtmlResult = { tree: RNode, deps: Map[Int, List[String]], components: List[ComponentTree], renderers: Map[String, () -> RHtmlResult], changedIds: List[Int] }

# === wrapNode helper ===
# Creates an RHtmlResult from an RNode (for internal use)
# Users should use RHtml(...) macro which handles tag name transformation

wrapNode(node: RNode) = RHtmlResult(tree: node, deps: %{}, components: [], renderers: %{}, changedIds: [])

# === Attribute helper ===

attr(name: String, value: String) = (name, value)

# === Text and special ===

text(str: String) = Text(str)
raw(str: String) = Raw(str)
empty() = Empty

# === Component ===
# component(name, renderFn) is handled specially by the compiler
# It stores the function, calls it, merges deps, and returns Component(name)
# This stub is for type checking only
component(name: String, renderFn: () -> RHtmlResult) = Component(name)

# === Tag functions (same as Html) ===

div(children: List[RNode]) = Element("div", [], children)
div(str: String) = Element("div", [], [Text(str)])
div(attrs: List[(String, String)], children: List[RNode]) = Element("div", attrs, children)
div(attrs: List[(String, String)], str: String) = Element("div", attrs, [Text(str)])

span(children: List[RNode]) = Element("span", [], children)
span(str: String) = Element("span", [], [Text(str)])
span(attrs: List[(String, String)], children: List[RNode]) = Element("span", attrs, children)
span(attrs: List[(String, String)], str: String) = Element("span", attrs, [Text(str)])

p(children: List[RNode]) = Element("p", [], children)
p(str: String) = Element("p", [], [Text(str)])
p(attrs: List[(String, String)], children: List[RNode]) = Element("p", attrs, children)
p(attrs: List[(String, String)], str: String) = Element("p", attrs, [Text(str)])

h1(children: List[RNode]) = Element("h1", [], children)
h1(str: String) = Element("h1", [], [Text(str)])

h2(children: List[RNode]) = Element("h2", [], children)
h2(str: String) = Element("h2", [], [Text(str)])

h3(children: List[RNode]) = Element("h3", [], children)
h3(str: String) = Element("h3", [], [Text(str)])

button(children: List[RNode]) = Element("button", [], children)
button(str: String) = Element("button", [], [Text(str)])
button(attrs: List[(String, String)], children: List[RNode]) = Element("button", attrs, children)
button(attrs: List[(String, String)], str: String) = Element("button", attrs, [Text(str)])

ul(children: List[RNode]) = Element("ul", [], children)
ol(children: List[RNode]) = Element("ol", [], children)
li(children: List[RNode]) = Element("li", [], children)
li(str: String) = Element("li", [], [Text(str)])

table(children: List[RNode]) = Element("table", [], children)
thead(children: List[RNode]) = Element("thead", [], children)
tbody(children: List[RNode]) = Element("tbody", [], children)
tr(children: List[RNode]) = Element("tr", [], children)
th(children: List[RNode]) = Element("th", [], children)
th(str: String) = Element("th", [], [Text(str)])
td(children: List[RNode]) = Element("td", [], children)
td(str: String) = Element("td", [], [Text(str)])

nav(children: List[RNode]) = Element("nav", [], children)
header(children: List[RNode]) = Element("header", [], children)
footer(children: List[RNode]) = Element("footer", [], children)
section(children: List[RNode]) = Element("section", [], children)
article(children: List[RNode]) = Element("article", [], children)
form(children: List[RNode]) = Element("form", [], children)
form(attrs: List[(String, String)], children: List[RNode]) = Element("form", attrs, children)

html(children: List[RNode]) = Element("html", [], children)
headEl(children: List[RNode]) = Element("head", [], children)
body(children: List[RNode]) = Element("body", [], children)
title(str: String) = Element("title", [], [Text(str)])

# Self-closing
br() = Element("br", [], [])
hr() = Element("hr", [], [])
img(attrs: List[(String, String)]) = Element("img", attrs, [])
input(attrs: List[(String, String)]) = Element("input", attrs, [])

# With attributes
a(attrs: List[(String, String)], children: List[RNode]) = Element("a", attrs, children)
a(attrs: List[(String, String)], str: String) = Element("a", attrs, [Text(str)])
el(tag: String, attrs: List[(String, String)], children: List[RNode]) = Element(tag, attrs, children)

# === Rendering ===

# Render RHtmlResult - uses renderers map for component content
renderRHtml(result: RHtmlResult) = {
    buf = Buffer.new()
    renderToBuffer(result.tree, result.renderers, buf)
    Buffer.toString(buf)
}

# Render RNode directly (no component support)
renderRNode(rhtml: RNode) = {
    buf = Buffer.new()
    renderToBuffer(rhtml, %{}, buf)
    Buffer.toString(buf)
}

renderToBuffer(rhtml: RNode, renderers: Map[String, () -> RHtmlResult], buf) = match rhtml {
    Element(tag, attrs, children) -> {
        Buffer.append(buf, "<")
        Buffer.append(buf, tag)
        renderAttrs(attrs, buf)
        if isSelfClosing(tag) then {
            Buffer.append(buf, " />")
        } else {
            Buffer.append(buf, ">")
            renderChildrenToBuffer(children, renderers, buf)
            Buffer.append(buf, "</")
            Buffer.append(buf, tag)
            Buffer.append(buf, ">")
        }
    }
    Text(s) -> Buffer.append(buf, escapeHtml(s))
    Raw(s) -> Buffer.append(buf, s)
    Empty -> ()
    Component(name) -> {
        Buffer.append(buf, "<div id=\"")
        Buffer.append(buf, name)
        Buffer.append(buf, "\" data-component=\"true\">")
        # Look up and call the render function for this component
        if Map.contains(renderers, name) then {
            renderFn = Map.get(renderers, name)
            childResult = renderFn()
            renderToBuffer(childResult.tree, childResult.renderers, buf)
        } else ()
        Buffer.append(buf, "</div>")
    }
}

renderChildrenToBuffer(children: List[RNode], renderers: Map[String, () -> RHtmlResult], buf) = match children {
    [] -> ()
    [child | rest] -> {
        renderToBuffer(child, renderers, buf)
        renderChildrenToBuffer(rest, renderers, buf)
    }
}

renderAttrs(attrs: List[(String, String)], buf) = match attrs {
    [] -> ()
    [(name, value) | rest] -> {
        Buffer.append(buf, " ")
        Buffer.append(buf, name)
        Buffer.append(buf, "=\"")
        Buffer.append(buf, escapeHtml(value))
        Buffer.append(buf, "\"")
        renderAttrs(rest, buf)
    }
}

isSelfClosing(tag: String) = match tag {
    "br" -> true
    "hr" -> true
    "img" -> true
    "input" -> true
    "meta" -> true
    "link" -> true
    _ -> false
}

escapeChar(c: Char) = match c {
    '<' -> "&lt;"
    '>' -> "&gt;"
    '&' -> "&amp;"
    '"' -> "&quot;"
    '\'' -> "&#39;"
    _ -> String.from_chars([c])
}

escapeHtmlChars(chars: List[Char]) = match chars {
    [] -> ""
    [c | rest] -> escapeChar(c) ++ escapeHtmlChars(rest)
}

escapeHtml(str: String) = escapeHtmlChars(String.chars(str))

# === State Transition Helpers ===

# Get component names affected by a reactive record change
affectedComponents(deps: Map[Int, List[String]], recordId: Int) =
    if Map.contains(deps, recordId) then Map.get(deps, recordId)
    else []

# Helper: check if list contains string
listContainsStr(list: List[String], s: String) = match list {
    [] -> false
    [x | rest] -> if x == s then true else listContainsStr(rest, s)
}

# Helper: add item to list if not present
addUniqueStr(items: List[String], acc: List[String]) = match items {
    [] -> acc
    [x | rest] ->
        if listContainsStr(acc, x) then addUniqueStr(rest, acc)
        else addUniqueStr(rest, [x | acc])
}

# Helper: union of two lists (no duplicates)
unionStrLists(a: List[String], b: List[String]) = addUniqueStr(b, a)

# Collect affected components from multiple records
collectAffectedHelper(deps: Map[Int, List[String]], ids: List[Int], acc: List[String]) = match ids {
    [] -> acc
    [id | rest] -> {
        affected = affectedComponents(deps, id)
        collectAffectedHelper(deps, rest, unionStrLists(acc, affected))
    }
}

# Get components affected by multiple record changes (union)
affectedComponentsMulti(deps: Map[Int, List[String]], recordIds: List[Int]) =
    collectAffectedHelper(deps, recordIds, [])

# Helper: check if any item from list1 is in list2
anyInList(list1: List[String], list2: List[String]) = match list1 {
    [] -> false
    [x | rest] -> if listContainsStr(list2, x) then true else anyInList(rest, list2)
}

# Build ancestry map from component trees
buildAncestryMap(trees, ancestors, acc) = match trees {
    [] -> acc
    [CNode(name, children) | rest] -> {
        newAcc = Map.insert(acc, name, ancestors)
        newAncestors = [name | ancestors]
        childAcc = buildAncestryMap(children, newAncestors, newAcc)
        buildAncestryMap(rest, ancestors, childAcc)
    }
}

# Filter list of affected names to only keep outermost
filterAffectedList(affected: List[String], ancestryMap: Map[String, List[String]], acc: List[String]) = match affected {
    [] -> acc
    [name | rest] -> {
        ancestors = if Map.contains(ancestryMap, name) then Map.get(ancestryMap, name) else []
        hasAffectedAncestor = anyInList(ancestors, affected)
        if hasAffectedAncestor then filterAffectedList(rest, ancestryMap, acc)
        else filterAffectedList(rest, ancestryMap, [name | acc])
    }
}

# Filter affected components to only the outermost ones
filterOutermost(affected, components) = {
    ancestryMap = buildAncestryMap(components, [], %{})
    filterAffectedList(affected, ancestryMap, [])
}

# === Update State ===

# Re-render a list of component names, collecting results
# Each render function is called with the component name on the render stack
# so that deps are tracked correctly
reRenderComponents(names, renderers, acc) = match names {
    [] -> acc
    [name | rest] ->
        if Map.contains(renderers, name) then {
            renderFn = Map.get(renderers, name)
            # Push component name to render stack for dep tracking
            RenderStack.push(name)
            result = renderFn()
            RenderStack.pop()
            reRenderComponents(rest, renderers, [(name, result) | acc])
        } else reRenderComponents(rest, renderers, acc)
}

# Helper for integer lists (for deps keys)
listContainsInt(list, n) = match list {
    [] -> false
    [x | rest] -> if x == n then true else listContainsInt(rest, n)
}

addUniqueInt(items, acc) = match items {
    [] -> acc
    [x | rest] ->
        if listContainsInt(acc, x) then addUniqueInt(rest, acc)
        else addUniqueInt(rest, [x | acc])
}

unionIntLists(a, b) = addUniqueInt(b, a)

# Merge two deps maps (union the component lists for each key)
mergeDeps(deps1, deps2, keys, acc) = match keys {
    [] -> acc
    [key | rest] -> {
        list1 = if Map.contains(deps1, key) then Map.get(deps1, key) else []
        list2 = if Map.contains(deps2, key) then Map.get(deps2, key) else []
        merged = unionStrLists(list1, list2)
        mergeDeps(deps1, deps2, rest, Map.insert(acc, key, merged))
    }
}

# Merge deps from a single re-rendered component
mergeSingleDeps(baseDeps, componentResult) = {
    newDeps = componentResult.deps
    allKeys = unionIntLists(Map.keys(baseDeps), Map.keys(newDeps))
    mergeDeps(baseDeps, newDeps, allKeys, %{})
}

# Merge renderers: second map overwrites first for same keys
mergeRenderers(r1, r2, keys, acc) = match keys {
    [] -> acc
    [key | rest] ->
        if Map.contains(r2, key) then
            mergeRenderers(r1, r2, rest, Map.insert(acc, key, Map.get(r2, key)))
        else if Map.contains(r1, key) then
            mergeRenderers(r1, r2, rest, Map.insert(acc, key, Map.get(r1, key)))
        else
            mergeRenderers(r1, r2, rest, acc)
}

# Merge renderers from a single re-rendered component
mergeSingleRenderers(baseRenderers, componentResult) = {
    newRenderers = componentResult.renderers
    allKeys = unionStrLists(Map.keys(baseRenderers), Map.keys(newRenderers))
    mergeRenderers(baseRenderers, newRenderers, allKeys, %{})
}

# Build map from component name to its new children (from re-rendered results)
buildChildrenMap(reRendered, acc) = match reRendered {
    [] -> acc
    [(name, result) | rest] ->
        buildChildrenMap(rest, Map.insert(acc, name, result.components))
}

# Update component trees: replace children of re-rendered components
updateTrees(trees, childrenMap) = match trees {
    [] -> []
    [CNode(name, children) | rest] ->
        if Map.contains(childrenMap, name) then {
            # This component was re-rendered, use its new children
            newChildren = Map.get(childrenMap, name)
            [CNode(name, newChildren) | updateTrees(rest, childrenMap)]
        } else {
            # Recurse into children
            [CNode(name, updateTrees(children, childrenMap)) | updateTrees(rest, childrenMap)]
        }
}

# Remove component names from a deps list
removeFromList(toRemove, list) = match list {
    [] -> []
    [x | rest] ->
        if listContainsStr(toRemove, x) then removeFromList(toRemove, rest)
        else [x | removeFromList(toRemove, rest)]
}

# Remove affected components from all deps entries
removeFromDeps(deps, toRemove, keys, acc) = match keys {
    [] -> acc
    [key | rest] -> {
        components = Map.get(deps, key)
        filtered = removeFromList(toRemove, components)
        removeFromDeps(deps, toRemove, rest, Map.insert(acc, key, filtered))
    }
}

# === Component Cleanup (for removed subcomponents) ===

# Collect all component names from a tree (including descendants)
collectComponentNames(trees, acc) = match trees {
    [] -> acc
    [CNode(name, children) | rest] -> {
        withName = [name | acc]
        withChildren = collectComponentNames(children, withName)
        collectComponentNames(rest, withChildren)
    }
}

# Get old children for a component from the component tree
getOldChildren(componentName, trees) = match trees {
    [] -> []
    [CNode(name, children) | rest] ->
        if name == componentName then children
        else {
            # Check in children recursively
            found = getOldChildren(componentName, children)
            match found {
                [] -> getOldChildren(componentName, rest)
                _ -> found
            }
        }
}

# Find components that were removed (in old but not in new)
findRemovedNames(oldNames, newNames, acc) = match oldNames {
    [] -> acc
    [name | rest] ->
        if listContainsStr(newNames, name) then findRemovedNames(rest, newNames, acc)
        else findRemovedNames(rest, newNames, [name | acc])
}

# Remove keys from a map
removeFromMap(map, keysToRemove) = match keysToRemove {
    [] -> map
    [key | rest] -> removeFromMap(Map.remove(map, key), rest)
}

# Find all removed components when re-rendering a list of components
# Returns list of all component names that should be cleaned up
findAllRemovedComponents(reRendered, componentTree, acc) = match reRendered {
    [] -> acc
    [(name, result) | rest] -> {
        # Get old children from original tree
        oldChildren = getOldChildren(name, componentTree)
        oldNames = collectComponentNames(oldChildren, [])

        # Get new children from re-rendered result
        newChildren = result.components
        newNames = collectComponentNames(newChildren, [])

        # Find names in old but not in new
        removed = findRemovedNames(oldNames, newNames, [])

        findAllRemovedComponents(rest, componentTree, unionStrLists(acc, removed))
    }
}

# Merge all deps and renderers from re-rendered results
mergeAllResults(baseDeps, baseRenderers, reRendered) = match reRendered {
    [] -> (baseDeps, baseRenderers)
    [(_, result) | rest] -> {
        newDeps = mergeSingleDeps(baseDeps, result)
        newRenderers = mergeSingleRenderers(baseRenderers, result)
        mergeAllResults(newDeps, newRenderers, rest)
    }
}

# Main state update function
updateState(state, changedRecordIds) = {
    affected = affectedComponentsMulti(state.deps, changedRecordIds)
    outermost = filterOutermost(affected, state.components)
    reRendered = reRenderComponents(outermost, state.renderers, [])

    # Find components that were removed during re-render
    removedComponents = findAllRemovedComponents(reRendered, state.components, [])

    # Components to clean from deps: affected + removed
    allToClean = unionStrLists(affected, removedComponents)
    cleanedDeps = removeFromDeps(state.deps, allToClean, Map.keys(state.deps), %{})

    # Remove stale renderers for removed components
    cleanedRenderers = removeFromMap(state.renderers, removedComponents)

    # Merge new deps and renderers from re-rendered results
    (mergedDeps, mergedRenderers) = mergeAllResults(cleanedDeps, cleanedRenderers, reRendered)

    # Update component tree
    childrenMap = buildChildrenMap(reRendered, %{})
    newComponents = updateTrees(state.components, childrenMap)

    # Use record update syntax to create new RHtmlResult with updated fields
    # changedIds is cleared since we just processed these changes
    RHtmlResult(state, deps: mergedDeps, components: newComponents, renderers: mergedRenderers, changedIds: [])
}

