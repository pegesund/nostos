# RWeb - Reactive Web Framework
#
# WebSocket-based reactive UI with process-per-session.
# Each client connection spawns a dedicated session process
# that holds reactive state and pushes updates.
#
# Key concept: Action handlers just MUTATE reactive records.
# The VM automatically tracks which records changed, finds affected
# components via the deps map, and re-renders them.
#
# Usage:
#   use stdlib.rweb
#   use stdlib.rhtml
#
#   reactive Counter = { value: Int }
#
#   session() = {
#       counter = Counter(0)
#       (
#           () => RHtml(div([
#               component("display", () => RHtml(
#                   span("Count: " ++ show(counter.value))
#               )),
#               button("+1", dataAction: "increment")
#           ])),
#           (action, params) => match action {
#               "increment" -> { counter.value = counter.value + 1 }
#               _ -> ()
#           }
#       )
#   }
#
#   main() = startRWeb(8080, "My App", session)

use stdlib.server.{serve, respondHtml, respond404, getParam}
use stdlib.rhtml

# --- Client JavaScript ---

clientJs() = "
<script>
(function() {
    var ws = null;
    var reconnectDelay = 1000;

    function connect() {
        var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(protocol + '//' + location.host + '/ws');

        ws.onopen = function() {
            console.log('RWeb connected');
            reconnectDelay = 1000;
        };

        ws.onmessage = function(e) {
            var data = JSON.parse(e.data);
            if (data.type === 'update') {
                // Update component HTML
                var el = document.getElementById(data.component);
                if (el) {
                    el.outerHTML = data.html;
                    bindEvents();
                }
            } else if (data.type === 'full') {
                // Full page update
                document.getElementById('rweb-root').innerHTML = data.html;
                bindEvents();
            }
        };

        ws.onclose = function() {
            console.log('RWeb disconnected, reconnecting...');
            setTimeout(connect, reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, 30000);
        };

        ws.onerror = function(e) {
            console.error('RWeb error', e);
        };
    }

    function sendAction(action, params) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: action, params: params || {} }));
        }
    }

    function bindEvents() {
        // Bind click handlers for data-action elements
        document.querySelectorAll('[data-action]').forEach(function(el) {
            if (!el._rweb_bound) {
                el._rweb_bound = true;
                el.addEventListener('click', function(e) {
                    e.preventDefault();
                    var action = el.getAttribute('data-action');
                    var params = {};
                    // Collect data-param-* attributes
                    for (var i = 0; i < el.attributes.length; i++) {
                        var attr = el.attributes[i];
                        if (attr.name.startsWith('data-param-')) {
                            params[attr.name.substring(11)] = attr.value;
                        }
                    }
                    sendAction(action, params);
                });
            }
        });

        // Bind form submissions
        document.querySelectorAll('form[data-action]').forEach(function(form) {
            if (!form._rweb_bound) {
                form._rweb_bound = true;
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    var action = form.getAttribute('data-action');
                    var params = {};
                    new FormData(form).forEach(function(v, k) { params[k] = v; });
                    sendAction(action, params);
                });
            }
        });

        // Bind change handlers for data-onchange elements
        document.querySelectorAll('[data-onchange]').forEach(function(el) {
            if (!el._rweb_bound) {
                el._rweb_bound = true;
                el.addEventListener('change', function(e) {
                    var action = el.getAttribute('data-onchange');
                    sendAction(action, { value: el.value });
                });
            }
        });
    }

    // Expose sendAction globally for custom use
    window.rweb = { sendAction: sendAction };

    // Connect on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            bindEvents();
            connect();
        });
    } else {
        bindEvents();
        connect();
    }
})();
</script>
"

# --- HTML Page Template ---

pageTemplate(title, content) =
    "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<title>" ++ title ++ "</title>\n</head>\n<body>\n<div id=\"rweb-root\">" ++ content ++ "</div>\n" ++ clientJs() ++ "\n</body>\n</html>"

# --- Session Process ---

# Session process main loop
# renderResult: current render state with deps, components, renderers
# renderPage: () -> RHtmlResult - renders the page (captures state via closure)
# onAction: (action, params) -> () - handles actions by mutating reactive records
sessionLoop(ws, renderResult: RHtmlResult, renderPage, onAction) = {
    result = try {
        msgJson = WebSocket.recv(ws)

        # Parse action from JSON: { "action": "name", "params": {...} }
        (action, params) = parseActionMessage(msgJson)

        # Call user's action handler - just mutates reactive records
        onAction(action, params)

        # Get record IDs that were modified during action handler
        changedIds = Reactive.getChangedRecordIds()

        # Find affected components using deps map
        affected = affectedComponentsMulti(renderResult.deps, changedIds)

        # Filter to outermost (don't re-render children if parent re-renders)
        componentsToUpdate = filterOutermost(affected, renderResult.components)

        # Re-render affected components and send updates
        sendComponentUpdates(ws, componentsToUpdate, renderResult.renderers)

        # Update render state with new deps from re-rendered components
        newRenderResult = updateState(renderResult, changedIds)

        (true, newRenderResult)
    } catch { (kind, msg) -> {
        # WebSocket connection errors include:
        # - kind == "websocket" or "websocket_error" for connection-related errors
        # - kind == "io_error" with "closed" or "not found" messages
        containsClosed = String.contains(msg, "closed")
        containsNotFound = String.contains(msg, "not found")
        isWsError = kind == "websocket" || kind == "websocket_error"
        isIoConnectionError = kind == "io_error" && (containsClosed || containsNotFound)
        isConnectionError = isWsError || isIoConnectionError

        if isConnectionError then (false, renderResult)
        else {
            println("RWeb action error: " ++ msg)
            (true, renderResult)
        }
    } }

    match result {
        (true, newState) -> sessionLoop(ws, newState, renderPage, onAction)
        (false, _) -> WebSocket.close(ws)
    }
}

# Parse JSON action message
parseActionMessage(json) = {
    # Simple JSON parsing for { "action": "name", "params": {...} }
    # For now, just extract action name - params parsing TODO
    action = extractJsonString(json, "action")
    (action, %{})
}

# Extract string value from JSON by key (simple implementation)
extractJsonString(json, key) = {
    searchFor = "\"" ++ key ++ "\""
    startIdx = findSubstring(json, searchFor, 0)
    if startIdx < 0 then ""
    else {
        # Find the colon after key
        colonIdx = findSubstring(json, ":", startIdx)
        # Find the opening quote of value
        quoteStart = findSubstring(json, "\"", colonIdx + 1)
        # Find closing quote
        quoteEnd = findSubstring(json, "\"", quoteStart + 1)
        if quoteEnd > quoteStart then
            String.substring(json, quoteStart + 1, quoteEnd)
        else ""
    }
}

# Find substring starting from index
findSubstring(str, needle, startFrom) = {
    chars = String.chars(str)
    needleChars = String.chars(needle)
    findSubstringHelper(chars, needleChars, startFrom, 0)
}

findSubstringHelper(chars, needle, startFrom, idx) = match chars {
    [] -> -1
    [c | rest] ->
        if idx < startFrom then findSubstringHelper(rest, needle, startFrom, idx + 1)
        else if matchesAt(chars, needle) then idx
        else findSubstringHelper(rest, needle, startFrom, idx + 1)
}

matchesAt(chars, needle) = match needle {
    [] -> true
    [n | nrest] -> match chars {
        [] -> false
        [c | crest] -> if c == n then matchesAt(crest, nrest) else false
    }
}

# Send component updates via WebSocket
sendComponentUpdates(ws, componentNames, renderers) = match componentNames {
    [] -> ()
    [name | rest] -> {
        if Map.contains(renderers, name) then {
            renderFn = Map.get(renderers, name)
            result = renderFn()
            innerHtml = renderRHtml(result)
            # Wrap with component div to preserve the id for future updates
            # This matches the structure created by renderComponent in rhtml.nos
            html = "<div id=\"" ++ name ++ "\" data-component=\"true\">" ++ innerHtml ++ "</div>"
            msg = "{\"type\":\"update\",\"component\":\"" ++ escapeJsonString(name) ++ "\",\"html\":\"" ++ escapeJsonString(html) ++ "\"}"
            WebSocket.send(ws, msg)
        } else ()
        sendComponentUpdates(ws, rest, renderers)
    }
}

# Escape string for JSON
escapeJsonString(s) = escapeJsonChars(String.chars(s))

escapeJsonChars(chars) = match chars {
    [] -> ""
    [c | rest] -> escapeJsonChar(c) ++ escapeJsonChars(rest)
}

escapeJsonChar(c) = match c {
    '"' -> "\\\""
    '\\' -> "\\\\"
    '\n' -> "\\n"
    '\r' -> "\\r"
    '\t' -> "\\t"
    _ -> String.from_chars([c])
}

# --- Request Handler ---

# Handle HTTP requests
rwebHandleRequest(req, title, sessionSetup) = {
    # NOTE: For WebSocket, we MUST call WebSocket.accept BEFORE any println!
    # Otherwise the spawned process blocks stdout before handshake completes
    if req.path == "/" then {
        # Serve initial HTML page - create fresh session for rendering
        (renderPage, _) = sessionSetup()
        result = renderPage()
        html = renderRHtml(result)
        respondHtml(req, pageTemplate(title, html))
    }
    else if req.path == "/ws" && req.isWebSocket then {
        # WebSocket upgrade - accept FIRST before any IO
        ws = WebSocket.accept(req.id)

        # Log session start (after WebSocket.accept to avoid blocking)
        pid = self()
        println("[RWeb] Session started: pid=" ++ show(pid))

        # Create fresh session state for this connection
        (renderPage, onAction) = sessionSetup()
        renderResult = renderPage()

        # Send initial full page HTML
        html = renderRHtml(renderResult)
        msg = "{\"type\":\"full\",\"html\":\"" ++ escapeJsonString(html) ++ "\"}"
        WebSocket.send(ws, msg)

        # Enter session loop (this process becomes the session)
        sessionLoop(ws, renderResult, renderPage, onAction)

        # Session has ended (sessionLoop returned)
        # Run GC and report stats before process exits
        gcResult = Gc.collect()
        stats = Gc.stats()
        println("[RWeb] Session ended: pid=" ++ show(pid) ++
                " | gc collected=" ++ show(gcResult.collected) ++
                " live=" ++ show(stats.live) ++
                " totalAllocated=" ++ show(stats.totalAllocated) ++
                " totalFreed=" ++ show(stats.totalFreed))
    }
    else respond404(req)
}

# --- Main Entry Point ---

# Start the reactive web server
# sessionSetup: () -> (renderPage, onAction) - creates fresh state per session
#   Returns a tuple of:
#   - renderPage: () -> RHtmlResult - renders the page
#   - onAction: (action, params) -> () - handles actions by mutating reactive records
pub startRWeb(port, title, sessionSetup) = {
    println("RWeb server started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws")
    serve(port, req => rwebHandleRequest(req, title, sessionSetup))
}

# --- Multi-Route Support ---

# Client JavaScript that passes current path to WebSocket
clientJsWithRoutes() = "
<script>
(function() {
    var ws = null;
    var reconnectDelay = 1000;

    function connect() {
        var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(protocol + '//' + location.host + '/ws?path=' + encodeURIComponent(location.pathname));

        ws.onopen = function() {
            console.log('RWeb connected for path: ' + location.pathname);
            reconnectDelay = 1000;
        };

        ws.onmessage = function(e) {
            var data = JSON.parse(e.data);
            if (data.type === 'update') {
                var el = document.getElementById(data.component);
                if (el) {
                    el.outerHTML = data.html;
                    bindEvents();
                }
            } else if (data.type === 'full') {
                document.getElementById('rweb-root').innerHTML = data.html;
                bindEvents();
            }
        };

        ws.onclose = function() {
            console.log('RWeb disconnected, reconnecting...');
            setTimeout(connect, reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, 30000);
        };

        ws.onerror = function(e) {
            console.error('RWeb error', e);
        };
    }

    function sendAction(action, params) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: action, params: params || {} }));
        }
    }

    function bindEvents() {
        document.querySelectorAll('[data-action]').forEach(function(el) {
            if (!el._rweb_bound) {
                el._rweb_bound = true;
                el.addEventListener('click', function(e) {
                    e.preventDefault();
                    var action = el.getAttribute('data-action');
                    var params = {};
                    for (var i = 0; i < el.attributes.length; i++) {
                        var attr = el.attributes[i];
                        if (attr.name.startsWith('data-param-')) {
                            params[attr.name.substring(11)] = attr.value;
                        }
                    }
                    sendAction(action, params);
                });
            }
        });

        document.querySelectorAll('form[data-action]').forEach(function(form) {
            if (!form._rweb_bound) {
                form._rweb_bound = true;
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    var action = form.getAttribute('data-action');
                    var params = {};
                    new FormData(form).forEach(function(v, k) { params[k] = v; });
                    sendAction(action, params);
                });
            }
        });

        document.querySelectorAll('[data-onchange]').forEach(function(el) {
            if (!el._rweb_bound) {
                el._rweb_bound = true;
                el.addEventListener('change', function(e) {
                    var action = el.getAttribute('data-onchange');
                    sendAction(action, { value: el.value });
                });
            }
        });
    }

    window.rweb = { sendAction: sendAction };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            bindEvents();
            connect();
        });
    } else {
        bindEvents();
        connect();
    }
})();
</script>
"

# Page template for routed pages
pageTemplateWithRoutes(title, content) =
    "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<title>" ++ title ++ "</title>\n</head>\n<body>\n<div id=\"rweb-root\">" ++ content ++ "</div>\n" ++ clientJsWithRoutes() ++ "\n</body>\n</html>"

# Request handler with routing support using resolver functions
# reactiveResolver: String -> Option[() -> (RenderFn, ActionHandler)] - resolves reactive pages
# plainResolver: String -> Option[Request -> ()] - resolves plain HTML handlers
rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver) = {
    # WebSocket upgrade - check path query param for which session to create
    if req.path == "/ws" && req.isWebSocket then {
        pagePath = getParam(req.queryParams, "path")
        actualPath = if pagePath == "" then "/" else pagePath

        match reactiveResolver(actualPath) {
            Some(sessionSetup) -> {
                # Accept WebSocket FIRST before any IO
                ws = WebSocket.accept(req.id)

                pid = self()
                println("[RWeb] Session started: pid=" ++ show(pid) ++ " path=" ++ actualPath)

                (renderPage, onAction) = sessionSetup()
                renderResult = renderPage()

                # Send initial full page HTML
                html = renderRHtml(renderResult)
                msg = "{\"type\":\"full\",\"html\":\"" ++ escapeJsonString(html) ++ "\"}"
                WebSocket.send(ws, msg)

                # Enter session loop (persistent process)
                sessionLoop(ws, renderResult, renderPage, onAction)

                # Session ended
                gcResult = Gc.collect()
                stats = Gc.stats()
                println("[RWeb] Session ended: pid=" ++ show(pid) ++
                        " | gc collected=" ++ show(gcResult.collected) ++
                        " live=" ++ show(stats.live) ++
                        " totalAllocated=" ++ show(stats.totalAllocated) ++
                        " totalFreed=" ++ show(stats.totalFreed))
            }
            None() -> respond404(req)
        }
    }
    # Check reactive routes - serve initial HTML
    else match reactiveResolver(req.path) {
        Some(sessionSetup) -> {
            (renderPage, _) = sessionSetup()
            result = renderPage()
            html = renderRHtml(result)
            respondHtml(req, pageTemplateWithRoutes(title, html))
        }
        None() -> {
            # Check plain routes - call handler directly
            match plainResolver(req.path) {
                Some(handler) -> handler(req)
                None() -> respond404(req)
            }
        }
    }
}

# Start RWeb server with multiple routes using resolver functions
#
# reactiveResolver: String -> Option[() -> (RenderFn, ActionHandler)]
#   A function that takes a path and returns Some(sessionSetup) or None()
#   sessionSetup: () -> (renderPage, onAction)
#
# plainResolver: String -> Option[Request -> ()]
#   A function that takes a path and returns Some(handler) or None()
#   handler: Request -> ()
#
# Example:
#   homeSession() = {
#       counter = Counter(value: 0)
#       (
#           () => RHtml(div([h1("Home"), span(show(counter.value))])),
#           (action, params) => ()
#       )
#   }
#
#   purchaseSession() = { ... }
#
#   aboutHandler(req) = respondHtml(req, "<h1>About Us</h1>")
#
#   reactiveResolver(path) = match path {
#       "/" -> Some(homeSession)
#       "/purchase" -> Some(purchaseSession)
#       _ -> None()
#   }
#
#   plainResolver(path) = match path {
#       "/about" -> Some(aboutHandler)
#       _ -> None()
#   }
#
#   main() = startRWebWithRoutes(8080, "My App", reactiveResolver, plainResolver)
#
pub startRWebWithRoutes(port, title, reactiveResolver, plainResolver) = {
    println("RWeb server with routes started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws?path=<path>")
    serve(port, req => rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver))
}
