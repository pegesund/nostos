# RWeb - Reactive Web Framework
#
# WebSocket-based reactive UI with process-per-session.
# Each client connection spawns a dedicated session process
# that holds reactive state and pushes updates.
#
# Key concept: Action handlers just MUTATE reactive records.
# The VM automatically tracks which records changed, finds affected
# components via the deps map, and re-renders them.
#
# Usage:
#   use stdlib.rweb
#   use stdlib.rhtml
#
#   reactive Counter = { value: Int }
#
#   session() = {
#       counter = Counter(0)
#       (
#           () => RHtml(div([
#               component("display", () => RHtml(
#                   span("Count: " ++ show(counter.value))
#               )),
#               button("+1", dataAction: "increment")
#           ])),
#           (action, params) => match action {
#               "increment" -> { counter.value = counter.value + 1 }
#               _ -> ()
#           }
#       )
#   }
#
#   main() = startRWeb(8080, "My App", session)

use stdlib.server.{serve, respondHtml, respond404, getParam}
use stdlib.rhtml
use stdlib.json.{jsonParse, Null, Bool, Number, Object, String}
use stdlib.rweb_state.rwebLastServer

# --- Client JavaScript ---

clientJs() = "
<script>
(function() {
    var ws = null;
    var reconnectDelay = 1000;

    function connect() {
        var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(protocol + '//' + location.host + '/ws');

        ws.onopen = function() {
            console.log('RWeb connected');
            reconnectDelay = 1000;
        };

        ws.onmessage = function(e) {
            var data = JSON.parse(e.data);
            if (data.type === 'update') {
                // Update component HTML
                var el = document.getElementById(data.component);
                if (el) {
                    el.outerHTML = data.html;
                    bindEvents();
                }
            } else if (data.type === 'full') {
                // Full page update
                document.getElementById('rweb-root').innerHTML = data.html;
                bindEvents();
            }
        };

        ws.onclose = function() {
            console.log('RWeb disconnected, reconnecting...');
            setTimeout(connect, reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, 30000);
        };

        ws.onerror = function(e) {
            console.error('RWeb error', e);
        };
    }

    function sendAction(action, params) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: action, params: params || {} }));
        }
    }

    function bindEvents() {
        // Bind click handlers for data-action elements (excluding forms)
        document.querySelectorAll('[data-action]:not(form)').forEach(function(el) {
            if (!el._rweb_bound) {
                el._rweb_bound = true;
                el.addEventListener('click', function(e) {
                    e.preventDefault();
                    var action = el.getAttribute('data-action');
                    var params = {};
                    // Collect data-param-* attributes
                    for (var i = 0; i < el.attributes.length; i++) {
                        var attr = el.attributes[i];
                        if (attr.name.startsWith('data-param-')) {
                            params[attr.name.substring(11)] = attr.value;
                        }
                    }
                    sendAction(action, params);
                });
            }
        });

        // Bind form submissions
        document.querySelectorAll('form[data-action]').forEach(function(form) {
            if (!form._rweb_bound) {
                form._rweb_bound = true;
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    var action = form.getAttribute('data-action');
                    var params = {};
                    new FormData(form).forEach(function(v, k) { params[k] = v; });
                    sendAction(action, params);
                });
            }
        });

        // Bind change handlers for data-onchange elements
        document.querySelectorAll('[data-onchange]').forEach(function(el) {
            if (!el._rweb_change_bound) {
                el._rweb_change_bound = true;
                el.addEventListener('change', function(e) {
                    var action = el.getAttribute('data-onchange');
                    var params = { value: el.value };
                    // For checkbox/radio, also send checked state
                    if (el.type === 'checkbox' || el.type === 'radio') {
                        params.checked = el.checked ? 'true' : 'false';
                    }
                    sendAction(action, params);
                });
            }
        });

        // Bind input handlers for data-oninput elements (real-time)
        document.querySelectorAll('[data-oninput]').forEach(function(el) {
            if (!el._rweb_input_bound) {
                el._rweb_input_bound = true;
                el.addEventListener('input', function(e) {
                    var action = el.getAttribute('data-oninput');
                    sendAction(action, { value: el.value });
                });
            }
        });
    }

    // Expose sendAction globally for custom use
    window.rweb = { sendAction: sendAction };

    // Connect on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            bindEvents();
            connect();
        });
    } else {
        bindEvents();
        connect();
    }
})();
</script>
"

# --- HTML Page Template ---

pageTemplate(title, content) =
    "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<title>" ++ title ++ "</title>\n</head>\n<body>\n<div id=\"rweb-root\">" ++ content ++ "</div>\n" ++ clientJs() ++ "\n</body>\n</html>"

# --- Session Process ---

# Helper to check if list is empty
listIsEmpty(xs) = match xs {
    [] -> true
    _ -> false
}

# Send full page update via WebSocket
sendFullPageUpdate(ws, renderPage) = {
    newResult = renderPage()
    html = renderRHtml(newResult)
    msg = "{\"type\":\"full\",\"html\":\"" ++ escapeJsonString(html) ++ "\"}"
    WebSocket.send(ws, msg)
    newResult
}

# Session process main loop
# renderResult: current render state with deps, components, renderers
# renderPage: () -> RHtmlResult - renders the page (captures state via closure)
# onAction: (action, params) -> () - handles actions by mutating reactive records
sessionLoop(ws, renderResult: RHtmlResult, renderPage, onAction) = {
    result = try {
        msgJson = WebSocket.recv(ws)

        # Parse action from JSON: { "action": "name", "params": {...} }
        (action, params) = parseActionMessage(msgJson)

        # Call user's action handler - just mutates reactive records
        onAction(action, params)

        # Get record IDs that were modified during action handler
        changedIds = Reactive.getChangedRecordIds()

        # Find affected components using deps map
        affected = affectedComponentsMulti(renderResult.deps, changedIds)

        # Filter to outermost (don't re-render children if parent re-renders)
        componentsToUpdate = filterOutermost(affected, renderResult.components)

        # If there are changes but no components to update, do a full page re-render
        # This handles the case where the app doesn't use component() wrappers
        newRenderResult = if !listIsEmpty(changedIds) && listIsEmpty(componentsToUpdate) then {
            sendFullPageUpdate(ws, renderPage)
        } else {
            # Re-render affected components and send updates
            sendComponentUpdates(ws, componentsToUpdate, renderResult.renderers)
            # Update render state with new deps from re-rendered components
            updateState(renderResult, changedIds)
        }

        (true, newRenderResult)
    } catch { (kind, msg) -> {
        # WebSocket connection errors include:
        # - kind == "websocket" or "websocket_error" for connection-related errors
        # - kind == "io_error" with "closed" or "not found" messages
        containsClosed = String.contains(msg, "closed")
        containsNotFound = String.contains(msg, "not found")
        isWsError = kind == "websocket" || kind == "websocket_error"
        isIoConnectionError = kind == "io_error" && (containsClosed || containsNotFound)
        isConnectionError = isWsError || isIoConnectionError

        if isConnectionError then (false, renderResult)
        else {
            println("RWeb action error: " ++ msg)
            (true, renderResult)
        }
    } }

    match result {
        (true, newState) -> sessionLoop(ws, newState, renderPage, onAction)
        (false, _) -> WebSocket.close(ws)
    }
}

# Convert Json value to string
jsonValueToString(json) = match json {
    String(s) -> s
    Number(n) -> show(n)
    Bool(true) -> "true"
    Bool(false) -> "false"
    Null -> ""
    _ -> ""
}

# Convert Json Object pairs to Map[String, String]
jsonPairsToMap(pairs, acc) = match pairs {
    [] -> acc
    [(key, value) | rest] -> jsonPairsToMap(rest, Map.insert(acc, key, jsonValueToString(value)))
}

# Find a field in Json Object
jsonGetField(json, key) = match json {
    Object(pairs) -> jsonFindField(pairs, key)
    _ -> Null
}

jsonFindField(pairs, key) = match pairs {
    [] -> Null
    [(k, v) | rest] -> if k == key then v else jsonFindField(rest, key)
}

# Parse JSON action message: { "action": "name", "params": {...} }
parseActionMessage(jsonStr) = {
    json = jsonParse(jsonStr)

    # Extract action name
    actionJson = jsonGetField(json, "action")
    action = jsonValueToString(actionJson)

    # Extract params object and convert to Map[String, String]
    paramsJson = jsonGetField(json, "params")
    params = match paramsJson {
        Object(pairs) -> jsonPairsToMap(pairs, %{})
        _ -> %{}
    }

    (action, params)
}

# Extract string value from JSON by key (simple implementation)
extractJsonString(json, key) = {
    searchFor = "\"" ++ key ++ "\""
    startIdx = findSubstring(json, searchFor, 0)
    if startIdx < 0 then ""
    else {
        # Find the colon after key
        colonIdx = findSubstring(json, ":", startIdx)
        # Find the opening quote of value
        quoteStart = findSubstring(json, "\"", colonIdx + 1)
        # Find closing quote
        quoteEnd = findSubstring(json, "\"", quoteStart + 1)
        if quoteEnd > quoteStart then
            String.substring(json, quoteStart + 1, quoteEnd)
        else ""
    }
}

# Find substring starting from index
findSubstring(str, needle, startFrom) = {
    chars = String.chars(str)
    needleChars = String.chars(needle)
    findSubstringHelper(chars, needleChars, startFrom, 0)
}

findSubstringHelper(chars, needle, startFrom, idx) = match chars {
    [] -> -1
    [c | rest] ->
        if idx < startFrom then findSubstringHelper(rest, needle, startFrom, idx + 1)
        else if matchesAt(chars, needle) then idx
        else findSubstringHelper(rest, needle, startFrom, idx + 1)
}

matchesAt(chars, needle) = match needle {
    [] -> true
    [n | nrest] -> match chars {
        [] -> false
        [c | crest] -> if c == n then matchesAt(crest, nrest) else false
    }
}

# Send component updates via WebSocket
sendComponentUpdates(ws, componentNames, renderers) = match componentNames {
    [] -> ()
    [name | rest] -> {
        if Map.contains(renderers, name) then {
            renderFn = Map.get(renderers, name)
            result = renderFn()
            innerHtml = renderRHtml(result)
            # Wrap with component div to preserve the id for future updates
            # This matches the structure created by renderComponent in rhtml.nos
            html = "<div id=\"" ++ name ++ "\" data-component=\"true\">" ++ innerHtml ++ "</div>"
            msg = "{\"type\":\"update\",\"component\":\"" ++ escapeJsonString(name) ++ "\",\"html\":\"" ++ escapeJsonString(html) ++ "\"}"
            WebSocket.send(ws, msg)
        } else ()
        sendComponentUpdates(ws, rest, renderers)
    }
}

# Escape string for JSON
escapeJsonString(s) = escapeJsonChars(String.chars(s))

escapeJsonChars(chars) = match chars {
    [] -> ""
    [c | rest] -> escapeJsonChar(c) ++ escapeJsonChars(rest)
}

escapeJsonChar(c) = match c {
    '"' -> "\\\""
    '\\' -> "\\\\"
    '\n' -> "\\n"
    '\r' -> "\\r"
    '\t' -> "\\t"
    _ -> String.from_chars([c])
}

# --- Request Handler ---

# Handle HTTP requests
rwebHandleRequest(req, title, sessionSetup) = {
    # NOTE: For WebSocket, we MUST call WebSocket.accept BEFORE any println!
    # Otherwise the spawned process blocks stdout before handshake completes
    if req.path == "/" then {
        # Serve initial HTML page - create fresh session for rendering
        (renderPage, _) = sessionSetup()
        result = renderPage()
        html = renderRHtml(result)
        respondHtml(req, pageTemplate(title, html))
    }
    else if req.path == "/ws" && req.isWebSocket then {
        # WebSocket upgrade - accept FIRST before any IO
        ws = WebSocket.accept(req.id)

        # Log session start (after WebSocket.accept to avoid blocking)
        pid = self()
        println("[RWeb] Session started: pid=" ++ show(pid))

        # Create fresh session state for this connection
        (renderPage, onAction) = sessionSetup()
        renderResult = renderPage()

        # Send initial full page HTML
        html = renderRHtml(renderResult)
        msg = "{\"type\":\"full\",\"html\":\"" ++ escapeJsonString(html) ++ "\"}"
        WebSocket.send(ws, msg)

        # Enter session loop (this process becomes the session)
        sessionLoop(ws, renderResult, renderPage, onAction)

        # Session has ended (sessionLoop returned)
        # Run GC and report stats before process exits
        gcResult = Gc.collect()
        stats = Gc.stats()
        println("[RWeb] Session ended: pid=" ++ show(pid) ++
                " | gc collected=" ++ show(gcResult.collected) ++
                " live=" ++ show(stats.live) ++
                " totalAllocated=" ++ show(stats.totalAllocated) ++
                " totalFreed=" ++ show(stats.totalFreed))
    }
    else respond404(req)
}

# --- Main Entry Point ---

# Start the reactive web server
# sessionSetup: () -> (renderPage, onAction) - creates fresh state per session
#   Returns a tuple of:
#   - renderPage: () -> RHtmlResult - renders the page
#   - onAction: (action, params) -> () - handles actions by mutating reactive records
pub startRWeb(port, title, sessionSetup) = {
    println("RWeb server started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws")
    # In interactive mode (REPL/TUI), spawn server in background
    # In script mode, run server in foreground (blocking)
    if Runtime.isInteractive() then {
        spawn { serve(port, req => rwebHandleRequest(req, title, sessionSetup)) }
        ()
    } else {
        serve(port, req => rwebHandleRequest(req, title, sessionSetup))
    }
}

# --- Multi-Route Support ---

# Client JavaScript that passes current path to WebSocket
clientJsWithRoutes() = "
<script>
(function() {
    var ws = null;
    var reconnectDelay = 1000;

    function connect() {
        var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(protocol + '//' + location.host + '/ws?path=' + encodeURIComponent(location.pathname));

        ws.onopen = function() {
            console.log('RWeb connected for path: ' + location.pathname);
            reconnectDelay = 1000;
        };

        ws.onmessage = function(e) {
            var data = JSON.parse(e.data);
            if (data.type === 'update') {
                var el = document.getElementById(data.component);
                if (el) {
                    el.outerHTML = data.html;
                    bindEvents();
                }
            } else if (data.type === 'full') {
                document.getElementById('rweb-root').innerHTML = data.html;
                bindEvents();
            }
        };

        ws.onclose = function() {
            console.log('RWeb disconnected, reconnecting...');
            setTimeout(connect, reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, 30000);
        };

        ws.onerror = function(e) {
            console.error('RWeb error', e);
        };
    }

    function sendAction(action, params) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: action, params: params || {} }));
        }
    }

    function bindEvents() {
        // Bind click handlers for data-action elements (excluding forms)
        document.querySelectorAll('[data-action]:not(form)').forEach(function(el) {
            if (!el._rweb_bound) {
                el._rweb_bound = true;
                el.addEventListener('click', function(e) {
                    e.preventDefault();
                    var action = el.getAttribute('data-action');
                    var params = {};
                    for (var i = 0; i < el.attributes.length; i++) {
                        var attr = el.attributes[i];
                        if (attr.name.startsWith('data-param-')) {
                            params[attr.name.substring(11)] = attr.value;
                        }
                    }
                    sendAction(action, params);
                });
            }
        });

        // Bind form submissions
        document.querySelectorAll('form[data-action]').forEach(function(form) {
            if (!form._rweb_bound) {
                form._rweb_bound = true;
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    var action = form.getAttribute('data-action');
                    var params = {};
                    new FormData(form).forEach(function(v, k) { params[k] = v; });
                    sendAction(action, params);
                });
            }
        });

        document.querySelectorAll('[data-onchange]').forEach(function(el) {
            if (!el._rweb_change_bound) {
                el._rweb_change_bound = true;
                el.addEventListener('change', function(e) {
                    var action = el.getAttribute('data-onchange');
                    var params = { value: el.value };
                    if (el.type === 'checkbox' || el.type === 'radio') {
                        params.checked = el.checked ? 'true' : 'false';
                    }
                    sendAction(action, params);
                });
            }
        });

        document.querySelectorAll('[data-oninput]').forEach(function(el) {
            if (!el._rweb_input_bound) {
                el._rweb_input_bound = true;
                el.addEventListener('input', function(e) {
                    var action = el.getAttribute('data-oninput');
                    sendAction(action, { value: el.value });
                });
            }
        });
    }

    window.rweb = { sendAction: sendAction };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            bindEvents();
            connect();
        });
    } else {
        bindEvents();
        connect();
    }
})();
</script>
"

# Page template for routed pages
pageTemplateWithRoutes(title, content) =
    "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<title>" ++ title ++ "</title>\n</head>\n<body>\n<div id=\"rweb-root\">" ++ content ++ "</div>\n" ++ clientJsWithRoutes() ++ "\n</body>\n</html>"

# Request handler with routing support using resolver functions
# reactiveResolver: String -> Option[() -> (RenderFn, ActionHandler)] - resolves reactive pages
# plainResolver: String -> Option[Request -> ()] - resolves plain HTML handlers
rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver) = {
    # WebSocket upgrade - check path query param for which session to create
    if req.path == "/ws" && req.isWebSocket then {
        pagePath = getParam(req.queryParams, "path")
        actualPath = if pagePath == "" then "/" else pagePath

        match reactiveResolver(actualPath) {
            Some(sessionSetup) -> {
                # Accept WebSocket FIRST before any IO
                ws = WebSocket.accept(req.id)

                pid = self()
                println("[RWeb] Session started: pid=" ++ show(pid) ++ " path=" ++ actualPath)

                (renderPage, onAction) = sessionSetup()
                renderResult = renderPage()

                # Send initial full page HTML
                html = renderRHtml(renderResult)
                msg = "{\"type\":\"full\",\"html\":\"" ++ escapeJsonString(html) ++ "\"}"
                WebSocket.send(ws, msg)

                # Enter session loop (persistent process)
                sessionLoop(ws, renderResult, renderPage, onAction)

                # Session ended
                gcResult = Gc.collect()
                stats = Gc.stats()
                println("[RWeb] Session ended: pid=" ++ show(pid) ++
                        " | gc collected=" ++ show(gcResult.collected) ++
                        " live=" ++ show(stats.live) ++
                        " totalAllocated=" ++ show(stats.totalAllocated) ++
                        " totalFreed=" ++ show(stats.totalFreed))
            }
            None() -> respond404(req)
        }
    }
    # Check reactive routes - serve initial HTML
    else match reactiveResolver(req.path) {
        Some(sessionSetup) -> {
            (renderPage, _) = sessionSetup()
            result = renderPage()
            html = renderRHtml(result)
            respondHtml(req, pageTemplateWithRoutes(title, html))
        }
        None() -> {
            # Check plain routes - call handler directly
            match plainResolver(req.path) {
                Some(handler) -> handler(req)
                None() -> respond404(req)
            }
        }
    }
}

# Start RWeb server with multiple routes using resolver functions
#
# reactiveResolver: String -> Option[() -> (RenderFn, ActionHandler)]
#   A function that takes a path and returns Some(sessionSetup) or None()
#   sessionSetup: () -> (renderPage, onAction)
#
# plainResolver: String -> Option[Request -> ()]
#   A function that takes a path and returns Some(handler) or None()
#   handler: Request -> ()
#
# Example:
#   homeSession() = {
#       counter = Counter(value: 0)
#       (
#           () => RHtml(div([h1("Home"), span(show(counter.value))])),
#           (action, params) => ()
#       )
#   }
#
#   purchaseSession() = { ... }
#
#   aboutHandler(req) = respondHtml(req, "<h1>About Us</h1>")
#
#   reactiveResolver(path) = match path {
#       "/" -> Some(homeSession)
#       "/purchase" -> Some(purchaseSession)
#       _ -> None()
#   }
#
#   plainResolver(path) = match path {
#       "/about" -> Some(aboutHandler)
#       _ -> None()
#   }
#
#   main() = startRWebWithRoutes(8080, "My App", reactiveResolver, plainResolver)
#
pub startRWebWithRoutes(port, title, reactiveResolver, plainResolver) = {
    println("RWeb server with routes started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws?path=<path>")
    # In interactive mode (REPL/TUI), spawn server in background
    # In script mode, run server in foreground (blocking)
    if Runtime.isInteractive() then {
        spawn { serve(port, req => rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver)) }
        ()
    } else {
        serve(port, req => rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver))
    }
}

# --- REPL-friendly Background Server ---

# Start server in background, automatically killing any previous server
# Returns the process ID
#
# Usage in REPL:
#   restartRWebBackground(8080, "My App", session)
#   # ... test in browser, modify code ...
#   restartRWebBackground(8080, "My App", session)  # auto-kills previous
#
pub restartRWebBackground(port, title, sessionSetup) = {
    # Kill previous server if exists
    match rwebLastServer {
        Some(oldPid) -> {
            if Process.alive(oldPid) then {
                Process.kill(oldPid)
                println("[RWeb] Killed previous server")
            } else ()
        }
        None() -> ()
    }

    # Start new server (using separate function to avoid cur_frame staleness with mvar+spawn)
    pid = startRWebBackground(port, title, sessionSetup)
    rwebLastServer = Some(pid)
    pid
}

# Same for routes-based servers
pub restartRWebWithRoutesBackground(port, title, reactiveResolver, plainResolver) = {
    match rwebLastServer {
        Some(oldPid) -> {
            if Process.alive(oldPid) then {
                Process.kill(oldPid)
                println("[RWeb] Killed previous server")
            } else ()
        }
        None() -> ()
    }

    # Using separate function to avoid cur_frame staleness with mvar+spawn
    pid = startRWebWithRoutesBackground(port, title, reactiveResolver, plainResolver)
    rwebLastServer = Some(pid)
    pid
}

# Simple version without auto-kill (user manages pid)
# Note: spawns serve directly to get correct server pid (not double-spawn)
pub startRWebBackground(port, title, sessionSetup) = {
    println("RWeb server started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws")
    spawn { serve(port, req => rwebHandleRequest(req, title, sessionSetup)) }
}

pub startRWebWithRoutesBackground(port, title, reactiveResolver, plainResolver) = {
    println("RWeb server with routes started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws?path=<path>")
    spawn { serve(port, req => rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver)) }
}

# Smart RWeb starters - auto-detect interactive mode
# In TUI/REPL: runs in background with auto-restart
# In script: runs in foreground (blocking)

pub runRWeb(port, title, sessionSetup) =
    if Env.isInteractive() then
        restartRWebBackground(port, title, sessionSetup)
    else
        startRWeb(port, title, sessionSetup)

pub runRWebWithRoutes(port, title, reactiveResolver, plainResolver) =
    if Env.isInteractive() then
        restartRWebWithRoutesBackground(port, title, reactiveResolver, plainResolver)
    else
        startRWebWithRoutes(port, title, reactiveResolver, plainResolver)
