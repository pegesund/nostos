# RWeb - Reactive Web Framework
#
# WebSocket-based reactive UI with process-per-session.
# Each client connection spawns a dedicated session process
# that holds reactive state and pushes updates.
#
# Key concept: Action handlers just MUTATE reactive records.
# The VM automatically tracks which records changed, finds affected
# components via the deps map, and re-renders them.
#
# Usage:
#   use stdlib.rweb
#   use stdlib.rhtml
#
#   reactive Counter = { value: Int }
#
#   session() = {
#       counter = Counter(0)
#       (
#           () => RHtml(div([
#               component("display", () => RHtml(
#                   span("Count: " ++ show(counter.value))
#               )),
#               button("+1", dataAction: "increment")
#           ])),
#           (action, params) => match action {
#               "increment" -> { counter.value = counter.value + 1 }
#               _ -> ()
#           }
#       )
#   }
#
#   main() = startRWeb(8080, "My App", session)

use stdlib.server.{serve, respondHtml, respond404, getParam, serveStatic}
use stdlib.rhtml
# Import Json variant constructors for pattern matching (Json.parse returns these)
use stdlib.json.{Null, Bool, Number, Object, String}
use stdlib.rweb_state.rwebLastServer

# --- Client JavaScript ---

pub clientJs() = "
<script>
(function() {
    var ws = null;
    var reconnectDelay = 1000;

    function connect() {
        var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(protocol + '//' + location.host + '/ws');

        ws.onopen = function() {
            console.log('RWeb connected');
            reconnectDelay = 1000;
        };

        ws.onmessage = function(e) {
            var data = JSON.parse(e.data);
            if (data.type === 'update') {
                // Update component HTML
                var el = document.getElementById(data.component);
                if (el) {
                    el.outerHTML = data.html;
                    bindEvents();
                }
            } else if (data.type === 'full') {
                // Full page update
                document.getElementById('rweb-root').innerHTML = data.html;
                bindEvents();
            } else if (data.type === 'trigger') {
                // Server wants to inject an action - send back to trigger processing
                sendAction('_external', {});
            } else if (data.type === 'setCookie') {
                // Server wants to set a cookie
                var cookie = data.name + '=' + encodeURIComponent(data.value);
                if (data.maxAge) cookie += '; Max-Age=' + data.maxAge;
                if (data.path) cookie += '; Path=' + data.path;
                if (data.secure) cookie += '; Secure';
                if (data.sameSite) cookie += '; SameSite=' + data.sameSite;
                document.cookie = cookie;
            } else if (data.type === 'clearCookie') {
                // Server wants to clear a cookie
                document.cookie = data.name + '=; Path=' + (data.path || '/') + '; Max-Age=0';
            }
        };

        ws.onclose = function() {
            console.log('RWeb disconnected, reconnecting...');
            setTimeout(connect, reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, 30000);
        };

        ws.onerror = function(e) {
            console.error('RWeb error', e);
        };
    }

    function sendAction(action, params) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: action, params: params || {} }));
        }
    }

    function bindEvents() {
        // Bind click handlers for data-action elements (excluding forms)
        document.querySelectorAll('[data-action]:not(form)').forEach(function(el) {
            if (!el._rweb_bound) {
                el._rweb_bound = true;
                el.addEventListener('click', function(e) {
                    e.preventDefault();
                    var action = el.getAttribute('data-action');
                    var params = {};
                    // Collect data-param-* attributes
                    for (var i = 0; i < el.attributes.length; i++) {
                        var attr = el.attributes[i];
                        if (attr.name.startsWith('data-param-')) {
                            params[attr.name.substring(11)] = attr.value;
                        }
                    }
                    sendAction(action, params);
                });
            }
        });

        // Bind form submissions
        document.querySelectorAll('form[data-action]').forEach(function(form) {
            if (!form._rweb_bound) {
                form._rweb_bound = true;
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    var action = form.getAttribute('data-action');
                    var params = {};
                    new FormData(form).forEach(function(v, k) { params[k] = v; });
                    sendAction(action, params);
                });
            }
        });

        // Bind change handlers for data-onchange elements
        document.querySelectorAll('[data-onchange]').forEach(function(el) {
            if (!el._rweb_change_bound) {
                el._rweb_change_bound = true;
                el.addEventListener('change', function(e) {
                    var action = el.getAttribute('data-onchange');
                    var params = { value: el.value };
                    // For checkbox/radio, also send checked state
                    if (el.type === 'checkbox' || el.type === 'radio') {
                        params.checked = el.checked ? 'true' : 'false';
                    }
                    sendAction(action, params);
                });
            }
        });

        // Bind input handlers for data-oninput elements (real-time)
        document.querySelectorAll('[data-oninput]').forEach(function(el) {
            if (!el._rweb_input_bound) {
                el._rweb_input_bound = true;
                el.addEventListener('input', function(e) {
                    var action = el.getAttribute('data-oninput');
                    sendAction(action, { value: el.value });
                });
            }
        });
    }

    // Expose sendAction globally for custom use
    window.rweb = { sendAction: sendAction };

    // Connect on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            bindEvents();
            connect();
        });
    } else {
        bindEvents();
        connect();
    }
})();
</script>
"

# --- HTML Page Template ---

pub pageTemplate(title, content) =
    "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<title>" ++ title ++ "</title>\n</head>\n<body>\n<div id=\"rweb-root\">" ++ content ++ "</div>\n" ++ clientJs() ++ "\n</body>\n</html>"

# --- Session Process ---

# Helper to check if list is empty
pub listIsEmpty(xs) = match xs {
    [] -> true
    _ -> false
}

# Send full page update via WebSocket (using shared writer)
pub sendFullPageUpdate(writerId, renderPage) = {
    newResult = renderPage()
    html = renderRHtml(newResult)
    msg = "{\"type\":\"full\",\"html\":\"" ++ Json.escapeString(html) ++ "\"}"
    WebSocket.sendShared(writerId, msg)
    newResult
}

# Session process main loop
# requestId: WebSocket request ID for receiving messages
# writerId: shared writer ID for sending (can be shared with external processes)
# renderResult: current render state with deps, components, renderers
# renderPage: () -> RHtmlResult - renders the page (captures state via closure)
# onAction: (action, params) -> () - handles actions by mutating reactive records
pub sessionLoop(requestId, writerId, renderResult: RHtmlResult, renderPage, onAction) = {
    result = try {
        msgJson = WebSocket.recv(requestId)

        # Parse action from JSON: { "action": "name", "params": {...} }
        (action, params) = parseActionMessage(msgJson)

        # Call user's action handler - just mutates reactive records
        # "_external" is passed through so user can handle trigger from background pusher
        onAction(action, params)

        # Get record IDs that were modified during action handler
        changedIds = Reactive.getChangedRecordIds()

        # Find affected components using deps map
        affected = affectedComponentsMulti(renderResult.deps, changedIds)

        # Filter to outermost (don't re-render children if parent re-renders)
        componentsToUpdate = filterOutermost(affected, renderResult.components)

        # If there are changes but no components to update, do a full page re-render
        # This handles the case where the app doesn't use component() wrappers
        newRenderResult = if !listIsEmpty(changedIds) && listIsEmpty(componentsToUpdate) then {
            sendFullPageUpdate(writerId, renderPage)
        } else {
            # Re-render affected components and send updates
            sendComponentUpdates(writerId, componentsToUpdate, renderResult.renderers)
            # Update render state with new deps from re-rendered components
            updateState(renderResult, changedIds)
        }

        (true, newRenderResult)
    } catch { (kind, msg) -> {
        # WebSocket connection errors include:
        # - kind == "websocket" or "websocket_error" for connection-related errors
        # - kind == "io_error" with "closed" or "not found" messages
        containsClosed = String.contains(msg, "closed")
        containsNotFound = String.contains(msg, "not found")
        isWsError = kind == "websocket" || kind == "websocket_error"
        isIoConnectionError = kind == "io_error" && (containsClosed || containsNotFound)
        isConnectionError = isWsError || isIoConnectionError

        if isConnectionError then (false, renderResult)
        else {
            println("RWeb action error: " ++ msg)
            (true, renderResult)
        }
    } }

    match result {
        (true, newState) -> sessionLoop(requestId, writerId, newState, renderPage, onAction)
        (false, _) -> WebSocket.close(requestId)
    }
}

# Convert Json value to string
pub jsonValueToString(json) = match json {
    String(s) -> s
    Number(n) -> show(n)
    Bool(true) -> "true"
    Bool(false) -> "false"
    Null -> ""
    _ -> ""
}

# Convert Json Object pairs to Map[String, String]
pub jsonPairsToMap(pairs, acc) = match pairs {
    [] -> acc
    [(key, value) | rest] -> jsonPairsToMap(rest, Map.insert(acc, key, jsonValueToString(value)))
}

# Find a field in Json Object
pub jsonGetField(json, key) = match json {
    Object(pairs) -> jsonFindField(pairs, key)
    _ -> Null
}

pub jsonFindField(pairs, key) = match pairs {
    [] -> Null
    [(k, v) | rest] -> if k == key then v else jsonFindField(rest, key)
}

# Parse JSON action message: { "action": "name", "params": {...} }
pub parseActionMessage(jsonStr) = {
    json = Json.parse(jsonStr)

    # Extract action name
    actionJson = jsonGetField(json, "action")
    action = jsonValueToString(actionJson)

    # Extract params object and convert to Map[String, String]
    paramsJson = jsonGetField(json, "params")
    params = match paramsJson {
        Object(pairs) -> jsonPairsToMap(pairs, %{})
        _ -> %{}
    }

    (action, params)
}

# Extract string value from JSON by key (simple implementation)
pub extractJsonString(json, key) = {
    searchFor = "\"" ++ key ++ "\""
    startIdx = findSubstring(json, searchFor, 0)
    if startIdx < 0 then ""
    else {
        # Find the colon after key
        colonIdx = findSubstring(json, ":", startIdx)
        # Find the opening quote of value
        quoteStart = findSubstring(json, "\"", colonIdx + 1)
        # Find closing quote
        quoteEnd = findSubstring(json, "\"", quoteStart + 1)
        if quoteEnd > quoteStart then
            String.substring(json, quoteStart + 1, quoteEnd)
        else ""
    }
}

# Find substring starting from index
pub findSubstring(str, needle, startFrom) = {
    chars = String.chars(str)
    needleChars = String.chars(needle)
    findSubstringHelper(chars, needleChars, startFrom, 0)
}

pub findSubstringHelper(chars, needle, startFrom, idx) = match chars {
    [] -> -1
    [c | rest] ->
        if idx < startFrom then findSubstringHelper(rest, needle, startFrom, idx + 1)
        else if matchesAt(chars, needle) then idx
        else findSubstringHelper(rest, needle, startFrom, idx + 1)
}

pub matchesAt(chars, needle) = match needle {
    [] -> true
    [n | nrest] -> match chars {
        [] -> false
        [c | crest] -> if c == n then matchesAt(crest, nrest) else false
    }
}

# Send component updates via WebSocket (using shared writer)
pub sendComponentUpdates(writerId, componentNames, renderers) = match componentNames {
    [] -> ()
    [name | rest] -> {
        if Map.contains(renderers, name) then {
            renderFn = Map.get(renderers, name)
            result = renderFn()
            innerHtml = renderRHtml(result)
            # Wrap with component div to preserve the id for future updates
            # This matches the structure created by renderComponent in rhtml.nos
            html = "<div id=\"" ++ name ++ "\" data-component=\"true\">" ++ innerHtml ++ "</div>"
            msg = "{\"type\":\"update\",\"component\":\"" ++ Json.escapeString(name) ++ "\",\"html\":\"" ++ Json.escapeString(html) ++ "\"}"
            WebSocket.sendShared(writerId, msg)
        } else ()
        sendComponentUpdates(writerId, rest, renderers)
    }
}

# Old pure-Nostos JSON escaping - kept for reference
# Now using native Json.escapeString for performance
# escapeJsonString(s) = escapeJsonChars(String.chars(s))
# escapeJsonChars(chars) = match chars {
#     [] -> ""
#     [c | rest] -> escapeJsonChar(c) ++ escapeJsonChars(rest)
# }
# escapeJsonChar(c) = match c {
#     '"' -> "\\\""
#     '\\' -> "\\\\"
#     '\n' -> "\\n"
#     '\r' -> "\\r"
#     '\t' -> "\\t"
#     _ -> String.from_chars([c])
# }

# --- Request Handler ---

# Handle HTTP requests
# sessionSetup now receives: (writerId, cookies) where cookies is List[(String, String)]
pub rwebHandleRequest(req, title, sessionSetup) = {
    # NOTE: For WebSocket, we MUST call WebSocket.accept BEFORE any println!
    # Otherwise the spawned process blocks stdout before handshake completes
    if req.path == "/" then {
        # Serve initial HTML page - create fresh session for rendering
        # Pass 0 as writerId placeholder, cookies from request
        (renderPage, _) = sessionSetup(0, req.cookies)
        result = renderPage()
        html = renderRHtml(result)
        respondHtml(req, pageTemplate(title, html))
    }
    else if req.path == "/ws" && req.isWebSocket then {
        # WebSocket upgrade - accept FIRST before any IO
        ws = WebSocket.accept(req.id)

        # Split the WebSocket into separate read/write handles
        # writerId can be shared with external processes for push messages
        splitResult = WebSocket.split(ws)
        requestId = splitResult.requestId
        writerId = splitResult.writerId

        # Log session start with writerId (external processes can use this to push)
        pid = self()
        println("[RWeb] Session started: pid=" ++ show(pid) ++ " writerId=" ++ show(writerId))

        # Call session start callback (for external push tracking)
        match onSessionStartCallback {
            Some(callback) -> callback(writerId)
            None() -> ()
        }

        # Create fresh session state for this connection
        # Pass writerId and cookies from WebSocket upgrade request
        (renderPage, onAction) = sessionSetup(writerId, req.cookies)
        renderResult = renderPage()

        # Send initial full page HTML (using shared writer)
        html = renderRHtml(renderResult)
        msg = "{\"type\":\"full\",\"html\":\"" ++ Json.escapeString(html) ++ "\"}"
        WebSocket.sendShared(writerId, msg)

        # Enter session loop (this process becomes the session)
        sessionLoop(requestId, writerId, renderResult, renderPage, onAction)

        # Session has ended (sessionLoop returned)
        # Call session end callback (for external push cleanup)
        match onSessionEndCallback {
            Some(callback) -> callback(writerId)
            None() -> ()
        }

        # Run GC and report stats before process exits
        gcResult = Gc.collect()
        stats = Gc.stats()
        println("[RWeb] Session ended: pid=" ++ show(pid) ++
                " | gc collected=" ++ show(gcResult.collected) ++
                " live=" ++ show(stats.live) ++
                " totalAllocated=" ++ show(stats.totalAllocated) ++
                " totalFreed=" ++ show(stats.totalFreed))
    }
    else respond404(req)
}

# --- Main Entry Point ---

# Start the reactive web server
# sessionSetup: (writerId: Int) -> (renderPage, onAction) - creates fresh state per session
#   writerId is the WebSocket writer ID for this session (use for targeted push messages)
#   Returns a tuple of:
#   - renderPage: () -> RHtmlResult - renders the page
#   - onAction: (action, params) -> () - handles actions by mutating reactive records
pub startRWeb(port, title, sessionSetup) -> () = {
    println("RWeb server started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws")
    # In interactive mode (REPL/TUI), spawn server in background
    # In script mode, run server in foreground (blocking)
    if Runtime.isInteractive() then {
        spawn { serve(port, req => rwebHandleRequest(req, title, sessionSetup)) }
        ()
    } else {
        serve(port, req => rwebHandleRequest(req, title, sessionSetup))
    }
}

# --- Multi-Route Support ---

# Client JavaScript that passes current path to WebSocket
pub clientJsWithRoutes() = "
<script>
(function() {
    var ws = null;
    var reconnectDelay = 1000;

    function connect() {
        var protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(protocol + '//' + location.host + '/ws?path=' + encodeURIComponent(location.pathname));

        ws.onopen = function() {
            console.log('RWeb connected for path: ' + location.pathname);
            reconnectDelay = 1000;
        };

        ws.onmessage = function(e) {
            var data = JSON.parse(e.data);
            if (data.type === 'update') {
                var el = document.getElementById(data.component);
                if (el) {
                    el.outerHTML = data.html;
                    bindEvents();
                }
            } else if (data.type === 'full') {
                document.getElementById('rweb-root').innerHTML = data.html;
                bindEvents();
            } else if (data.type === 'setCookie') {
                var cookie = data.name + '=' + encodeURIComponent(data.value);
                if (data.maxAge) cookie += '; Max-Age=' + data.maxAge;
                if (data.path) cookie += '; Path=' + data.path;
                if (data.secure) cookie += '; Secure';
                if (data.sameSite) cookie += '; SameSite=' + data.sameSite;
                document.cookie = cookie;
            } else if (data.type === 'clearCookie') {
                document.cookie = data.name + '=; Path=' + (data.path || '/') + '; Max-Age=0';
            }
        };

        ws.onclose = function() {
            console.log('RWeb disconnected, reconnecting...');
            setTimeout(connect, reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, 30000);
        };

        ws.onerror = function(e) {
            console.error('RWeb error', e);
        };
    }

    function sendAction(action, params) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ action: action, params: params || {} }));
        }
    }

    function bindEvents() {
        // Bind click handlers for data-action elements (excluding forms)
        document.querySelectorAll('[data-action]:not(form)').forEach(function(el) {
            if (!el._rweb_bound) {
                el._rweb_bound = true;
                el.addEventListener('click', function(e) {
                    e.preventDefault();
                    var action = el.getAttribute('data-action');
                    var params = {};
                    for (var i = 0; i < el.attributes.length; i++) {
                        var attr = el.attributes[i];
                        if (attr.name.startsWith('data-param-')) {
                            params[attr.name.substring(11)] = attr.value;
                        }
                    }
                    sendAction(action, params);
                });
            }
        });

        // Bind form submissions
        document.querySelectorAll('form[data-action]').forEach(function(form) {
            if (!form._rweb_bound) {
                form._rweb_bound = true;
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    var action = form.getAttribute('data-action');
                    var params = {};
                    new FormData(form).forEach(function(v, k) { params[k] = v; });
                    sendAction(action, params);
                });
            }
        });

        document.querySelectorAll('[data-onchange]').forEach(function(el) {
            if (!el._rweb_change_bound) {
                el._rweb_change_bound = true;
                el.addEventListener('change', function(e) {
                    var action = el.getAttribute('data-onchange');
                    var params = { value: el.value };
                    if (el.type === 'checkbox' || el.type === 'radio') {
                        params.checked = el.checked ? 'true' : 'false';
                    }
                    sendAction(action, params);
                });
            }
        });

        document.querySelectorAll('[data-oninput]').forEach(function(el) {
            if (!el._rweb_input_bound) {
                el._rweb_input_bound = true;
                el.addEventListener('input', function(e) {
                    var action = el.getAttribute('data-oninput');
                    sendAction(action, { value: el.value });
                });
            }
        });
    }

    window.rweb = { sendAction: sendAction };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            bindEvents();
            connect();
        });
    } else {
        bindEvents();
        connect();
    }
})();
</script>
"

# Page template for routed pages
pub pageTemplateWithRoutes(title, content) =
    "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<title>" ++ title ++ "</title>\n</head>\n<body>\n<div id=\"rweb-root\">" ++ content ++ "</div>\n" ++ clientJsWithRoutes() ++ "\n</body>\n</html>"

# Request handler with routing support using resolver functions
# reactiveResolver: String -> Option[(writerId, cookies) -> (RenderFn, ActionHandler)]
# plainResolver: String -> Option[Request -> ()] - resolves plain HTML handlers
pub rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver) = {
    # WebSocket upgrade - check path query param for which session to create
    if req.path == "/ws" && req.isWebSocket then {
        pagePath = getParam(req.queryParams, "path")
        actualPath = if pagePath == "" then "/" else pagePath

        match reactiveResolver(actualPath) {
            Some(sessionSetup) -> {
                # Accept WebSocket FIRST before any IO
                ws = WebSocket.accept(req.id)

                # Split the WebSocket into separate read/write handles
                # writerId can be shared with external processes for push messages
                splitResult = WebSocket.split(ws)
                requestId = splitResult.requestId
                writerId = splitResult.writerId

                pid = self()
                println("[RWeb] Session started: pid=" ++ show(pid) ++ " path=" ++ actualPath ++ " writerId=" ++ show(writerId))

                # Pass cookies from WebSocket upgrade request
                (renderPage, onAction) = sessionSetup(writerId, req.cookies)
                renderResult = renderPage()

                # Send initial full page HTML (using shared writer)
                html = renderRHtml(renderResult)
                msg = "{\"type\":\"full\",\"html\":\"" ++ Json.escapeString(html) ++ "\"}"
                WebSocket.sendShared(writerId, msg)

                # Enter session loop (persistent process)
                sessionLoop(requestId, writerId, renderResult, renderPage, onAction)

                # Session ended
                gcResult = Gc.collect()
                stats = Gc.stats()
                println("[RWeb] Session ended: pid=" ++ show(pid) ++
                        " | gc collected=" ++ show(gcResult.collected) ++
                        " live=" ++ show(stats.live) ++
                        " totalAllocated=" ++ show(stats.totalAllocated) ++
                        " totalFreed=" ++ show(stats.totalFreed))
            }
            None() -> respond404(req)
        }
    }
    # Check reactive routes - serve initial HTML
    else match reactiveResolver(req.path) {
        Some(sessionSetup) -> {
            # Pass 0 as writerId placeholder, cookies from request
            (renderPage, _) = sessionSetup(0, req.cookies)
            result = renderPage()
            html = renderRHtml(result)
            respondHtml(req, pageTemplateWithRoutes(title, html))
        }
        None() -> {
            # Check plain routes - call handler directly
            match plainResolver(req.path) {
                Some(handler) -> handler(req)
                None() -> respond404(req)
            }
        }
    }
}

# Start RWeb server with multiple routes using resolver functions
#
# reactiveResolver: String -> Option[() -> (RenderFn, ActionHandler)]
#   A function that takes a path and returns Some(sessionSetup) or None()
#   sessionSetup: (writerId: Int) -> (renderPage, onAction)
#
# plainResolver: String -> Option[Request -> ()]
#   A function that takes a path and returns Some(handler) or None()
#   handler: Request -> ()
#
# Example:
#   homeSession() = {
#       counter = Counter(value: 0)
#       (
#           () => RHtml(div([h1("Home"), span(show(counter.value))])),
#           (action, params) => ()
#       )
#   }
#
#   purchaseSession() = { ... }
#
#   aboutHandler(req) = respondHtml(req, "<h1>About Us</h1>")
#
#   reactiveResolver(path) = match path {
#       "/" -> Some(homeSession)
#       "/purchase" -> Some(purchaseSession)
#       _ -> None()
#   }
#
#   plainResolver(path) = match path {
#       "/about" -> Some(aboutHandler)
#       _ -> None()
#   }
#
#   main() = startRWebWithRoutes(8080, "My App", reactiveResolver, plainResolver)
#
pub startRWebWithRoutes(port, title, reactiveResolver, plainResolver) -> () = {
    println("RWeb server with routes started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws?path=<path>")
    # In interactive mode (REPL/TUI), spawn server in background
    # In script mode, run server in foreground (blocking)
    if Runtime.isInteractive() then {
        spawn { serve(port, req => rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver)) }
        ()
    } else {
        serve(port, req => rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver))
    }
}

# --- Static File Integration ---

# Request handler with routes AND static file support
# staticConfig: list of (urlPrefix, directory) tuples for static serving
#   e.g., [("/static", "./public"), ("/assets", "./assets")]
pub rwebHandleRequestWithStatic(req, title, reactiveResolver, plainResolver, staticConfig) = {
    # WebSocket upgrade
    if req.path == "/ws" && req.isWebSocket then {
        pagePath = getParam(req.queryParams, "path")
        actualPath = if pagePath == "" then "/" else pagePath

        match reactiveResolver(actualPath) {
            Some(sessionSetup) -> {
                ws = WebSocket.accept(req.id)
                splitResult = WebSocket.split(ws)
                requestId = splitResult.requestId
                writerId = splitResult.writerId

                pid = self()
                println("[RWeb] Session started: pid=" ++ show(pid) ++ " path=" ++ actualPath ++ " writerId=" ++ show(writerId))

                # Pass cookies from WebSocket upgrade request
                (renderPage, onAction) = sessionSetup(writerId, req.cookies)
                renderResult = renderPage()

                html = renderRHtml(renderResult)
                msg = "{\"type\":\"full\",\"html\":\"" ++ Json.escapeString(html) ++ "\"}"
                WebSocket.sendShared(writerId, msg)

                sessionLoop(requestId, writerId, renderResult, renderPage, onAction)

                gcResult = Gc.collect()
                stats = Gc.stats()
                println("[RWeb] Session ended: pid=" ++ show(pid) ++
                        " | gc collected=" ++ show(gcResult.collected) ++
                        " live=" ++ show(stats.live))
            }
            None() -> respond404(req)
        }
    }
    # Check reactive routes first
    else match reactiveResolver(req.path) {
        Some(sessionSetup) -> {
            # Pass cookies from request
            (renderPage, _) = sessionSetup(0, req.cookies)
            result = renderPage()
            html = renderRHtml(result)
            respondHtml(req, pageTemplateWithRoutes(title, html))
        }
        None() -> {
            # Check plain routes
            match plainResolver(req.path) {
                Some(handler) -> handler(req)
                None() -> {
                    # Try static files
                    if tryServeStatic(req, staticConfig) then ()
                    else respond404(req)
                }
            }
        }
    }
}

# Try to serve static file from config list
pub tryServeStatic(req, config) = match config {
    [] -> false
    [(prefix, dir) | rest] -> {
        if serveStatic(req, prefix, dir) then true
        else tryServeStatic(req, rest)
    }
}

# Start RWeb with routes AND static file serving
#
# staticConfig: list of (urlPrefix, directory) tuples
#   e.g., [("/static", "./public"), ("/css", "./styles")]
#
# Example:
#   reactiveResolver(path) = match path {
#       "/" -> Some(homeSession)
#       "/app" -> Some(appSession)
#       _ -> None()
#   }
#
#   plainResolver(path) = match path {
#       "/api/health" -> Some(req => respondJson(req, "{\"ok\":true}"))
#       _ -> None()
#   }
#
#   main() = startRWebFull(8080, "My App", reactiveResolver, plainResolver, [("/static", "./public")])
#
pub startRWebFull(port, title, reactiveResolver, plainResolver, staticConfig) -> () = {
    println("RWeb server started on http://localhost:" ++ show(port))
    println("Static paths: " ++ showStaticConfig(staticConfig))
    if Runtime.isInteractive() then {
        spawn { serve(port, req => rwebHandleRequestWithStatic(req, title, reactiveResolver, plainResolver, staticConfig)) }
        ()
    } else {
        serve(port, req => rwebHandleRequestWithStatic(req, title, reactiveResolver, plainResolver, staticConfig))
    }
}

pub showStaticConfig(config) = match config {
    [] -> "(none)"
    [(prefix, dir) | rest] -> prefix ++ " -> " ++ dir ++ showStaticConfigRest(rest)
}

pub showStaticConfigRest(config) = match config {
    [] -> ""
    [(prefix, dir) | rest] -> ", " ++ prefix ++ " -> " ++ dir ++ showStaticConfigRest(rest)
}

# --- REPL-friendly Background Server ---

# Start server in background, automatically killing any previous server
# Returns the process ID
#
# Usage in REPL:
#   restartRWebBackground(8080, "My App", session)
#   # ... test in browser, modify code ...
#   restartRWebBackground(8080, "My App", session)  # auto-kills previous
#
pub restartRWebBackground(port, title, sessionSetup) -> () = {
    # Kill previous server if exists (uses separate helper to avoid mvar lock pattern)
    killOldRwebServer()

    # Start new server (using separate function to avoid cur_frame staleness with mvar+spawn)
    pid = startRWebBackground(port, title, sessionSetup)
    setRwebLastServer(pid)
    pid
}

# Same for routes-based servers
pub restartRWebWithRoutesBackground(port, title, reactiveResolver, plainResolver) -> () = {
    # Kill previous server if exists (uses separate helper to avoid mvar lock pattern)
    killOldRwebServer()

    # Using separate function to avoid cur_frame staleness with mvar+spawn
    pid = startRWebWithRoutesBackground(port, title, reactiveResolver, plainResolver)
    setRwebLastServer(pid)
    pid
}

# Simple version without auto-kill (user manages pid)
# Note: spawns serve directly to get correct server pid (not double-spawn)
pub startRWebBackground(port, title, sessionSetup) -> () = {
    println("RWeb server started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws")
    spawn { serve(port, req => rwebHandleRequest(req, title, sessionSetup)) }
}

pub startRWebWithRoutesBackground(port, title, reactiveResolver, plainResolver) -> () = {
    println("RWeb server with routes started on http://localhost:" ++ show(port))
    println("WebSocket endpoint: ws://localhost:" ++ show(port) ++ "/ws?path=<path>")
    spawn { serve(port, req => rwebHandleRequestWithRoutes(req, title, reactiveResolver, plainResolver)) }
}

# Smart RWeb starters - auto-detect interactive mode
# In TUI/REPL: runs in background with auto-restart
# In script: runs in foreground (blocking)

pub runRWeb(port, title, sessionSetup) -> () =
    if Env.isInteractive() then
        restartRWebBackground(port, title, sessionSetup)
    else
        startRWeb(port, title, sessionSetup)

pub runRWebWithRoutes(port, title, reactiveResolver, plainResolver) -> () =
    if Env.isInteractive() then
        restartRWebWithRoutesBackground(port, title, reactiveResolver, plainResolver)
    else
        startRWebWithRoutes(port, title, reactiveResolver, plainResolver)

# --- External Push API ---
# These functions allow external processes to push messages to RWeb clients

# Optional callback for when a session starts/ends (receives writerId)
# Set these before starting the server to track writerIds
# Use: onSessionStartCallback = Some(writerId => { ... })
pub mvar onSessionStartCallback: Option[(Int -> ())] = None()
pub mvar onSessionEndCallback: Option[(Int -> ())] = None()

# Push a full page update to a WebSocket connection
# writerId: the writer ID obtained from session (logged as "writerId=..." when session starts)
# html: the HTML content to push
pub rwebPushFull(writerId, html) -> () = {
    msg = "{\"type\":\"full\",\"html\":\"" ++ Json.escapeString(html) ++ "\"}"
    WebSocket.sendShared(writerId, msg)
}

# Push a component update to a WebSocket connection
# writerId: the writer ID obtained from session
# componentId: the component div id to update
# html: the new HTML for the component
pub rwebPushComponent(writerId, componentId, html) -> () = {
    wrappedHtml = "<div id=\"" ++ componentId ++ "\" data-component=\"true\">" ++ html ++ "</div>"
    msg = "{\"type\":\"update\",\"component\":\"" ++ Json.escapeString(componentId) ++ "\",\"html\":\"" ++ Json.escapeString(wrappedHtml) ++ "\"}"
    WebSocket.sendShared(writerId, msg)
}

# Push a raw JSON message to a WebSocket connection
# writerId: the writer ID obtained from session
# jsonMsg: the raw JSON string to send
pub rwebPushRaw(writerId, jsonMsg) -> () =
    WebSocket.sendShared(writerId, jsonMsg)

# --- External Trigger API ---
# Send a trigger to a session from an external process
# This causes the client to send "_external" action, which the session's action handler receives
# The action handler can then read from shared MVars to get the update data
# writerId: the writer ID for the session
pub rwebTrigger(writerId) -> () = {
    WebSocket.sendShared(writerId, "{\"type\":\"trigger\"}")
}

# --- Cookie API (via WebSocket) ---
# Set a cookie in the browser via WebSocket message
# Note: These are NOT HttpOnly cookies (JS-accessible). For secure auth tokens,
# use plain HTTP handlers with redirectWith() instead.
#
# writerId: the WebSocket writer ID for the session
# name: cookie name
# value: cookie value
# maxAge: max age in seconds (0 = session cookie)
pub rwebSetCookie(writerId, name, value, maxAge) -> () = {
    msg = "{\"type\":\"setCookie\",\"name\":\"" ++ Json.escapeString(name) ++
          "\",\"value\":\"" ++ Json.escapeString(value) ++
          "\",\"maxAge\":" ++ show(maxAge) ++
          ",\"path\":\"/\"}"
    WebSocket.sendShared(writerId, msg)
}

# Set a secure cookie (for HTTPS)
pub rwebSetSecureCookie(writerId, name, value, maxAge) -> () = {
    msg = "{\"type\":\"setCookie\",\"name\":\"" ++ Json.escapeString(name) ++
          "\",\"value\":\"" ++ Json.escapeString(value) ++
          "\",\"maxAge\":" ++ show(maxAge) ++
          ",\"path\":\"/\",\"secure\":true,\"sameSite\":\"Strict\"}"
    WebSocket.sendShared(writerId, msg)
}

# Clear a cookie in the browser via WebSocket message
pub rwebClearCookie(writerId, name) -> () = {
    msg = "{\"type\":\"clearCookie\",\"name\":\"" ++ Json.escapeString(name) ++ "\",\"path\":\"/\"}"
    WebSocket.sendShared(writerId, msg)
}
