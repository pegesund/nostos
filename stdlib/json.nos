# JSON Parser for Nostos
#
# Parses JSON strings into a Json variant type.
# Usage: jsonParse("{\"key\": 123}")

type Json =
    | Null
    | Bool(Bool)
    | Number(Float)
    | String(String)
    | Array(List[Json])
    | Object(List[(String, Json)])


# --- Character classification helpers ---

is_whitespace(c) = c == ' ' || c == '\n' || c == '\t' || c == '\r'

# Match digit characters explicitly since char comparisons aren't supported
is_digit(c) = match c {
    '0' -> true
    '1' -> true
    '2' -> true
    '3' -> true
    '4' -> true
    '5' -> true
    '6' -> true
    '7' -> true
    '8' -> true
    '9' -> true
    _ -> false


}
# --- Whitespace handling ---

skip_ws(chars) = match chars {
    [c | rest] -> if is_whitespace(c) then skip_ws(rest) else chars
    [] -> []


}
# --- Primitive parsers ---

parse_null(chars) = match chars {
    ['n', 'u', 'l', 'l' | rest] -> (Null, rest)
    _ -> (Null, chars)

}
parse_true(chars) = match chars {
    ['t', 'r', 'u', 'e' | rest] -> (Bool(true), rest)
    _ -> (Bool(false), chars)

}
parse_false(chars) = match chars {
    ['f', 'a', 'l', 's', 'e' | rest] -> (Bool(false), rest)
    _ -> (Bool(false), chars)


}
# --- Number parsing ---

collect_digits(chars, acc) = match chars {
    [c | rest] -> if is_digit(c)
                  then collect_digits(rest, acc ++ [c])
                  else (acc, chars)
    [] -> (acc, [])

}
# Collect integer part, optional decimal point and fractional part
collect_number_chars(chars, acc) = {
    (int_digits, after_int) = collect_digits(chars, acc)
    match after_int {
        ['.' | rest] -> {
            (frac_digits, after_frac) = collect_digits(rest, int_digits ++ ['.'])
            (frac_digits, after_frac)
        }
        _ -> (int_digits, after_int)
    }
}

parse_number(chars) = match chars {
    ['-' | rest] -> {
        (num_chars, remaining) = collect_number_chars(rest, [])
        num = unwrapOr(String.toFloat(String.from_chars(num_chars)), 0.0)
        (Number(0.0 - num), remaining)
    }
    _ -> {
        (num_chars, rest) = collect_number_chars(chars, [])
        num = unwrapOr(String.toFloat(String.from_chars(num_chars)), 0.0)
        (Number(num), rest)
    }


}
# --- String parsing ---

collect_string_chars(chars, acc) = match chars {
    ['"' | rest]  -> (acc, rest)
    ['\\', c | rest] -> collect_string_chars(rest, acc ++ [c])
    [c | rest]    -> collect_string_chars(rest, acc ++ [c])
    []            -> (acc, [])

}
parse_string(chars) = {
    (content, rest) = collect_string_chars(chars, [])
    (String(String.from_chars(content)), rest)
}

extract_string(json) = match json {
    String(s) -> s
    _ -> ""


}
# --- Array parsing ---

parse_array_items(chars) = {
    trimmed = skip_ws(chars)
    match trimmed {
        [']' | rest] -> ([], rest)
        _ -> parse_array_item(trimmed)
    }
}

parse_array_item(chars) = {
    (value, after_value) = parse_value(chars)
    after_ws = skip_ws(after_value)
    match after_ws {
        [',' | rest] -> {
            (more, final) = parse_array_items(rest)
            ([value | more], final)
        }
        [']' | rest] -> ([value], rest)
        _ -> ([value], after_ws)
    }
}

parse_array(chars) = {
    (items, rest) = parse_array_items(chars)
    (Array(items), rest)
}


# --- Object parsing ---

parse_object_items(chars) = {
    trimmed = skip_ws(chars)
    match trimmed {
        ['}' | rest] -> ([], rest)
        _ -> parse_object_entry(trimmed)
    }
}

parse_object_entry(chars) = {
    (key_json, after_key) = parse_value(chars)
    key = extract_string(key_json)
    after_colon = skip_ws(after_key)
    match after_colon {
        [':' | rest1] -> {
            (value, after_value) = parse_value(rest1)
            after_ws = skip_ws(after_value)
            match after_ws {
                [',' | rest2] -> {
                    (more, final) = parse_object_items(rest2)
                    ([(key, value) | more], final)
                }
                ['}' | rest3] -> ([(key, value)], rest3)
                _ -> ([(key, value)], after_ws)
            }
        }
        _ -> ([], after_colon)
    }
}

parse_object(chars) = {
    (items, rest) = parse_object_items(chars)
    (Object(items), rest)
}


# --- Main value parser ---

parse_value(chars) = {
    trimmed = skip_ws(chars)
    match trimmed {
        ['{' | rest] -> parse_object(rest)
        ['[' | rest] -> parse_array(rest)
        ['"' | rest] -> parse_string(rest)
        ['t' | _]    -> parse_true(trimmed)
        ['f' | _]    -> parse_false(trimmed)
        ['n' | _]    -> parse_null(trimmed)
        _            -> parse_number(trimmed)
    }
}


# --- Stringify helpers ---

stringify_array([], acc) = acc
stringify_array([x], acc) = acc ++ stringify(x)
stringify_array([x | rest], acc) = stringify_array(rest, acc ++ stringify(x) ++ ",")

stringify_object([], acc) = acc
stringify_object([(k, v)], acc) = acc ++ "\"" ++ k ++ "\":" ++ stringify(v)
stringify_object([(k, v) | rest], acc) =
    stringify_object(rest, acc ++ "\"" ++ k ++ "\":" ++ stringify(v) ++ ",")

stringify(json) = match json {
    Null -> "null"
    Bool(true) -> "true"
    Bool(false) -> "false"
    Number(n) -> show(n)
    String(s) -> "\"" ++ s ++ "\""
    Array(items) -> "[" ++ stringify_array(items, "") ++ "]"
    Object(pairs) -> "{" ++ stringify_object(pairs, "") ++ "}"


}
# --- JSON to Type Conversion ---

# Find a value by key in Object pairs list
findField(pairs, key) = match pairs {
    [] -> Null
    [(k, v) | rest] -> if k == key then v else findField(rest, key)

}
# Check if type is a numeric type
isNumericType(typeName) =
    typeName == "Int" || typeName == "Int8" || typeName == "Int16" ||
    typeName == "Int32" || typeName == "Int64" ||
    typeName == "UInt8" || typeName == "UInt16" || typeName == "UInt32" || typeName == "UInt64" ||
    typeName == "Float" || typeName == "Float32" || typeName == "Float64" ||
    typeName == "BigInt"

# Convert a number to the expected numeric type
convertNumber(n, typeName) =
    if typeName == "Int" || typeName == "Int64" then n.asInt64()
    else if typeName == "Int8" then n.asInt8()
    else if typeName == "Int16" then n.asInt16()
    else if typeName == "Int32" then n.asInt32()
    else if typeName == "UInt8" then n.asUInt8()
    else if typeName == "UInt16" then n.asUInt16()
    else if typeName == "UInt32" then n.asUInt32()
    else if typeName == "UInt64" then n.asUInt64()
    else if typeName == "Float32" then n.asFloat32()
    else if typeName == "BigInt" then n.asBigInt()
    else n  # Float64 or Float

# Convert a Json value to the expected primitive type
convertPrimitive(json, typeName) =
    if isNumericType(typeName) then
        match json {
            Number(n) -> convertNumber(n, typeName)
            _ -> throw("Expected Number for " ++ typeName ++ ", got " ++ show(json))
        }
    else if typeName == "String" then
        match json {
            String(s) -> s
            _ -> throw("Expected String, got " ++ show(json))
        }
    else if typeName == "Bool" then
        match json {
            Bool(b) -> b
            _ -> throw("Expected Bool, got " ++ show(json))
        }
    else if typeName == "Char" then
        match json {
            String(s) -> match String.chars(s) {
                [c | _] -> c
                [] -> throw("Expected non-empty string for Char")
            }
            _ -> throw("Expected String for Char, got " ++ show(json))
        }
    else
        # Nested type - recursive call
        fromJsonValue(typeName, json)

# Build field map for record construction
buildRecordFields(fields, pairs, acc) = match fields {
    [] -> acc
    [field | rest] -> {
        fieldName = Map.get(field, "name")
        fieldType = Map.get(field, "type")
        jsonValue = findField(pairs, fieldName)
        convertedValue = convertPrimitive(jsonValue, fieldType)
        newAcc = Map.insert(acc, fieldName, convertedValue)
        buildRecordFields(rest, pairs, newAcc)
    }

}
# Check if a key exists in pairs list
hasKey(pairs, key) = match pairs {
    [] -> false
    [(k, _) | rest] -> if k == key then true else hasKey(rest, key)

}
# Parse field index from name like "_0", "_1", etc.
parseFieldIndex(name) = match String.chars(name) {
    ['_' | rest] -> unwrapOr(String.toInt(String.from_chars(rest)), -1)
    _ -> -1

}
# Get element at index from list
listGet(list, idx) = match list {
    [] -> Null
    [x | rest] -> if idx == 0 then x else listGet(rest, idx - 1)

}
# Extract field value from Json for variant field building
# - Single-field variants: value is passed directly (e.g., 42 for Ok(42))
# - Multi-field variants: value is an array (e.g., [10, 20] for Click(10, 20))
getVariantFieldValue(fieldName, jsonValue) = match jsonValue {
    Array(items) -> {
        # Multi-field variant uses array format
        idx = parseFieldIndex(fieldName)
        if idx >= 0 then listGet(items, idx) else Null
    }
    Object(pairs) ->
        # Legacy: handle object format if present
        if hasKey(pairs, fieldName)
        then findField(pairs, fieldName)
        else jsonValue
    _ -> jsonValue  # Single-field variant: use value directly

}
# Build field map for variant constructor
buildVariantFields(ctorFields, jsonValue, acc) = match ctorFields {
    [] -> acc
    [field | rest] -> {
        fieldName = Map.get(field, "name")
        fieldType = Map.get(field, "type")
        value = getVariantFieldValue(fieldName, jsonValue)
        convertedValue = convertPrimitive(value, fieldType)
        newAcc = Map.insert(acc, fieldName, convertedValue)
        buildVariantFields(rest, jsonValue, newAcc)
    }

}
# Find constructor by name in constructors list
findConstructor(constructors, name) = match constructors {
    [] -> %{}
    [ctor | rest] ->
        if Map.get(ctor, "name") == name
        then ctor
        else findConstructor(rest, name)

}
# Parse a parameterized type name like "Result[Int, String]"
# Returns (baseType, [typeArgs])
parseTypeName(typeName) = {
    chars = String.chars(typeName)
    parseTypeNameChars(chars, [], 0)
}

parseTypeNameChars(chars, acc, depth) = match chars {
    [] -> (String.from_chars(acc), [])
    ['[' | rest] -> {
        baseName = String.from_chars(acc)
        (args, _) = parseTypeArgs(rest, [], [], 0)
        (baseName, args)
    }
    [c | rest] -> parseTypeNameChars(rest, acc ++ [c], depth)

}
parseTypeArgs(chars, currentArg, args, depth) = match chars {
    [] -> (args ++ [String.trim(String.from_chars(currentArg))], [])
    [']' | rest] ->
        if depth == 0 then
            (args ++ [String.trim(String.from_chars(currentArg))], rest)
        else
            parseTypeArgs(rest, currentArg ++ [']'], args, depth - 1)
    ['[' | rest] -> parseTypeArgs(rest, currentArg ++ ['['], args, depth + 1)
    [',' | rest] ->
        if depth == 0 then
            parseTypeArgs(rest, [], args ++ [String.trim(String.from_chars(currentArg))], 0)
        else
            parseTypeArgs(rest, currentArg ++ [','], args, depth)
    [c | rest] -> parseTypeArgs(rest, currentArg ++ [c], args, depth)

}
# Build substitution map from type params to concrete types
buildTypeParamMap(typeParams, typeArgs, acc) = match typeParams {
    [] -> acc
    [param | restParams] -> match typeArgs {
        [] -> acc
        [arg | restArgs] -> buildTypeParamMap(restParams, restArgs, Map.insert(acc, param, arg))
    }
}
# Substitute type parameter in a field type
substituteTypeParam(fieldType, typeParamMap) =
    if Map.contains(typeParamMap, fieldType)
    then Map.get(typeParamMap, fieldType)
    else fieldType

# Convert Json to typed value by type name
# Supports parameterized types like "Result[Int, String]"
pub fromJsonValue(typeName, json) = {
    (baseType, typeArgs) = parseTypeName(typeName)
    info = typeInfo(baseType)

    # Check for unknown type (empty map)
    if Map.isEmpty(info) then
        throw("Unknown type: " ++ baseType)
    else {
        # Build type parameter substitution map
        typeParamMap = if Map.contains(info, "type_params")
            then buildTypeParamMap(Map.get(info, "type_params"), typeArgs, %{})
            else %{}

        kind = Map.get(info, "kind")

        if kind == "record" then {
            # Record: json should be Object with field values
            match json {
                Object(pairs) -> {
                    fields = Map.get(info, "fields")
                    fieldMap = buildRecordFieldsWithSubs(fields, pairs, typeParamMap, %{})
                    makeRecordByName(baseType, fieldMap)
                }
                _ -> throw("Expected Object for record type " ++ baseType)
            }
        }
        else if kind == "variant" then {
            # Variant: json should be Object with single key (constructor name)
            match json {
                Object(pairs) -> match pairs {
                    [(ctorName, ctorValue)] -> {
                        constructors = Map.get(info, "constructors")
                        ctor = findConstructor(constructors, ctorName)
                        if Map.isEmpty(ctor) then
                            throw("Unknown constructor: " ++ ctorName ++ " for type " ++ baseType)
                        else {
                            ctorFields = Map.get(ctor, "fields")
                            fieldMap = buildVariantFieldsWithSubs(ctorFields, ctorValue, typeParamMap, %{})
                            makeVariantByName(baseType, ctorName, fieldMap)
                        }
                    }
                    _ -> throw("Variant JSON must have exactly one key (constructor name)")
                }
                _ -> throw("Expected Object for variant type " ++ baseType)
            }
        }
        else
            throw("Cannot convert JSON to type: " ++ baseType ++ " (kind: " ++ kind ++ ")")
    }
}

# Build field map for record construction with type param substitution
buildRecordFieldsWithSubs(fields, pairs, typeParamMap, acc) = match fields {
    [] -> acc
    [field | rest] -> {
        fieldName = Map.get(field, "name")
        rawFieldType = Map.get(field, "type")
        fieldType = substituteTypeParam(rawFieldType, typeParamMap)
        jsonValue = findField(pairs, fieldName)
        convertedValue = convertPrimitive(jsonValue, fieldType)
        newAcc = Map.insert(acc, fieldName, convertedValue)
        buildRecordFieldsWithSubs(rest, pairs, typeParamMap, newAcc)
    }

}
# Build field map for variant constructor with type param substitution
buildVariantFieldsWithSubs(ctorFields, jsonValue, typeParamMap, acc) = match ctorFields {
    [] -> acc
    [field | rest] -> {
        fieldName = Map.get(field, "name")
        rawFieldType = Map.get(field, "type")
        fieldType = substituteTypeParam(rawFieldType, typeParamMap)
        value = getVariantFieldValue(fieldName, jsonValue)
        convertedValue = convertPrimitive(value, fieldType)
        newAcc = Map.insert(acc, fieldName, convertedValue)
        buildVariantFieldsWithSubs(rest, jsonValue, typeParamMap, newAcc)
    }


}
# --- Public API ---

# Parse a JSON string into a Json value
pub jsonParse(input) = {
    chars = String.chars(input)
    (value, _) = parse_value(chars)
    value
}

# Convert a Json value back to a JSON string
pub jsonStringify(json) = stringify(json)


