# JSON Parser for Nostos
#
# Parses JSON strings into a Json variant type.
# Usage: jsonParse("{\"key\": 123}")

type Json =
    | Null
    | Bool(Bool)
    | Number(Float)
    | String(String)
    | Array(List[Json])
    | Object(List[(String, Json)])


# --- Character classification helpers ---

is_whitespace(c) = c == ' ' || c == '\n' || c == '\t' || c == '\r'

# Match digit characters explicitly since char comparisons aren't supported
is_digit(c) = match c
    '0' -> true
    '1' -> true
    '2' -> true
    '3' -> true
    '4' -> true
    '5' -> true
    '6' -> true
    '7' -> true
    '8' -> true
    '9' -> true
    _ -> false


# --- Whitespace handling ---

skip_ws(chars) = match chars
    [c | rest] -> if is_whitespace(c) then skip_ws(rest) else chars
    [] -> []


# --- Primitive parsers ---

parse_null(chars) = match chars
    ['n', 'u', 'l', 'l' | rest] -> (Null, rest)
    _ -> (Null, chars)

parse_true(chars) = match chars
    ['t', 'r', 'u', 'e' | rest] -> (Bool(true), rest)
    _ -> (Bool(false), chars)

parse_false(chars) = match chars
    ['f', 'a', 'l', 's', 'e' | rest] -> (Bool(false), rest)
    _ -> (Bool(false), chars)


# --- Number parsing ---

collect_digits(chars, acc) = match chars
    [c | rest] -> if is_digit(c)
                  then collect_digits(rest, acc ++ [c])
                  else (acc, chars)
    [] -> (acc, [])

# Collect integer part, optional decimal point and fractional part
collect_number_chars(chars, acc) = {
    (int_digits, after_int) = collect_digits(chars, acc)
    match after_int
        ['.' | rest] -> {
            (frac_digits, after_frac) = collect_digits(rest, int_digits ++ ['.'])
            (frac_digits, after_frac)
        }
        _ -> (int_digits, after_int)
}

parse_number(chars) = match chars
    ['-' | rest] -> {
        (num_chars, remaining) = collect_number_chars(rest, [])
        num = String.toFloat(String.from_chars(num_chars))
        (Number(0.0 - num), remaining)
    }
    _ -> {
        (num_chars, rest) = collect_number_chars(chars, [])
        num = String.toFloat(String.from_chars(num_chars))
        (Number(num), rest)
    }


# --- String parsing ---

collect_string_chars(chars, acc) = match chars
    ['"' | rest]  -> (acc, rest)
    ['\\', c | rest] -> collect_string_chars(rest, acc ++ [c])
    [c | rest]    -> collect_string_chars(rest, acc ++ [c])
    []            -> (acc, [])

parse_string(chars) = {
    (content, rest) = collect_string_chars(chars, [])
    (String(String.from_chars(content)), rest)
}

extract_string(json) = match json
    String(s) -> s
    _ -> ""


# --- Array parsing ---

parse_array_items(chars) = {
    trimmed = skip_ws(chars)
    match trimmed
        [']' | rest] -> ([], rest)
        _ -> parse_array_item(trimmed)
}

parse_array_item(chars) = {
    (value, after_value) = parse_value(chars)
    after_ws = skip_ws(after_value)
    match after_ws
        [',' | rest] -> {
            (more, final) = parse_array_items(rest)
            ([value | more], final)
        }
        [']' | rest] -> ([value], rest)
        _ -> ([value], after_ws)
}

parse_array(chars) = {
    (items, rest) = parse_array_items(chars)
    (Array(items), rest)
}


# --- Object parsing ---

parse_object_items(chars) = {
    trimmed = skip_ws(chars)
    match trimmed
        ['}' | rest] -> ([], rest)
        _ -> parse_object_entry(trimmed)
}

parse_object_entry(chars) = {
    (key_json, after_key) = parse_value(chars)
    key = extract_string(key_json)
    after_colon = skip_ws(after_key)
    match after_colon
        [':' | rest1] -> {
            (value, after_value) = parse_value(rest1)
            after_ws = skip_ws(after_value)
            match after_ws
                [',' | rest2] -> {
                    (more, final) = parse_object_items(rest2)
                    ([(key, value) | more], final)
                }
                ['}' | rest3] -> ([(key, value)], rest3)
                _ -> ([(key, value)], after_ws)
        }
        _ -> ([], after_colon)
}

parse_object(chars) = {
    (items, rest) = parse_object_items(chars)
    (Object(items), rest)
}


# --- Main value parser ---

parse_value(chars) = {
    trimmed = skip_ws(chars)
    match trimmed
        ['{' | rest] -> parse_object(rest)
        ['[' | rest] -> parse_array(rest)
        ['"' | rest] -> parse_string(rest)
        ['t' | _]    -> parse_true(trimmed)
        ['f' | _]    -> parse_false(trimmed)
        ['n' | _]    -> parse_null(trimmed)
        _            -> parse_number(trimmed)
}


# --- Stringify helpers ---

stringify_array([], acc) = acc
stringify_array([x], acc) = acc ++ stringify(x)
stringify_array([x | rest], acc) = stringify_array(rest, acc ++ stringify(x) ++ ",")

stringify_object([], acc) = acc
stringify_object([(k, v)], acc) = acc ++ "\"" ++ k ++ "\":" ++ stringify(v)
stringify_object([(k, v) | rest], acc) =
    stringify_object(rest, acc ++ "\"" ++ k ++ "\":" ++ stringify(v) ++ ",")

stringify(json) = match json
    Null -> "null"
    Bool(true) -> "true"
    Bool(false) -> "false"
    Number(n) -> show(n)
    String(s) -> "\"" ++ s ++ "\""
    Array(items) -> "[" ++ stringify_array(items, "") ++ "]"
    Object(pairs) -> "{" ++ stringify_object(pairs, "") ++ "}"


# --- Public API ---

# Parse a JSON string into a Json value
pub jsonParse(input) = {
    chars = String.chars(input)
    (value, _) = parse_value(chars)
    value
}

# Convert a Json value back to a JSON string
pub jsonStringify(json) = stringify(json)


