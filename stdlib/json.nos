# JSON Parser for Nostos
#
# Parses JSON strings into a Json variant type.
# Usage: jsonParse("{\"key\": 123}")

type Json =
    | Null
    | Bool(Bool)
    | Number(Float)
    | String(String)
    | Array(List[Json])
    | Object(List[(String, Json)])


# --- Character classification helpers ---

is_whitespace(c) = c == ' ' || c == '\n' || c == '\t' || c == '\r'

# Match digit characters explicitly since char comparisons aren't supported
is_digit(c) = match c
    '0' -> true
    '1' -> true
    '2' -> true
    '3' -> true
    '4' -> true
    '5' -> true
    '6' -> true
    '7' -> true
    '8' -> true
    '9' -> true
    _ -> false


# --- Whitespace handling ---

skip_ws(chars) = match chars
    [c | rest] -> if is_whitespace(c) then skip_ws(rest) else chars
    [] -> []


# --- Primitive parsers ---

parse_null(chars) = match chars
    ['n', 'u', 'l', 'l' | rest] -> (Null, rest)
    _ -> (Null, chars)

parse_true(chars) = match chars
    ['t', 'r', 'u', 'e' | rest] -> (Bool(true), rest)
    _ -> (Bool(false), chars)

parse_false(chars) = match chars
    ['f', 'a', 'l', 's', 'e' | rest] -> (Bool(false), rest)
    _ -> (Bool(false), chars)


# --- Number parsing ---

collect_digits(chars, acc) = match chars
    [c | rest] -> if is_digit(c)
                  then collect_digits(rest, acc ++ [c])
                  else (acc, chars)
    [] -> (acc, [])

# Collect integer part, optional decimal point and fractional part
collect_number_chars(chars, acc) = {
    (int_digits, after_int) = collect_digits(chars, acc)
    match after_int
        ['.' | rest] -> {
            (frac_digits, after_frac) = collect_digits(rest, int_digits ++ ['.'])
            (frac_digits, after_frac)
        }
        _ -> (int_digits, after_int)
}

parse_number(chars) = match chars
    ['-' | rest] -> {
        (num_chars, remaining) = collect_number_chars(rest, [])
        num = String.toFloat(String.from_chars(num_chars))
        (Number(0.0 - num), remaining)
    }
    _ -> {
        (num_chars, rest) = collect_number_chars(chars, [])
        num = String.toFloat(String.from_chars(num_chars))
        (Number(num), rest)
    }


# --- String parsing ---

collect_string_chars(chars, acc) = match chars
    ['"' | rest]  -> (acc, rest)
    ['\\', c | rest] -> collect_string_chars(rest, acc ++ [c])
    [c | rest]    -> collect_string_chars(rest, acc ++ [c])
    []            -> (acc, [])

parse_string(chars) = {
    (content, rest) = collect_string_chars(chars, [])
    (String(String.from_chars(content)), rest)
}

extract_string(json) = match json
    String(s) -> s
    _ -> ""


# --- Array parsing ---

parse_array_items(chars) = {
    trimmed = skip_ws(chars)
    match trimmed
        [']' | rest] -> ([], rest)
        _ -> parse_array_item(trimmed)
}

parse_array_item(chars) = {
    (value, after_value) = parse_value(chars)
    after_ws = skip_ws(after_value)
    match after_ws
        [',' | rest] -> {
            (more, final) = parse_array_items(rest)
            ([value | more], final)
        }
        [']' | rest] -> ([value], rest)
        _ -> ([value], after_ws)
}

parse_array(chars) = {
    (items, rest) = parse_array_items(chars)
    (Array(items), rest)
}


# --- Object parsing ---

parse_object_items(chars) = {
    trimmed = skip_ws(chars)
    match trimmed
        ['}' | rest] -> ([], rest)
        _ -> parse_object_entry(trimmed)
}

parse_object_entry(chars) = {
    (key_json, after_key) = parse_value(chars)
    key = extract_string(key_json)
    after_colon = skip_ws(after_key)
    match after_colon
        [':' | rest1] -> {
            (value, after_value) = parse_value(rest1)
            after_ws = skip_ws(after_value)
            match after_ws
                [',' | rest2] -> {
                    (more, final) = parse_object_items(rest2)
                    ([(key, value) | more], final)
                }
                ['}' | rest3] -> ([(key, value)], rest3)
                _ -> ([(key, value)], after_ws)
        }
        _ -> ([], after_colon)
}

parse_object(chars) = {
    (items, rest) = parse_object_items(chars)
    (Object(items), rest)
}


# --- Main value parser ---

parse_value(chars) = {
    trimmed = skip_ws(chars)
    match trimmed
        ['{' | rest] -> parse_object(rest)
        ['[' | rest] -> parse_array(rest)
        ['"' | rest] -> parse_string(rest)
        ['t' | _]    -> parse_true(trimmed)
        ['f' | _]    -> parse_false(trimmed)
        ['n' | _]    -> parse_null(trimmed)
        _            -> parse_number(trimmed)
}


# --- Stringify helpers ---

stringify_array([], acc) = acc
stringify_array([x], acc) = acc ++ stringify(x)
stringify_array([x | rest], acc) = stringify_array(rest, acc ++ stringify(x) ++ ",")

stringify_object([], acc) = acc
stringify_object([(k, v)], acc) = acc ++ "\"" ++ k ++ "\":" ++ stringify(v)
stringify_object([(k, v) | rest], acc) =
    stringify_object(rest, acc ++ "\"" ++ k ++ "\":" ++ stringify(v) ++ ",")

stringify(json) = match json
    Null -> "null"
    Bool(true) -> "true"
    Bool(false) -> "false"
    Number(n) -> show(n)
    String(s) -> "\"" ++ s ++ "\""
    Array(items) -> "[" ++ stringify_array(items, "") ++ "]"
    Object(pairs) -> "{" ++ stringify_object(pairs, "") ++ "}"


# --- JSON to Type Conversion ---

# Find a value by key in Object pairs list
findField(pairs, key) = match pairs
    [] -> Null
    [(k, v) | rest] -> if k == key then v else findField(rest, key)

# Check if type is a numeric type
isNumericType(typeName) =
    typeName == "Int" || typeName == "Int8" || typeName == "Int16" ||
    typeName == "Int32" || typeName == "Int64" ||
    typeName == "UInt8" || typeName == "UInt16" || typeName == "UInt32" || typeName == "UInt64" ||
    typeName == "Float" || typeName == "Float32" || typeName == "Float64" ||
    typeName == "BigInt"

# Convert a number to the expected numeric type
convertNumber(n, typeName) =
    if typeName == "Int" || typeName == "Int64" then toInt(n)
    else if typeName == "Int8" then toInt8(n)
    else if typeName == "Int16" then toInt16(n)
    else if typeName == "Int32" then toInt32(n)
    else if typeName == "UInt8" then toUInt8(n)
    else if typeName == "UInt16" then toUInt16(n)
    else if typeName == "UInt32" then toUInt32(n)
    else if typeName == "UInt64" then toUInt64(n)
    else if typeName == "Float32" then toFloat32(n)
    else if typeName == "BigInt" then toBigInt(n)
    else n  # Float64 or Float

# Convert a Json value to the expected primitive type
convertPrimitive(json, typeName) =
    if isNumericType(typeName) then
        match json
            Number(n) -> convertNumber(n, typeName)
            _ -> throw("Expected Number for " ++ typeName ++ ", got " ++ show(json))
    else if typeName == "String" then
        match json
            String(s) -> s
            _ -> throw("Expected String, got " ++ show(json))
    else if typeName == "Bool" then
        match json
            Bool(b) -> b
            _ -> throw("Expected Bool, got " ++ show(json))
    else if typeName == "Char" then
        match json
            String(s) -> match String.chars(s)
                [c | _] -> c
                [] -> throw("Expected non-empty string for Char")
            _ -> throw("Expected String for Char, got " ++ show(json))
    else
        # Nested type - recursive call
        fromJson(typeName, json)

# Build field map for record construction
buildRecordFields(fields, pairs, acc) = match fields
    [] -> acc
    [field | rest] -> {
        fieldName = Map.get(field, "name")
        fieldType = Map.get(field, "type")
        jsonValue = findField(pairs, fieldName)
        convertedValue = convertPrimitive(jsonValue, fieldType)
        newAcc = Map.insert(acc, fieldName, convertedValue)
        buildRecordFields(rest, pairs, newAcc)
    }

# Extract field value from Json for variant field building
# For single-field variants with name "_0", the value is passed directly
# For multi-field variants, extract from Object pairs
getVariantFieldValue(fieldName, jsonValue) = match jsonValue
    Object(pairs) -> findField(pairs, fieldName)
    _ -> if fieldName == "_0" then jsonValue else jsonValue

# Build field map for variant constructor
buildVariantFields(ctorFields, jsonValue, acc) = match ctorFields
    [] -> acc
    [field | rest] -> {
        fieldName = Map.get(field, "name")
        fieldType = Map.get(field, "type")
        value = getVariantFieldValue(fieldName, jsonValue)
        convertedValue = convertPrimitive(value, fieldType)
        newAcc = Map.insert(acc, fieldName, convertedValue)
        buildVariantFields(rest, jsonValue, newAcc)
    }

# Find constructor by name in constructors list
findConstructor(constructors, name) = match constructors
    [] -> %{}
    [ctor | rest] ->
        if Map.get(ctor, "name") == name
        then ctor
        else findConstructor(rest, name)

# Convert Json to typed value by type name
# This is the main conversion function
pub fromJson(typeName, json) = {
    info = typeInfo(typeName)

    # Check for unknown type (empty map)
    if Map.isEmpty(info) then
        throw("Unknown type: " ++ typeName)
    else {
        kind = Map.get(info, "kind")

        if kind == "record" then {
            # Record: json should be Object with field values
            match json
                Object(pairs) -> {
                    fields = Map.get(info, "fields")
                    fieldMap = buildRecordFields(fields, pairs, %{})
                    makeRecordByName(typeName, fieldMap)
                }
                _ -> throw("Expected Object for record type " ++ typeName)
        }
        else if kind == "variant" then {
            # Variant: json should be Object with single key (constructor name)
            match json
                Object(pairs) -> match pairs
                    [(ctorName, ctorValue)] -> {
                        constructors = Map.get(info, "constructors")
                        ctor = findConstructor(constructors, ctorName)
                        if Map.isEmpty(ctor) then
                            throw("Unknown constructor: " ++ ctorName ++ " for type " ++ typeName)
                        else {
                            ctorFields = Map.get(ctor, "fields")
                            fieldMap = buildVariantFields(ctorFields, ctorValue, %{})
                            makeVariantByName(typeName, ctorName, fieldMap)
                        }
                    }
                    _ -> throw("Variant JSON must have exactly one key (constructor name)")
                _ -> throw("Expected Object for variant type " ++ typeName)
        }
        else
            throw("Cannot convert JSON to type: " ++ typeName ++ " (kind: " ++ kind ++ ")")
    }
}


# --- Public API ---

# Parse a JSON string into a Json value
pub jsonParse(input) = {
    chars = String.chars(input)
    (value, _) = parse_value(chars)
    value
}

# Convert a Json value back to a JSON string
pub jsonStringify(json) = stringify(json)


