# List Standard Library
# Functional list operations for Nostos
#
# All functions use receiver-first parameter order to support method chaining:
#   [1, 2, 3].map(x => x * 2).filter(x => x > 2)

# Option type for functions that may not return a value
pub type Option[T] = Some(T) | None

# Get last element of a list
last([x]) = x
last([_ | rest]) = last(rest)

# Get all elements except the last
init([_]) = []
init([x | rest]) = [x | init(rest)]

# Get element at index (0-based)
nth(list, 0) = head(list)
nth(list, n) = nth(tail(list), n - 1)

# Alias for nth
get(list, idx) = nth(list, idx)

# Set element at index, returns new list
set([], _, _) = []
set([_ | rest], 0, val) = [val | rest]
set([x | rest], idx, val) = [x | set(rest, idx - 1, val)]

# Append element to end of list
push([], x) = [x]
push([h | t], x) = [h | push(t, x)]

# Remove and return last element as (list, element) tuple
pop([x]) = ([], x)
pop([h | t]) = {
    (rest, last) = pop(t)
    ([h | rest], last)
}

# Get sublist from start to stop index (exclusive)
slice(list, start, stop) = take(list, stop - start).drop(start)

# Concatenate two lists
concat([], ys) = ys
concat([x | xs], ys) = [x | concat(xs, ys)]

# Reverse a list
reverse(list) = reverseAcc(list, [])
reverseAcc([], acc) = acc
reverseAcc([x | xs], acc) = reverseAcc(xs, [x | acc])

# Sort a list (quicksort)
sort([]) = []
sort([pivot | rest]) = {
    lesser = rest.filter(x => x < pivot)
    greater = rest.filter(x => x >= pivot)
    concat(sort(lesser), [pivot | sort(greater)])
}

# Apply function to each element, return new list
map([], _) = []
map([x | xs], f) = [f(x) | map(xs, f)]

# Apply function to each element for side effects only, returns unit
each([], _) = ()
each([x | xs], f) = { f(x); each(xs, f) }

# Keep elements that satisfy predicate
filter([], _) = []
filter([x | xs], pred) = if pred(x) then [x | filter(xs, pred)] else filter(xs, pred)

# Reduce list to single value (left fold)
fold([], acc, _) = acc
fold([x | xs], acc, f) = fold(xs, f(acc, x), f)

# Right fold
foldr([], acc, _) = acc
foldr([x | xs], acc, f) = f(x, foldr(xs, acc, f))

# True if any element satisfies predicate
any([], _) = false
any([x | xs], pred) = if pred(x) then true else any(xs, pred)

# True if all elements satisfy predicate
all([], _) = true
all([x | xs], pred) = if pred(x) then all(xs, pred) else false

# Find first element satisfying predicate
find([], _) = None
find([x | xs], pred) = if pred(x) then Some(x) else find(xs, pred)

# Find index of first match
position([], _) = None
position(list, pred) = positionAcc(list, pred, 0)
positionAcc([], _, _) = None
positionAcc([x | xs], pred, idx) = if pred(x) then Some(idx) else positionAcc(xs, pred, idx + 1)

# Remove duplicate elements (keeps first occurrence)
unique([]) = []
unique([x | xs]) = [x | unique(xs.filter(y => y != x))]

# Flatten nested list one level
flatten([]) = []
flatten([x | xs]) = concat(x, flatten(xs))

# Pair up elements from two lists
zip([], _) = []
zip(_, []) = []
zip([x | xs], [y | ys]) = [(x, y) | zip(xs, ys)]

# Split list of pairs into two lists
unzip([]) = ([], [])
unzip([(a, b) | rest]) = {
    (as, bs) = unzip(rest)
    ([a | as], [b | bs])
}

# Take first n elements
take([], _) = []
take(_, 0) = []
take([x | xs], n) = [x | take(xs, n - 1)]

# Drop first n elements
drop(list, 0) = list
drop([], _) = []
drop([_ | xs], n) = drop(xs, n - 1)

# Create list of n copies of a value
replicate(n, x) = replicateAcc(n, x, [])
replicateAcc(0, _, acc) = acc
replicateAcc(n, x, acc) = replicateAcc(n - 1, x, [x | acc])

# Check if element is in list
contains([], _) = false
contains([y | ys], x) = if x == y then true else contains(ys, x)

# Alias for backwards compatibility
elem(x, list) = contains(list, x)

# Remove first occurrence of element
remove([], _) = []
remove([y | ys], x) = if x == y then ys else [y | remove(ys, x)]

# Remove element at index
removeAt([], _) = []
removeAt([_ | xs], 0) = xs
removeAt([x | xs], idx) = [x | removeAt(xs, idx - 1)]

# Insert element at index
insertAt(list, 0, x) = [x | list]
insertAt([], _, x) = [x]
insertAt([h | t], idx, x) = [h | insertAt(t, idx - 1, x)]

# Partition list by predicate into (matching, non-matching)
partition([], _) = ([], [])
partition([x | xs], pred) = {
    (yes, no) = partition(xs, pred)
    if pred(x) then ([x | yes], no) else (yes, [x | no])
}

# Take elements while predicate is true
takeWhile([], _) = []
takeWhile([x | xs], pred) = if pred(x) then [x | takeWhile(xs, pred)] else []

# Drop elements while predicate is true
dropWhile([], _) = []
dropWhile([x | xs], pred) = if pred(x) then dropWhile(xs, pred) else [x | xs]

# Split list at index
splitAt(list, 0) = ([], list)
splitAt([], _) = ([], [])
splitAt([x | xs], n) = {
    (left, right) = splitAt(xs, n - 1)
    ([x | left], right)
}

# Interleave two lists
interleave([], ys) = ys
interleave(xs, []) = xs
interleave([x | xs], ys) = [x | interleave(ys, xs)]

# Group consecutive equal elements
group([]) = []
group([x | xs]) = groupAcc(xs, x, [x], [])
groupAcc([], _, current, acc) = reverse([reverse(current) | acc])
groupAcc([x | xs], prev, current, acc) =
    if x == prev
    then groupAcc(xs, x, [x | current], acc)
    else groupAcc(xs, x, [x], [reverse(current) | acc])

# Scan (like fold but returns all intermediate values)
scanl([], acc, _) = [acc]
scanl([x | xs], acc, f) = [acc | scanl(xs, f(acc, x), f)]

# Zip with custom function
zipWith([], _, _) = []
zipWith(_, [], _) = []
zipWith([x | xs], [y | ys], f) = [f(x, y) | zipWith(xs, ys, f)]

# Get indices where predicate is true
findIndices(list, pred) = findIndicesAcc(list, pred, 0)
findIndicesAcc([], _, _) = []
findIndicesAcc([x | xs], pred, idx) =
    if pred(x)
    then [idx | findIndicesAcc(xs, pred, idx + 1)]
    else findIndicesAcc(xs, pred, idx + 1)

# Count elements satisfying predicate
count(list, pred) = list.fold(0, (acc, x) => if pred(x) then acc + 1 else acc)

# Maximum element (requires non-empty list)
maximum([x]) = x
maximum([x | xs]) = {
    m = maximum(xs)
    if x > m then x else m
}

# Minimum element (requires non-empty list)
minimum([x]) = x
minimum([x | xs]) = {
    m = minimum(xs)
    if x < m then x else m
}

# Sum all elements (requires numeric list)
sum(list) = list.fold(0, (acc, x) => acc + x)

# Product of all elements (requires numeric list)
product(list) = list.fold(1, (acc, x) => acc * x)

# Find index of first element equal to target
indexOf([], _) = None
indexOf(list, target) = indexOfAcc(list, target, 0)
indexOfAcc([], _, _) = None
indexOfAcc([x | xs], target, idx) = if x == target then Some(idx) else indexOfAcc(xs, target, idx + 1)

# Sort with custom comparator (comparator returns -1, 0, or 1)
sortBy([], _) = []
sortBy([pivot | rest], cmp) = {
    lesser = rest.filter(x => cmp(x, pivot) < 0)
    greater = rest.filter(x => cmp(x, pivot) >= 0)
    concat(sortBy(lesser, cmp), [pivot | sortBy(greater, cmp)])
}

# Insert element between all elements
intersperse([], _) = []
intersperse([x], _) = [x]
intersperse([x | xs], sep) = [x, sep | intersperse(xs, sep)]

# Split list at first element not satisfying predicate
# Returns (takeWhile(pred), dropWhile(pred))
# Named spanList to avoid conflict with Html.span
spanList([], _) = ([], [])
spanList([x | xs], pred) = if pred(x) then {
    (ys, zs) = spanList(xs, pred)
    ([x | ys], zs)
} else ([], [x | xs])

# Group consecutive elements by key function
groupBy([], _) = []
groupBy([x | xs], keyFn) = groupByAcc(xs, keyFn, keyFn(x), [x], [])
groupByAcc([], _, _, current, acc) = reverse([reverse(current) | acc])
groupByAcc([x | xs], keyFn, prevKey, current, acc) = {
    key = keyFn(x)
    if key == prevKey
    then groupByAcc(xs, keyFn, key, [x | current], acc)
    else groupByAcc(xs, keyFn, key, [x], [reverse(current) | acc])
}

# Transpose a list of lists (rows become columns)
transpose([]) = []
transpose(rows) = {
    # Check if first row is empty (base case for inner recursion)
    if isEmpty(head(rows))
    then []
    else {
        heads = rows.map(r => head(r))
        tails = rows.map(r => tail(r))
        [heads | transpose(tails)]
    }
}

# Apply function to pairs of adjacent elements
pairwise([], _) = []
pairwise([_], _) = []
pairwise([x, y | rest], f) = [f(x, y) | pairwise([y | rest], f)]

# Check if list is sorted
isSorted([]) = true
isSorted([_]) = true
isSorted([x, y | rest]) = x <= y && isSorted([y | rest])

# Check if list is sorted by comparator
isSortedBy([], _) = true
isSortedBy([_], _) = true
isSortedBy([x, y | rest], cmp) = cmp(x, y) <= 0 && isSortedBy([y | rest], cmp)
