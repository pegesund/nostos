# List Standard Library
# Functional list operations for Nostos
#
# All functions use receiver-first parameter order to support method chaining:
#   [1, 2, 3].map(x => x * 2).filter(x => x > 2)

# Option type for functions that may not return a value
pub type Option[T] = Some(T) | None

# Result type for operations that can fail
pub type Result[T, E] = Ok(T) | Err(E)

# Result helpers - prefixed with 'res' to avoid conflicts with other methods

# Transform the success value, keep error unchanged
resMap[T, U, E](result: Result[T, E], f: (T) -> U) -> Result[U, E] = match result {
    Ok(x) -> Ok(f(x))
    Err(e) -> Err(e)
}

# Transform the error value, keep success unchanged
resMapErr[T, E, F](result: Result[T, E], f: (E) -> F) -> Result[T, F] = match result {
    Ok(x) -> Ok(x)
    Err(e) -> Err(f(e))
}

# Chain operations that return Result
resFlatMap[T, U, E](result: Result[T, E], f: (T) -> Result[U, E]) -> Result[U, E] = match result {
    Ok(x) -> f(x)
    Err(e) -> Err(e)
}

# Get value or throw error message
resUnwrap[T, E](result: Result[T, E]) -> T = match result {
    Ok(x) -> x
    Err(e) -> throw("resUnwrap called on Err: " ++ show(e))
}

# Get value or return default
resUnwrapOr[T, E](result: Result[T, E], default: T) -> T = match result {
    Ok(x) -> x
    Err(_) -> default
}

# Check if Result is Ok
resIsOk[T, E](result: Result[T, E]) -> Bool = match result {
    Ok(_) -> true
    Err(_) -> false
}

# Check if Result is Err
resIsErr[T, E](result: Result[T, E]) -> Bool = match result {
    Ok(_) -> false
    Err(_) -> true
}

# Convert Result to Option (discards error)
resToOption[T, E](result: Result[T, E]) -> Option[T] = match result {
    Ok(x) -> Some(x)
    Err(_) -> None()
}

# Option helpers - prefixed with 'opt' to avoid conflicts with List methods

# Transform the value inside Some, or return None
optMap[T, U](opt: Option[T], f: (T) -> U) -> Option[U] = match opt {
    Some(x) -> Some(f(x))
    None() -> None()
}

# Map and flatten (when f returns an Option)
optFlatMap[T, U](opt: Option[T], f: (T) -> Option[U]) -> Option[U] = match opt {
    Some(x) -> f(x)
    None() -> None()
}

# Get the value or throw error if None
optUnwrap[T](opt: Option[T]) -> T = match opt {
    Some(x) -> x
    None() -> throw("optUnwrap called on None")
}

# Get the value or return default
optUnwrapOr[T](opt: Option[T], default: T) -> T = match opt {
    Some(x) -> x
    None() -> default
}

# Check if Option is Some
optIsSome[T](opt: Option[T]) -> Bool = match opt {
    Some(_) -> true
    None() -> false
}

# Check if Option is None
optIsNone[T](opt: Option[T]) -> Bool = match opt {
    Some(_) -> false
    None() -> true
}

# Get last element of a list
last[T](list: List[T]) -> T = match list {
    [x] -> x
    [_ | rest] -> last(rest)
}

# Get all elements except the last
init[T](list: List[T]) -> List[T] = match list {
    [_] -> []
    [x | rest] -> [x | init(rest)]
}

# Get element at index (0-based)
nth[T](list: List[T], idx: Int) -> T = if idx == 0 then head(list) else nth(tail(list), idx - 1)

# Alias for nth
get[T](list: List[T], idx: Int) -> T = nth(list, idx)

# Set element at index, returns new list
set[T](list: List[T], idx: Int, val: T) -> List[T] = match list {
    [] -> []
    [_ | rest] -> if idx == 0 then [val | rest] else match list { [x | rest2] -> [x | set(rest2, idx - 1, val)] }
}

# Append element to end of list
push[T](list: List[T], x: T) -> List[T] = match list {
    [] -> [x]
    [h | t] -> [h | push(t, x)]
}

# Remove and return last element as (list, element) tuple
pop[T](list: List[T]) -> (List[T], T) = match list {
    [x] -> ([], x)
    [h | t] -> {
        (rest, lst) = pop(t)
        ([h | rest], lst)
    }
}

# Get sublist from start to stop index (exclusive)
slice[T](list: List[T], start: Int, stop: Int) -> List[T] = take(drop(list, start), stop - start)

# Concatenate two lists
concat[T](xs: List[T], ys: List[T]) -> List[T] = match xs {
    [] -> ys
    [x | rest] -> [x | concat(rest, ys)]
}

# Reverse a list
reverse[T](list: List[T]) -> List[T] = reverseAcc(list, [])
reverseAcc[T](list: List[T], acc: List[T]) -> List[T] = match list {
    [] -> acc
    [x | xs] -> reverseAcc(xs, [x | acc])
}

# Sort a list (quicksort)
sort[T](list: List[T]) -> List[T] = match list {
    [] -> []
    [pivot | rest] -> {
        lesser = filter(rest, x => x < pivot)
        greater = filter(rest, x => x >= pivot)
        concat(sort(lesser), [pivot | sort(greater)])
    }
}

# Apply function to each element, return new list
map[T, U](list: List[T], f: (T) -> U) -> List[U] = match list {
    [] -> []
    [x | xs] -> [f(x) | map(xs, f)]
}

# Apply function to each element for side effects only, returns unit
each[T](list: List[T], f: (T) -> Unit) -> Unit = match list {
    [] -> ()
    [x | xs] -> { f(x); each(xs, f) }
}

# Keep elements that satisfy predicate
filter[T](list: List[T], pred: (T) -> Bool) -> List[T] = match list {
    [] -> []
    [x | xs] -> if pred(x) then [x | filter(xs, pred)] else filter(xs, pred)
}

# Reduce list to single value (left fold)
fold[T, U](list: List[T], acc: U, f: (U, T) -> U) -> U = match list {
    [] -> acc
    [x | xs] -> fold(xs, f(acc, x), f)
}

# Right fold
foldr[T, U](list: List[T], acc: U, f: (T, U) -> U) -> U = match list {
    [] -> acc
    [x | xs] -> f(x, foldr(xs, acc, f))
}

# True if any element satisfies predicate
any[T](list: List[T], pred: (T) -> Bool) -> Bool = match list {
    [] -> false
    [x | xs] -> if pred(x) then true else any(xs, pred)
}

# True if all elements satisfy predicate
all[T](list: List[T], pred: (T) -> Bool) -> Bool = match list {
    [] -> true
    [x | xs] -> if pred(x) then all(xs, pred) else false
}

# Find first element satisfying predicate
find[T](list: List[T], pred: (T) -> Bool) -> Option[T] = match list {
    [] -> None()
    [x | xs] -> if pred(x) then Some(x) else find(xs, pred)
}

# Find index of first match
position[T](list: List[T], pred: (T) -> Bool) -> Option[Int] = positionAcc(list, pred, 0)
positionAcc[T](list: List[T], pred: (T) -> Bool, idx: Int) -> Option[Int] = match list {
    [] -> None()
    [x | xs] -> if pred(x) then Some(idx) else positionAcc(xs, pred, idx + 1)
}

# Remove duplicate elements (keeps first occurrence)
unique[T](list: List[T]) -> List[T] = match list {
    [] -> []
    [x | xs] -> [x | unique(filter(xs, y => y != x))]
}

# Flatten nested list one level
flatten[T](list: List[List[T]]) -> List[T] = match list {
    [] -> []
    [x | xs] -> concat(x, flatten(xs))
}

# Map and flatten in one step (monadic bind for lists)
flatMap[T, U](list: List[T], f: (T) -> List[U]) -> List[U] = flatten(map(list, f))

# Pair up elements from two lists
zip[T, U](xs: List[T], ys: List[U]) -> List[(T, U)] = match xs {
    [] -> []
    [x | xrest] -> match ys {
        [] -> []
        [y | yrest] -> [(x, y) | zip(xrest, yrest)]
    }
}

# Split list of pairs into two lists
unzip[T, U](list: List[(T, U)]) -> (List[T], List[U]) = match list {
    [] -> ([], [])
    [(a, b) | rest] -> {
        (as, bs) = unzip(rest)
        ([a | as], [b | bs])
    }
}

# Take first n elements
take[T](list: List[T], n: Int) -> List[T] = match list {
    [] -> []
    [x | xs] -> if n == 0 then [] else [x | take(xs, n - 1)]
}

# Drop first n elements
drop[T](list: List[T], n: Int) -> List[T] = match list {
    [] -> []
    [_ | xs] -> if n == 0 then list else drop(xs, n - 1)
}

# Create list of n copies of a value
replicate[T](n: Int, x: T) -> List[T] = replicateAcc(n, x, [])
replicateAcc[T](n: Int, x: T, acc: List[T]) -> List[T] = if n == 0 then acc else replicateAcc(n - 1, x, [x | acc])

# Check if element is in list
contains[T](list: List[T], x: T) -> Bool = match list {
    [] -> false
    [y | ys] -> if x == y then true else contains(ys, x)
}

# Alias for backwards compatibility
elem[T](x: T, list: List[T]) -> Bool = contains(list, x)

# Remove first occurrence of element
remove[T](list: List[T], x: T) -> List[T] = match list {
    [] -> []
    [y | ys] -> if x == y then ys else [y | remove(ys, x)]
}

# Remove element at index
removeAt[T](list: List[T], idx: Int) -> List[T] = match list {
    [] -> []
    [_ | xs] -> if idx == 0 then xs else match list { [x | xs2] -> [x | removeAt(xs2, idx - 1)] }
}

# Insert element at index
insertAt[T](list: List[T], idx: Int, x: T) -> List[T] = match list {
    [] -> [x]
    [h | t] -> if idx == 0 then [x | list] else [h | insertAt(t, idx - 1, x)]
}

# Partition list by predicate into (matching, non-matching)
partition[T](list: List[T], pred: (T) -> Bool) -> (List[T], List[T]) = match list {
    [] -> ([], [])
    [x | xs] -> {
        (yes, no) = partition(xs, pred)
        if pred(x) then ([x | yes], no) else (yes, [x | no])
    }
}

# Take elements while predicate is true
takeWhile[T](list: List[T], pred: (T) -> Bool) -> List[T] = match list {
    [] -> []
    [x | xs] -> if pred(x) then [x | takeWhile(xs, pred)] else []
}

# Drop elements while predicate is true
dropWhile[T](list: List[T], pred: (T) -> Bool) -> List[T] = match list {
    [] -> []
    [x | xs] -> if pred(x) then dropWhile(xs, pred) else list
}

# Split list at index
splitAt[T](list: List[T], n: Int) -> (List[T], List[T]) = match list {
    [] -> ([], [])
    [x | xs] -> if n == 0 then ([], list) else {
        (left, right) = splitAt(xs, n - 1)
        ([x | left], right)
    }
}

# Interleave two lists
interleave[T](xs: List[T], ys: List[T]) -> List[T] = match xs {
    [] -> ys
    [x | xrest] -> match ys {
        [] -> xs
        _ -> [x | interleave(ys, xrest)]
    }
}

# Group consecutive equal elements
group[T](list: List[T]) -> List[List[T]] = match list {
    [] -> []
    [x | xs] -> groupAcc(xs, x, [x], [])
}
groupAcc[T](list: List[T], prev: T, current: List[T], acc: List[List[T]]) -> List[List[T]] = match list {
    [] -> reverse([reverse(current) | acc])
    [x | xs] -> if x == prev
        then groupAcc(xs, x, [x | current], acc)
        else groupAcc(xs, x, [x], [reverse(current) | acc])
}

# Scan (like fold but returns all intermediate values)
scanl[T, U](list: List[T], acc: U, f: (U, T) -> U) -> List[U] = match list {
    [] -> [acc]
    [x | xs] -> [acc | scanl(xs, f(acc, x), f)]
}

# Zip with custom function
zipWith[T, U, V](xs: List[T], ys: List[U], f: (T, U) -> V) -> List[V] = match xs {
    [] -> []
    [x | xrest] -> match ys {
        [] -> []
        [y | yrest] -> [f(x, y) | zipWith(xrest, yrest, f)]
    }
}

# Get indices where predicate is true
findIndices[T](list: List[T], pred: (T) -> Bool) -> List[Int] = findIndicesAcc(list, pred, 0)
findIndicesAcc[T](list: List[T], pred: (T) -> Bool, idx: Int) -> List[Int] = match list {
    [] -> []
    [x | xs] -> if pred(x)
        then [idx | findIndicesAcc(xs, pred, idx + 1)]
        else findIndicesAcc(xs, pred, idx + 1)
}

# Count elements satisfying predicate
count[T](list: List[T], pred: (T) -> Bool) -> Int = fold(list, 0, (acc, x) => if pred(x) then acc + 1 else acc)

# Maximum element (requires non-empty list)
maximum[T](list: List[T]) -> T = match list {
    [x] -> x
    [x | xs] -> {
        m = maximum(xs)
        if x > m then x else m
    }
}

# Minimum element (requires non-empty list)
minimum[T](list: List[T]) -> T = match list {
    [x] -> x
    [x | xs] -> {
        m = minimum(xs)
        if x < m then x else m
    }
}

# Sum all elements (requires numeric list)
sum(list: List[Int]) -> Int = fold(list, 0, (acc, x) => acc + x)

# Product of all elements (requires numeric list)
product(list: List[Int]) -> Int = fold(list, 1, (acc, x) => acc * x)

# Find index of first element equal to target
indexOf[T](list: List[T], target: T) -> Option[Int] = indexOfAcc(list, target, 0)
indexOfAcc[T](list: List[T], target: T, idx: Int) -> Option[Int] = match list {
    [] -> None()
    [x | xs] -> if x == target then Some(idx) else indexOfAcc(xs, target, idx + 1)
}

# Sort with custom comparator (comparator returns -1, 0, or 1)
sortBy[T](list: List[T], cmp: (T, T) -> Int) -> List[T] = match list {
    [] -> []
    [pivot | rest] -> {
        lesser = filter(rest, x => cmp(x, pivot) < 0)
        greater = filter(rest, x => cmp(x, pivot) >= 0)
        concat(sortBy(lesser, cmp), [pivot | sortBy(greater, cmp)])
    }
}

# Insert element between all elements
intersperse[T](list: List[T], sep: T) -> List[T] = match list {
    [] -> []
    [x] -> [x]
    [x | xs] -> [x, sep | intersperse(xs, sep)]
}

# Split list at first element not satisfying predicate
# Returns (takeWhile(pred), dropWhile(pred))
# Named spanList to avoid conflict with Html.span
spanList[T](list: List[T], pred: (T) -> Bool) -> (List[T], List[T]) = match list {
    [] -> ([], [])
    [x | xs] -> if pred(x) then {
        (ys, zs) = spanList(xs, pred)
        ([x | ys], zs)
    } else ([], [x | xs])
}

# Group consecutive elements by key function
groupBy[T, K](list: List[T], keyFn: (T) -> K) -> List[List[T]] = match list {
    [] -> []
    [x | xs] -> groupByAcc(xs, keyFn, keyFn(x), [x], [])
}
groupByAcc[T, K](list: List[T], keyFn: (T) -> K, prevKey: K, current: List[T], acc: List[List[T]]) -> List[List[T]] = match list {
    [] -> reverse([reverse(current) | acc])
    [x | xs] -> {
        key = keyFn(x)
        if key == prevKey
        then groupByAcc(xs, keyFn, key, [x | current], acc)
        else groupByAcc(xs, keyFn, key, [x], [reverse(current) | acc])
    }
}

# Transpose a list of lists (rows become columns)
transpose[T](rows: List[List[T]]) -> List[List[T]] = match rows {
    [] -> []
    _ -> if isEmpty(head(rows))
        then []
        else {
            heads = map(rows, r => head(r))
            tails = map(rows, r => tail(r))
            [heads | transpose(tails)]
        }
}

# Apply function to pairs of adjacent elements
pairwise[T, U](list: List[T], f: (T, T) -> U) -> List[U] = match list {
    [] -> []
    [_] -> []
    [x, y | rest] -> [f(x, y) | pairwise([y | rest], f)]
}

# Check if list is sorted
isSorted[T](list: List[T]) -> Bool = match list {
    [] -> true
    [_] -> true
    [x, y | rest] -> x <= y && isSorted([y | rest])
}

# Check if list is sorted by comparator
isSortedBy[T](list: List[T], cmp: (T, T) -> Int) -> Bool = match list {
    [] -> true
    [_] -> true
    [x, y | rest] -> cmp(x, y) <= 0 && isSortedBy([y | rest], cmp)
}
