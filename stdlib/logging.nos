# Logging Library for Nostos
#
# Provides console, stderr, and file logging with level filtering.
#
# Built-in loggers:
#   - ConsoleLogger: logs to stdout
#   - StderrLogger: logs to stderr
#   - FileLogger: logs to file (append mode)
#   - RotatingFileLogger: logs to file with size-based rotation
#
# Usage:
#   use stdlib.logging.*
#   logger = newConsoleLogger()
#   logInfo(logger, "Hello!")
#   consoleFlush(logger)
#
# Custom loggers: Define a type with minLevel field, then create
# myLog(logger, entry) and myFlush(logger) functions. Example:
#
#   type PrefixLogger = { prefix: String, minLevel: LogLevel }
#   prefixLog(logger, entry) = {
#       if levelPriority(entry.level) >= levelPriority(logger.minLevel) then
#           println("[" ++ logger.prefix ++ "] " ++ formatEntry(entry))
#       else ()
#   }
#
# The Logger trait is exported for documentation purposes.
# Use function-based API for logger operations.

# Log Levels - prefixed with L to avoid namespace conflicts
pub type LogLevel = LDebug | LInfo | LWarn | LError | LFatal

# Convert log level to string
pub levelToString(level) = match level {
    LDebug -> "DEBUG"
    LInfo -> "INFO"
    LWarn -> "WARN"
    LError -> "ERROR"
    LFatal -> "FATAL"
}

# Get priority for comparison (higher = more severe)
pub levelPriority(level) = match level {
    LDebug -> 0
    LInfo -> 1
    LWarn -> 2
    LError -> 3
    LFatal -> 4
}

# Log Entry
pub type LogEntry = { level: LogLevel, message: String, timestamp: Int, source: String }

# Create entries
pub makeEntry(level, message) = LogEntry(level, message, Time.now(), "")
pub makeEntryFrom(level, message, source) = LogEntry(level, message, Time.now(), source)

# Pad with zeros
pub repeatStr(0, acc) = acc
pub repeatStr(n, acc) = repeatStr(n - 1, acc ++ "0")

pub padZero(n, width) = {
    s = show(n)
    len = s.length()
    if len >= width then s
    else repeatStr(width - len, "") ++ s
}

# Format timestamp
pub formatTimestamp(ts) = {
    millis = ts % 1000
    totalSecs = ts / 1000
    secs = totalSecs % 60
    totalMins = totalSecs / 60
    mins = totalMins % 60
    totalHours = totalMins / 60
    hours = totalHours % 24
    days = totalHours / 24
    years = 1970 + (days / 365)
    dayOfYear = days % 365
    month = (dayOfYear / 30) + 1
    day = (dayOfYear % 30) + 1
    padZero(years, 4) ++ "-" ++ padZero(month, 2) ++ "-" ++ padZero(day, 2) ++ " " ++
    padZero(hours, 2) ++ ":" ++ padZero(mins, 2) ++ ":" ++ padZero(secs, 2) ++ "." ++
    padZero(millis, 3)
}

# Format a log entry
pub formatEntry(entry) = {
    ts = formatTimestamp(entry.timestamp)
    lvl = levelToString(entry.level)
    src = if entry.source == "" then "" else "[" ++ entry.source ++ "] "
    "[" ++ ts ++ "] [" ++ lvl ++ "] " ++ src ++ entry.message
}

# Logger Trait (for documentation - stdlib traits have limited accessibility)
# Custom loggers should define:
#   - myLog(logger, entry: LogEntry) -> ()
#   - myFlush(logger) -> ()
trait Logger
    log(self, entry: LogEntry) -> ()
    flush(self) -> ()
end

# Console Logger
pub type ConsoleLogger = { minLevel: LogLevel }

pub newConsoleLogger() = ConsoleLogger(LDebug)
pub newConsoleLoggerWithLevel(level) = ConsoleLogger(level)

pub consoleLog(logger, entry) = {
    if levelPriority(entry.level) >= levelPriority(logger.minLevel) then
        println(formatEntry(entry))
    else ()
}
pub consoleFlush(logger) = flushStdout()

# Stderr Logger
pub type StderrLogger = { minLevel: LogLevel }

pub newStderrLogger() = StderrLogger(LDebug)
pub newStderrLoggerWithLevel(level) = StderrLogger(level)

pub stderrLog(logger, entry) = {
    if levelPriority(entry.level) >= levelPriority(logger.minLevel) then
        eprintln(formatEntry(entry))
    else ()
}
pub stderrFlush(logger) = flushStderr()

# Convenience functions for console logger
pub logDebug(logger, message) = consoleLog(logger, makeEntry(LDebug, message))
pub logInfo(logger, message) = consoleLog(logger, makeEntry(LInfo, message))
pub logWarn(logger, message) = consoleLog(logger, makeEntry(LWarn, message))
pub logError(logger, message) = consoleLog(logger, makeEntry(LError, message))
pub logFatal(logger, message) = consoleLog(logger, makeEntry(LFatal, message))

# Log with source
pub logDebugFrom(logger, source, message) = consoleLog(logger, makeEntryFrom(LDebug, message, source))
pub logInfoFrom(logger, source, message) = consoleLog(logger, makeEntryFrom(LInfo, message, source))
pub logWarnFrom(logger, source, message) = consoleLog(logger, makeEntryFrom(LWarn, message, source))
pub logErrorFrom(logger, source, message) = consoleLog(logger, makeEntryFrom(LError, message, source))
pub logFatalFrom(logger, source, message) = consoleLog(logger, makeEntryFrom(LFatal, message, source))

# File Logger (simple, no rotation)
pub type FileLogger = { path: String, minLevel: LogLevel }

pub newFileLogger(path) = FileLogger(path, LDebug)
pub newFileLoggerWithLevel(path, level) = FileLogger(path, level)

pub fileLog(logger, entry) = {
    if levelPriority(entry.level) >= levelPriority(logger.minLevel) then {
        line = formatEntry(entry) ++ "\n"
        handle = File.open(logger.path, "a")
        File.write(handle, line)
        File.close(handle)
    } else ()
}

pub fileFlush(logger) = {
    # File is already closed after each write, so this is a no-op
    ()
}

# Rotating File Logger
pub type RotatingFileLogger = { path: String, minLevel: LogLevel, maxSize: Int, maxBackups: Int }

pub newRotatingFileLogger(path, maxSize, maxBackups) = RotatingFileLogger(path, LDebug, maxSize, maxBackups)
pub newRotatingFileLoggerWithLevel(path, level, maxSize, maxBackups) = RotatingFileLogger(path, level, maxSize, maxBackups)

# Rotate files: app.log -> app.log.1, app.log.1 -> app.log.2, etc.
pub rotateFilesImpl(basePath, n, maxBackups) = {
    if n == 0 then ()
    else {
        oldPath = basePath ++ "." ++ show(n)
        newPath = basePath ++ "." ++ show(n + 1)
        if File.exists(oldPath) then {
            if n == maxBackups then
                File.remove(oldPath)
            else
                File.rename(oldPath, newPath)
        } else ()
        rotateFilesImpl(basePath, n - 1, maxBackups)
    }
}

pub rotateFiles(basePath, maxBackups) = {
    # Shift all existing backups
    rotateFilesImpl(basePath, maxBackups, maxBackups)

    # Move current file to .1
    if File.exists(basePath) then
        File.rename(basePath, basePath ++ ".1")
    else ()
}

pub rotatingFileLog(logger, entry) = {
    if levelPriority(entry.level) >= levelPriority(logger.minLevel) then {
        # Check if rotation needed
        needsRotation = if File.exists(logger.path) then
            File.size(logger.path) >= logger.maxSize
        else false

        if needsRotation then rotateFiles(logger.path, logger.maxBackups) else ()

        # Write the log entry
        line = formatEntry(entry) ++ "\n"
        handle = File.open(logger.path, "a")
        File.write(handle, line)
        File.close(handle)
    } else ()
}

pub rotatingFileFlush(logger) = {
    # File is already closed after each write, so this is a no-op
    ()
}

# Convenience functions for file logger
pub fileLogDebug(logger, message) = fileLog(logger, makeEntry(LDebug, message))
pub fileLogInfo(logger, message) = fileLog(logger, makeEntry(LInfo, message))
pub fileLogWarn(logger, message) = fileLog(logger, makeEntry(LWarn, message))
pub fileLogError(logger, message) = fileLog(logger, makeEntry(LError, message))
pub fileLogFatal(logger, message) = fileLog(logger, makeEntry(LFatal, message))

# Convenience functions for rotating file logger
pub rotatingLogDebug(logger, message) = rotatingFileLog(logger, makeEntry(LDebug, message))
pub rotatingLogInfo(logger, message) = rotatingFileLog(logger, makeEntry(LInfo, message))
pub rotatingLogWarn(logger, message) = rotatingFileLog(logger, makeEntry(LWarn, message))
pub rotatingLogError(logger, message) = rotatingFileLog(logger, makeEntry(LError, message))
pub rotatingLogFatal(logger, message) = rotatingFileLog(logger, makeEntry(LFatal, message))


