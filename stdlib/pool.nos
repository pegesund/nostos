# PostgreSQL Connection Pool
#
# Automatic connection management - get, use, release handled for you.
# Limits concurrent connections to avoid exhausting database resources.
#
# Usage:
#   use stdlib.pool.{init, query, execute, withConn}
#
#   main() = {
#       init("host=localhost user=postgres password=postgres")
#       rows = query("SELECT * FROM users", [])
#       execute("INSERT INTO users (name) VALUES ($1)", ["Alice"])
#   }

# Pool state: (connections, connString, active, maxPool, lastResult)
# lastResult: ("none") | ("took", conn) | ("create", connStr) | ("wait")
mvar poolState: (List[Int], String, Int, Int, (String, Int, String)) = ([], "", 0, 25, ("none", 0, ""))

# Initialize the pool with a connection string
init(connStr) = {
    poolState.update(state => {
        (conns, _, active, maxP, _) = state
        (conns, connStr, active, maxP, ("none", 0, ""))
    })
    ()
}

# Initialize the pool with a connection string and custom max pool size
initWithMax(connStr, maxConnections) = {
    poolState.update(state => {
        (conns, _, active, _, _) = state
        (conns, connStr, active, maxConnections, ("none", 0, ""))
    })
    ()
}

# Atomically try to get a connection from pool
# Returns: ("take", conn, "") | ("create", 0, connStr) | ("wait", 0, "")
decideConnection() = {
    (_, _, _, _, result) = poolState.update(state => {
        (conns, connStr, active, maxP, _) = state
        match conns {
            [conn | rest] ->
                (rest, connStr, active + 1, maxP, ("take", conn, ""))
            [] -> if active < maxP then
                ([], connStr, active + 1, maxP, ("create", 0, connStr))
            else
                ([], connStr, active, maxP, ("wait", 0, ""))
        }
    })
    result
}

# Decrement active count atomically (used when connection creation fails)
releaseSlot() = {
    poolState.update(state => {
        (conns, connStr, active, maxP, _) = state
        (conns, connStr, active - 1, maxP, ("none", 0, ""))
    })
    ()
}

# Get pool statistics for debugging/monitoring
# Returns: (active, pooled, total, max)
stats() = {
    (conns, _, active, maxP, _) = poolState
    pooled = length(conns)
    (active, pooled, active + pooled, maxP)
}

# Get a connection from the pool (internal) - waits if pool exhausted
getConn() = match decideConnection() {
    ("take", conn, _) -> conn
    ("create", _, connStr) -> try {
        Pg.connect(connStr)
    } catch {
        e -> {
            releaseSlot()
            throw(e)
        }
    }
    ("wait", _, _) -> {
        sleep(5)
        getConn()
    }
}

# Try to get a connection immediately - returns None if pool exhausted
tryGetConn() = match decideConnection() {
    ("take", conn, _) -> Some(conn)
    ("create", _, connStr) -> try {
        Some(Pg.connect(connStr))
    } catch {
        e -> {
            releaseSlot()
            throw(e)
        }
    }
    ("wait", _, _) -> None
}

# Return a connection to the pool atomically
releaseConn(conn) = {
    poolState.update(state => {
        (conns, connStr, active, maxP, _) = state
        (conn :: conns, connStr, active - 1, maxP, ("none", 0, ""))
    })
    ()
}

# Execute a query and return rows - connection handled automatically
query(sql, params) = {
    conn = getConn()
    try { Pg.query(conn, sql, params) } catch { e -> throw(e) } finally { releaseConn(conn) }
}

# Execute a statement and return affected count - connection handled automatically
execute(sql, params) = {
    conn = getConn()
    try { Pg.execute(conn, sql, params) } catch { e -> throw(e) } finally { releaseConn(conn) }
}

# Run a function with a connection (for transactions or multiple operations)
# The connection is automatically released after the function completes.
#
# Usage:
#   withConn(conn => {
#       Pg.begin(conn)
#       Pg.execute(conn, "INSERT ...", [...])
#       Pg.execute(conn, "UPDATE ...", [...])
#       Pg.commit(conn)
#   })
withConn(action) = {
    conn = getConn()
    try { action(conn) } catch { e -> throw(e) } finally { releaseConn(conn) }
}

# Run a function in a transaction - auto rollback on error, auto commit on success
#
# Usage:
#   transaction(conn => {
#       Pg.execute(conn, "INSERT ...", [...])
#       Pg.execute(conn, "UPDATE ...", [...])
#   })
transaction(action) = {
    conn = getConn()
    try {
        Pg.begin(conn)
        result = action(conn)
        Pg.commit(conn)
        result
    } catch {
        e -> {
            # Try to rollback, but ignore errors (transaction may already be aborted)
            try { Pg.rollback(conn) } catch { _ -> () }
            throw(e)
        }
    } finally {
        releaseConn(conn)
    }
}

# Try to run a transaction - returns None immediately if pool exhausted
# Returns Some(result) on success
tryTransaction(action) = match tryGetConn() {
    None -> None
    Some(conn) -> {
        result = try {
            Pg.begin(conn)
            r = action(conn)
            Pg.commit(conn)
            Some(r)
        } catch {
            e -> {
                try { Pg.rollback(conn) } catch { _ -> () }
                throw(e)
            }
        } finally {
            releaseConn(conn)
        }
        result
    }
}
