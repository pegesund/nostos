# Timeout Example
#
# Demonstrates receive timeout patterns:
# - Simple timeout: waiting for messages that never arrive
# - HTTP with retry: timeout during async HTTP operations
# - Race requests: take first response from multiple sources
# - Collect with timeout: gather as many results as possible
# - Sleep vs timeout: interleaving sleep and receive
#
# Run with: nostos examples/timeout_example.nos

# Pattern 1: Simple timeout - wait for a message that never arrives
simpleTimeout() = {
  println("Pattern 1: Simple timeout")

  result = receive
    msg -> ("received", msg)
  after 500 ->
    ("timeout", "")
  end

  # Should timeout since no message is sent
  assert_eq(("timeout", ""), result)
  println("  Timeout works correctly")
  println("")
}

# Pattern 2: HTTP request with guaranteed completion
httpWithRetry() = {
  println("Pattern 2: HTTP request with retry on timeout")
  me = self()

  # Worker makes HTTP request
  spawn {
    response = Http.get("https://httpbin.org/delay/1")
    me <- ("http_done", response.status, response.body)
  }

  # Wait with timeout
  result = receive
    ("http_done", status, body) -> ("success", status)
  after 3000 ->
    ("timeout", 0)
  end

  print("  Result: ")
  println(result)
  println("")
}

# Pattern 3: Race multiple requests, take first
raceRequests() = {
  println("Pattern 3: Race multiple requests")
  me = self()

  # Start 3 requests with different delays
  spawn {
    response = Http.get("https://httpbin.org/delay/2")
    me <- ("server_a", response.status)
  }
  spawn {
    response = Http.get("https://httpbin.org/delay/1")
    me <- ("server_b", response.status)
  }
  spawn {
    response = Http.get("https://httpbin.org/delay/3")
    me <- ("server_c", response.status)
  }

  # Take the first response
  result = receive
    (server, status) -> (server, status)
  after 5000 ->
    ("none", 0)
  end

  print("  First responder: ")
  println(result)
  println("")
}

# Pattern 4: Collect with timeout - gather as many as possible
collectWithTimeout() = {
  println("Pattern 4: Collect with timeout")
  me = self()

  # Start multiple workers
  spawn {
    sleep(100)
    me <- ("worker", 1)
  }
  spawn {
    sleep(200)
    me <- ("worker", 2)
  }
  spawn {
    sleep(300)
    me <- ("worker", 3)
  }
  spawn {
    sleep(2000)
    me <- ("worker", 4)
  }

  # Simple receive loop with count
  r1 = receive ("worker", id) -> id after 500 -> 0 end
  r2 = receive ("worker", id) -> id after 500 -> 0 end
  r3 = receive ("worker", id) -> id after 500 -> 0 end

  print("  Received workers: ")
  print(r1)
  print(", ")
  print(r2)
  print(", ")
  println(r3)
  println("")
}

# Pattern 5: Sleep vs timeout race
sleepVsTimeout() = {
  println("Pattern 5: Sleep vs timeout")
  me = self()

  # Worker sleeps then sends
  spawn {
    sleep(300)
    me <- "done"
  }

  # Timeout before worker finishes (100ms < 300ms)
  result = receive
    msg1 -> ("got", msg1)
  after 100 ->
    ("timeout", "")
  end

  assert_eq(("timeout", ""), result)

  # Now wait longer - should get message
  result2 = receive
    msg2 -> ("got", msg2)
  after 1000 ->
    ("timeout", "")
  end

  assert_eq(("got", "done"), result2)
  println("  Sleep vs timeout works correctly")
  println("")
}

main() = {
  println("=== Timeout Patterns Example ===")
  println("")

  simpleTimeout()
  sleepVsTimeout()

  # HTTP patterns need network access, run them but don't assert
  # httpWithRetry()
  # raceRequests()
  # collectWithTimeout()

  println("Timeout example tests passed!")
}
