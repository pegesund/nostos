# Ring Test
# 
# Tests message passing around rings of processes:
# - Simple ring: 5 nodes, 1 message, value incremented at each hop
# - Multi-round ring: 3 nodes, 5 messages cycling through
# - Parallel rings: 4 independent rings running concurrently
# 
# Tests cross-thread messaging, ordering, and process coordination.
# Run with: nostos --parallel-affinity 4 examples/ring_test.nos

# Ring node: receives from predecessor, sends to successor
ring_node(successor, count) = {
    if count > 0 then {
        println("Ring node waiting...")
        msg = receive
            n -> n
        after 5000 ->
            -9999
        end
        println("Ring node got:")
        println(msg)
        if msg == -9999 then {
            println("Ring node timed out!")
            ()
        } else {
            # Pass message to next node, incrementing it
            println("Sending to next:")
            println(msg + 1)
            successor <- msg + 1
            ring_node(successor, count - 1)
        }
    } else {
        ()
    }
}

# Create a ring of n nodes, returns the first node's PID
# Each node will pass `rounds` messages
create_ring_rec(n, first, prev, rounds) = {
    if n > 0 then {
        # Create new node that sends to prev (building backwards)
        node = spawn { ring_node(prev, rounds) }
        if n == 1 then {
            # Last node to create - this is actually first in the ring
            # Return it so we can close the ring
            (node, first)
        } else {
            create_ring_rec(n - 1, first, node, rounds)
        }
    } else {
        (prev, first)
    }
}

# Test 1: Simple ring of 5 nodes, 1 round each
test_simple_ring() = {
    println("Test 1: Simple ring (5 nodes, 1 message)")
    me = self()

    # Create 5 nodes that each handle 1 message
    # Node 5 -> Node 4 -> Node 3 -> Node 2 -> Node 1 -> me
    node1 = spawn { ring_node(me, 1) }
    node2 = spawn { ring_node(node1, 1) }
    node3 = spawn { ring_node(node2, 1) }
    node4 = spawn { ring_node(node3, 1) }
    node5 = spawn { ring_node(node4, 1) }

    # Start the ring with value 1
    node5 <- 1

    # Receive final value (should be 1 + 5 = 6)
    result = receive n -> n after 5000 -> 0 end
    println("Final value (expect 6):")
    println(result)
    assert(result == 6)
    println("Test 1 PASSED")
    ()
}

# Test 2: Ring with multiple rounds
test_multi_round_ring() = {
    println("")
    println("Test 2: Multi-round ring (3 nodes, 5 rounds)")
    me = self()

    # 3 nodes, each handles 5 messages
    node1 = spawn { ring_node(me, 5) }
    node2 = spawn { ring_node(node1, 5) }
    node3 = spawn { ring_node(node2, 5) }

    # Send 5 messages into the ring
    node3 <- 0
    r1 = receive n -> n after 5000 -> -1 end

    node3 <- 10
    r2 = receive n -> n after 5000 -> -1 end

    node3 <- 20
    r3 = receive n -> n after 5000 -> -1 end

    node3 <- 30
    r4 = receive n -> n after 5000 -> -1 end

    node3 <- 40
    r5 = receive n -> n after 5000 -> -1 end

    println("Results (expect 3, 13, 23, 33, 43):")
    println(r1)
    println(r2)
    println(r3)
    println(r4)
    println(r5)

    assert(r1 == 3)
    assert(r2 == 13)
    assert(r3 == 23)
    assert(r4 == 33)
    assert(r5 == 43)
    println("Test 2 PASSED")
    ()
}

# Collector for parallel ring results
collect_results(remaining, acc) = {
    if remaining > 0 then {
        r = receive n -> n after 10000 -> -1 end
        if r == -1 then {
            println("Timeout collecting results!")
            acc
        } else {
            collect_results(remaining - 1, acc + r)
        }
    } else {
        acc
    }
}

# Test 3: Multiple independent rings running in parallel
test_parallel_rings() = {
    println("")
    println("Test 3: Parallel rings (4 independent 3-node rings)")
    me = self()

    # Ring 1
    r1n1 = spawn { ring_node(me, 1) }
    r1n2 = spawn { ring_node(r1n1, 1) }
    r1n3 = spawn { ring_node(r1n2, 1) }

    # Ring 2
    r2n1 = spawn { ring_node(me, 1) }
    r2n2 = spawn { ring_node(r2n1, 1) }
    r2n3 = spawn { ring_node(r2n2, 1) }

    # Ring 3
    r3n1 = spawn { ring_node(me, 1) }
    r3n2 = spawn { ring_node(r3n1, 1) }
    r3n3 = spawn { ring_node(r3n2, 1) }

    # Ring 4
    r4n1 = spawn { ring_node(me, 1) }
    r4n2 = spawn { ring_node(r4n1, 1) }
    r4n3 = spawn { ring_node(r4n2, 1) }

    # Start all rings simultaneously with different starting values
    r1n3 <- 100
    r2n3 <- 200
    r3n3 <- 300
    r4n3 <- 400

    # Collect all 4 results (order may vary)
    total = collect_results(4, 0)

    # Expected: (100+3) + (200+3) + (300+3) + (400+3) = 1012
    println("Total sum (expect 1012):")
    println(total)
    assert(total == 1012)
    println("Test 3 PASSED")
    ()
}

main() = {
    println("=== Ring Test Suite ===")
    println("")

    test_simple_ring()
    test_multi_round_ring()
    test_parallel_rings()

    println("")
    println("=== All Ring Tests PASSED ===")
    ()
}
