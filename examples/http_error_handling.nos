# HTTP Error Handling
#
# Demonstrates IO error handling patterns with exceptions:
# - All IO throws exceptions on error (caught with try/catch)
# - DNS errors: invalid domain names throw exceptions
# - HTTP errors: 404, 500 are successful connections (no exception)
# - Retry pattern: exponential backoff on failures
# - File IO: same exception pattern for file operations
#
# Run with: nostos examples/http_error_handling.nos

# Pattern 1: Basic error checking with try/catch
basicErrorHandling() = {
  println("Pattern 1: Basic error checking")
  println("  Testing valid URL...")

  result = try {
    response = Http.get("https://httpbin.org/get")
    print("    Connection successful! HTTP status: ")
    println(response.status)
    true
  } catch e ->
    print("    Connection error: ")
    println(e)
    false
  end

  # Valid URL should succeed
  assert_eq(true, result)
  println("")
}

# Pattern 2: DNS error handling
dnsErrorHandling() = {
  println("Pattern 2: DNS error (invalid domain)")
  println("  Testing invalid domain...")

  gotError = try {
    response = Http.get("https://this-domain-does-not-exist-xyz123.com/test")
    print("    Unexpected success: ")
    println(response.status)
    false
  } catch e ->
    print("    Expected error: ")
    println(e)
    true
  end

  # Invalid domain should throw an exception
  assert_eq(true, gotError)
  println("")
}

# Pattern 3: HTTP status codes (not connection errors)
httpStatusHandling() = {
  println("Pattern 3: HTTP status codes (valid connection)")
  println("  Testing httpbin.org endpoint...")

  result = try {
    response = Http.get("https://httpbin.org/status/404")
    print("    Got HTTP status: ")
    println(response.status)
    println("    Note: Any HTTP status (200, 404, 503) means the connection worked")
    response.status
  } catch e ->
    print("    Connection error: ")
    println(e)
    0
  end

  # Connection should succeed (404 is HTTP status, not a connection error)
  assert_eq(404, result)
  println("")
}

# Pattern 4: Worker process with error handling
httpWorker(parent, id, url) = {
  try {
    response = Http.get(url)
    parent <- ("success", id, response.status)
  } catch e ->
    parent <- ("failure", id, e)
  end
}

workerErrorHandling() = {
  println("Pattern 4: Worker processes with error handling")
  me = self()

  spawn { httpWorker(me, 1, "https://httpbin.org/get") }
  spawn { httpWorker(me, 2, "https://invalid-domain-xyz.com/") }
  spawn { httpWorker(me, 3, "https://httpbin.org/status/500") }

  r1 = receive
    ("success", id, httpStatus) -> ("worker " ++ show(id), "success", httpStatus)
    ("failure", id, errMsg) -> ("worker " ++ show(id), "failure", errMsg)
  after 10000 -> ("timeout", "no response", 0)
  end

  r2 = receive
    ("success", id, httpStatus) -> ("worker " ++ show(id), "success", httpStatus)
    ("failure", id, errMsg) -> ("worker " ++ show(id), "failure", errMsg)
  after 10000 -> ("timeout", "no response", 0)
  end

  r3 = receive
    ("success", id, httpStatus) -> ("worker " ++ show(id), "success", httpStatus)
    ("failure", id, errMsg) -> ("worker " ++ show(id), "failure", errMsg)
  after 10000 -> ("timeout", "no response", 0)
  end

  print("  Result 1: ")
  println(r1)
  print("  Result 2: ")
  println(r2)
  print("  Result 3: ")
  println(r3)
  println("")
}

# Pattern 5: Retry on error
retryRequest(url, retriesLeft) = {
  if retriesLeft <= 0 then {
    ("error", "max retries exceeded")
  } else {
    result = try {
      response = Http.get(url)
      ("ok", response)
    } catch e ->
      print("    Retry ")
      print(4 - retriesLeft)
      print(" failed: ")
      println(e)
      sleep(500)
      retryRequest(url, retriesLeft - 1)
    end
    result
  }
}

retryExample() = {
  println("Pattern 5: Retry on error")
  println("  Attempting request with retries to invalid domain...")

  (status, result) = retryRequest("https://will-fail-xyz.com/", 3)

  print("  Final result: ")
  println(status)

  # Invalid domain should fail after all retries
  assert_eq("error", status)
  assert_eq("max retries exceeded", result)

  println("")
}

# Pattern 6: File IO error handling
fileErrorHandling() = {
  println("Pattern 6: File IO error handling")

  println("  Reading non-existent file...")
  gotError = try {
    content = File.readAll("/tmp/this-file-does-not-exist-xyz.txt")
    print("    Unexpected content: ")
    println(content)
    false
  } catch e ->
    print("    Expected error: ")
    println(e)
    true
  end

  # Reading non-existent file should throw
  assert_eq(true, gotError)

  println("  Writing to valid path...")
  writeResult = try {
    File.writeAll("/tmp/nostos_test_write.txt", "Hello from Nostos!")
    println("    Write successful!")

    content = File.readAll("/tmp/nostos_test_write.txt")
    assert_eq("Hello from Nostos!", content)
    print("    Read back: ")
    println(content)
    true
  } catch e ->
    print("    Error: ")
    println(e)
    false
  end

  assert_eq(true, writeResult)
  println("")
}

main() = {
  println("=== HTTP Error Handling Examples ===")
  println("")
  println("IO operations throw exceptions on error - use try/catch to handle")
  println("")

  basicErrorHandling()
  dnsErrorHandling()
  httpStatusHandling()
  workerErrorHandling()
  retryExample()
  fileErrorHandling()

  println("=== All assertions passed! ===")
  0
}
