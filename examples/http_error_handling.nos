# HTTP Error Handling
# 
# Demonstrates IO error handling patterns:
# - All IO returns ("ok", value) or ("error", message) tuples
# - DNS errors: invalid domain names
# - HTTP errors: 404, 500 are successful connections (not IO errors)
# - Retry pattern: exponential backoff on failures
# - File IO: same tuple pattern for file operations
# 
# Run with: nostos examples/http_error_handling.nos

# Pattern 1: Basic error checking
basicErrorHandling() = {
  println("Pattern 1: Basic error checking")
  println("  Testing valid URL...")

  (status, response) = Http.get("https://httpbin.org/get")

  # Valid URL should return "ok" status
  assert_eq("ok", status)

  if status == "ok" then {
    print("    Success! HTTP status: ")
    println(response.status)
    # httpbin.org/get should return 200
    assert_eq(200, response.status)
  } else {
    print("    Error: ")
    println(response)
  }
  println("")
}

# Pattern 2: DNS error handling
dnsErrorHandling() = {
  println("Pattern 2: DNS error (invalid domain)")
  println("  Testing invalid domain...")

  (status, response) = Http.get("https://this-domain-does-not-exist-xyz123.com/test")

  # Invalid domain should return "error" status (DNS failure)
  assert_eq("error", status)

  if status == "ok" then {
    print("    Unexpected success: ")
    println(response.status)
  } else {
    print("    Expected error: ")
    println(response)
  }
  println("")
}

# Pattern 3: HTTP 404 error (not a connection error)
http404Handling() = {
  println("Pattern 3: HTTP 404 (valid connection, page not found)")
  println("  Testing non-existent path...")

  (status, response) = Http.get("https://httpbin.org/status/404")

  # Connection is successful even for 404 - HTTP errors are not IO errors
  assert_eq("ok", status)

  if status == "ok" then {
    print("    Got response with HTTP status: ")
    println(response.status)
    println("    Note: 404 is a successful HTTP response, not an IO error")
    # HTTP status should be 404
    assert_eq(404, response.status)
  } else {
    print("    Connection error: ")
    println(response)
  }
  println("")
}

# Pattern 4: Worker process with error handling
httpWorker(parent, id, url) = {
  (status, response) = Http.get(url)
  if status == "ok" then {
    parent <- ("success", id, response.status)
  } else {
    parent <- ("failure", id, response)
  }
}

workerErrorHandling() = {
  println("Pattern 4: Worker processes with error handling")
  me = self()

  spawn { httpWorker(me, 1, "https://httpbin.org/get") }
  spawn { httpWorker(me, 2, "https://invalid-domain-xyz.com/") }
  spawn { httpWorker(me, 3, "https://httpbin.org/status/500") }

  r1 = receive
    ("success", id, httpStatus) -> ("worker " ++ show(id), "success", httpStatus)
    ("failure", id, errMsg) -> ("worker " ++ show(id), "failure", errMsg)
  after 10000 -> ("timeout", "no response", 0)
  end

  r2 = receive
    ("success", id, httpStatus) -> ("worker " ++ show(id), "success", httpStatus)
    ("failure", id, errMsg) -> ("worker " ++ show(id), "failure", errMsg)
  after 10000 -> ("timeout", "no response", 0)
  end

  r3 = receive
    ("success", id, httpStatus) -> ("worker " ++ show(id), "success", httpStatus)
    ("failure", id, errMsg) -> ("worker " ++ show(id), "failure", errMsg)
  after 10000 -> ("timeout", "no response", 0)
  end

  print("  Result 1: ")
  println(r1)
  print("  Result 2: ")
  println(r2)
  print("  Result 3: ")
  println(r3)
  println("")
}

# Pattern 5: Retry on error
retryRequest(url, retriesLeft) = {
  if retriesLeft <= 0 then {
    ("error", "max retries exceeded")
  } else {
    (status, response) = Http.get(url)
    if status == "ok" then {
      ("ok", response)
    } else {
      print("    Retry ")
      print(4 - retriesLeft)
      print(" failed: ")
      println(response)
      sleep(500)
      retryRequest(url, retriesLeft - 1)
    }
  }
}

retryExample() = {
  println("Pattern 5: Retry on error")
  println("  Attempting request with retries to invalid domain...")

  (status, result) = retryRequest("https://will-fail-xyz.com/", 3)

  print("  Final result: ")
  println(status)

  # Invalid domain should fail after all retries
  assert_eq("error", status)
  assert_eq("max retries exceeded", result)

  println("")
}

# Pattern 6: File IO error handling
fileErrorHandling() = {
  println("Pattern 6: File IO error handling")

  println("  Reading non-existent file...")
  (status, content) = File.readAll("/tmp/this-file-does-not-exist-xyz.txt")

  # Reading non-existent file should return error
  assert_eq("error", status)

  if status == "ok" then {
    print("    Content: ")
    println(content)
  } else {
    print("    Expected error: ")
    println(content)
  }

  println("  Writing to valid path...")
  (wstatus, wresult) = File.writeAll("/tmp/nostos_test_write.txt", "Hello from Nostos!")

  # Writing to /tmp should succeed
  assert_eq("ok", wstatus)

  if wstatus == "ok" then {
    println("    Write successful!")

    (rstatus, rcontent) = File.readAll("/tmp/nostos_test_write.txt")

    # Reading the file we just wrote should succeed
    assert_eq("ok", rstatus)
    assert_eq("Hello from Nostos!", rcontent)

    if rstatus == "ok" then {
      print("    Read back: ")
      println(rcontent)
    } else {
      print("    Read error: ")
      println(rcontent)
    }
  } else {
    print("    Write error: ")
    println(wresult)
  }
  println("")
}

main() = {
  println("=== HTTP Error Handling Examples ===")
  println("")
  println("IO operations return: (\"ok\", value) or (\"error\", message)")
  println("")

  basicErrorHandling()
  dnsErrorHandling()
  http404Handling()
  workerErrorHandling()
  retryExample()
  fileErrorHandling()

  println("=== All assertions passed! ===")
  0
}
