# Worker Pool
# 
# Demonstrates a pool of worker processes:
# - worker: receives Task messages, executes work, returns Result
# - start_workers: spawns n worker processes
# - submit_task: sends work to a worker in the pool
# 
# Pattern for distributing work across multiple concurrent workers.

# Worker process
worker(pool) = receive
    Task(client, work) -> {
        result = work()
        client <- Result(result)
        worker(pool)
    }
    Stop -> ()
end

# Start n workers
start_workers(0, _) = []
start_workers(n, pool) = [spawn { worker(pool) } | start_workers(n - 1, pool)]

# Round-robin task distribution
submit_task([], _, _) = ()
submit_task([w | _], client, work) = w <- Task(client, work)

# Simple work functions
compute_fib() = fib(10)

fib(0) = 0
fib(1) = 1
fib(n) = fib(n - 1) + fib(n - 2)

compute_fact() = fact(5)

fact(0) = 1
fact(n) = n * fact(n - 1)

main() = {
    me = self()

    # Start 2 workers
    workers = start_workers(2, me)

    # Submit fib(10) task
    submit_task(workers, me, compute_fib)

    # Wait for result
    result = receive
        Result(r) -> r
    end

    # fib(10) = 55
    assert_eq(55, result)

    # Submit fact(5) task
    submit_task(workers, me, compute_fact)

    result2 = receive
        Result(r) -> r
    end

    # fact(5) = 120
    assert_eq(120, result2)

    println("Worker pool tests passed!")
    result + result2  # 55 + 120 = 175
}
