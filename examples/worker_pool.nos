# Worker Pool
#
# Demonstrates a pool of worker processes:
# - worker: receives Task messages, executes work, returns Result
# - start_workers: spawns n worker processes
# - submit_task: sends work to a worker in the pool
#
# Pattern for distributing work across multiple concurrent workers.

type Message = Task(Pid, Int) | Result(Int) | Stop

# Worker process - receives a number and computes fib of it
worker(pool) = receive {
    Task(client, n) -> {
        result = fib(n)
        client <- Result(result)
        worker(pool)
    }
    Stop -> ()
}

# Start n workers
start_workers(0, _) = []
start_workers(n, pool) = [spawn { worker(pool) } | start_workers(n - 1, pool)]

# Round-robin task distribution
submit_task([], _, _) = ()
submit_task([w | _], client, work) = w <- Task(client, work)

# Fibonacci
fib(0) = 0
fib(1) = 1
fib(n) = fib(n - 1) + fib(n - 2)

main() = {
    me = self()

    # Start 2 workers
    workers = start_workers(2, me)

    # Submit fib(10) task
    submit_task(workers, me, 10)

    # Wait for result
    result = receive {
        Result(r1) -> r1
    }

    # fib(10) = 55
    assert_eq(55, result)

    # Submit fib(8) task
    submit_task(workers, me, 8)

    result2 = receive {
        Result(r2) -> r2
    }

    # fib(8) = 21
    assert_eq(21, result2)

    println("Worker pool tests passed!")
    result + result2  # 55 + 21 = 76
}
