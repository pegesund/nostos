# List Operations
#
# Demonstrates higher-order functions and pattern matching on lists:
# - map: apply a function to each element
# - filter: keep elements matching a predicate
# - fold: reduce a list to a single value
# - reverse, take, drop: common list manipulations
#
# These are fundamental building blocks for functional programming.

# Map a function over a list
map(_, []) = []
map(f, [h | t]) = [f(h) | map(f, t)]

# Filter elements that satisfy a predicate
filter(_, []) = []
filter(p, [h | t]) = if p(h) then [h | filter(p, t)] else filter(p, t)

# Fold (reduce) a list with an accumulator
fold(_, acc, []) = acc
fold(f, acc, [h | t]) = fold(f, f(acc, h), t)

# Sum all elements in a list
sum(lst) = fold((a, b) => a + b, 0, lst)

# Product of all elements
product(lst) = fold((a, b) => a * b, 1, lst)

# Length of a list
length([]) = 0
length([_ | t]) = 1 + length(t)

# Reverse a list
reverse(lst) = fold((acc, x) => [x | acc], [], lst)

# Take first n elements
take(0, _) = []
take(_, []) = []
take(n, [h | t]) = [h | take(n - 1, t)]

# Drop first n elements
drop(0, lst) = lst
drop(_, []) = []
drop(n, [_ | t]) = drop(n - 1, t)

main() = {
    nums = [1, 2, 3, 4, 5]

    # Test map
    doubled = map(x => x * 2, nums)
    assert_eq([2, 4, 6, 8, 10], doubled)

    # Test filter - filter evens from original list
    evens = filter(x => x % 2 == 0, nums)
    assert_eq([2, 4], evens)

    # Test sum and product
    assert_eq(15, sum(nums))
    assert_eq(120, product(nums))

    # Test length
    assert_eq(5, length(nums))

    # Test reverse
    assert_eq([5, 4, 3, 2, 1], reverse(nums))

    # Test take and drop
    assert_eq([1, 2, 3], take(3, nums))
    assert_eq([4, 5], drop(3, nums))

    println("List operations tests passed!")
    sum(evens)  # 2 + 4 = 6
}
