# Complete Web Application
#
# PostgreSQL + Html(...) templating + routing + forms + cookies + connection pooling
#
# Requires: PostgreSQL at localhost (user: postgres, pw: postgres)
#
# Features:
# - Connection pooling via stdlib.pool (no per-request connection overhead)
# - spawn-per-request pattern for scalable request handling
# - Html templating with components
# - Form handling with POST requests
#
# Test:
#   curl http://localhost:8080/
#   curl http://localhost:8080/users
#   curl -X POST -d "name=Alice&email=alice@example.com" http://localhost:8080/users
#   curl -X POST -d "from=1&to=2&amount=50" http://localhost:8080/transfer

use stdlib.html.{Html, render}
use stdlib.server.{serve, getParam, respondHtml, redirect, redirectWith, respond400, respond405, setCookieWithAge}
use stdlib.pool.{init, query, execute, withConn, transaction}

# --- Database Setup ---

setupDatabase() = {
    execute("
        CREATE TABLE IF NOT EXISTS web_users (
            id SERIAL PRIMARY KEY,
            name TEXT NOT NULL,
            email TEXT NOT NULL,
            credits INT DEFAULT 100,
            created_at TIMESTAMP DEFAULT NOW()
        )
    ", [])

    rows = query("SELECT COUNT(*) FROM web_users", [])
    count = head(rows).0

    if count == 0 then {
        execute("INSERT INTO web_users (name, email) VALUES ($1, $2)", ("Alice", "alice@example.com"))
        execute("INSERT INTO web_users (name, email) VALUES ($1, $2)", ("Bob", "bob@example.com"))
        println("Inserted sample users")
    } else ()
}

# --- HTML Components ---

layout(pageTitle: String, content: Html) = Html(
    el("html", [], [
        headEl([
            meta([("charset", "UTF-8")]),
            title(pageTitle ++ " - Nostos App"),
            el("style", [], [raw("
                body { font-family: sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
                .container { background: white; padding: 30px; border-radius: 8px; }
                nav { margin-bottom: 20px; }
                nav a { margin-right: 15px; }
                .card { background: #f9f9f9; padding: 15px; margin: 10px 0; border-radius: 4px; }
                form input { padding: 8px; margin: 5px 0; width: 200px; }
                form button { padding: 8px 16px; background: #0066cc; color: white; border: none; cursor: pointer; }
            ")])
        ]),
        body([
            el("div", [("class", "container")], [
                nav([a([("href", "/")], "Home"), a([("href", "/users")], "Users")]),
                content
            ])
        ])
    ])
)

userCard(userId: Int, name: String, email: String, credits: Int) = Html(
    el("div", [("class", "card")], [
        h3(name),
        p("Email: " ++ email),
        p("Credits: " ++ show(credits)),
        p([a([("href", "/users/" ++ show(userId))], "View Details")])
    ])
)

# --- Route Handlers ---

handleHome(req) = {
    rows = query("SELECT COUNT(*) FROM web_users", [])
    userCount = head(rows).0

    content = Html(div([
        h1("Nostos Web App"),
        p("Users in database: " ++ show(userCount)),
        p([a([("href", "/users")], "View All Users")])
    ]))
    respondHtml(req, render(layout("Home", content)))
}

handleUsers(req) = {
    rows = query("SELECT id, name, email, credits FROM web_users ORDER BY id", [])
    cards = map(rows, (id, name, email, credits) => userCard(id, name, email, credits))

    content = Html(div([
        h1("All Users"),
        div(cards),
        hr(),
        h2("Add New User"),
        el("form", [("method", "POST"), ("action", "/users")], [
            input([("type", "text"), ("name", "name"), ("placeholder", "Name")]),
            input([("type", "email"), ("name", "email"), ("placeholder", "Email")]),
            el("button", [("type", "submit")], [text("Add User")])
        ]),
        hr(),
        h2("Transfer Credits"),
        el("form", [("method", "POST"), ("action", "/transfer")], [
            input([("type", "number"), ("name", "from"), ("placeholder", "From User ID")]),
            input([("type", "number"), ("name", "to"), ("placeholder", "To User ID")]),
            input([("type", "number"), ("name", "amount"), ("placeholder", "Amount")]),
            el("button", [("type", "submit")], [text("Transfer")])
        ])
    ]))
    respondHtml(req, render(layout("Users", content)))
}

handleUserDetail(req, userId: String) = {
    intOr = s => match String.toInt(s) { Some(n) -> n, None -> 0 }
    rows = query("SELECT id, name, email, credits FROM web_users WHERE id = $1", (intOr(userId)))

    content = match rows {
        [] -> Html(div([
            h1("User Not Found"),
            p([a([("href", "/users")], "Back to Users")])
        ]))
        [(id, name, email, credits) | _] -> Html(div([
            h1("User: " ++ name),
            el("div", [("class", "card")], [
                p("ID: " ++ show(id)),
                p("Name: " ++ name),
                p("Email: " ++ email),
                p("Credits: " ++ show(credits))
            ]),
            p([a([("href", "/users")], "Back to Users")])
        ]))
    }
    respondHtml(req, render(layout("User " ++ userId, content)))
}

handleCreateUser(req) = match req.method {
    "POST" -> {
        name = getParam(req.formParams, "name")
        email = getParam(req.formParams, "email")

        match (name, email) {
            ("", _) -> respond400(req, "Name is required")
            (_, "") -> respond400(req, "Email is required")
            _ -> {
                execute("INSERT INTO web_users (name, email) VALUES ($1, $2)", (name, email))
                redirect(req, "/users")
            }
        }
    }
    _ -> respond405(req)
}

# Transfer credits between users - uses transaction for atomicity
# Both updates succeed or both fail (no partial transfers)
handleTransfer(req) = match req.method {
    "POST" -> {
        fromId = getParam(req.formParams, "from")
        toId = getParam(req.formParams, "to")
        amountStr = getParam(req.formParams, "amount")

        match (fromId, toId, amountStr) {
            ("", _, _) -> respond400(req, "From user ID is required")
            (_, "", _) -> respond400(req, "To user ID is required")
            (_, _, "") -> respond400(req, "Amount is required")
            _ -> {
                intOr = s => match String.toInt(s) { Some(n) -> n, None -> 0 }
                amount = intOr(amountStr)
                fromIdInt = intOr(fromId)
                toIdInt = intOr(toId)

                if amount <= 0 then respond400(req, "Amount must be positive")
                else {
                    # Transaction ensures both updates happen atomically
                    transaction(conn => {
                        Pg.execute(conn, "UPDATE web_users SET credits = credits - $1 WHERE id = $2", (amount, fromIdInt))
                        Pg.execute(conn, "UPDATE web_users SET credits = credits + $1 WHERE id = $2", (amount, toIdInt))
                    })
                    redirect(req, "/users")
                }
            }
        }
    }
    _ -> respond405(req)
}

handle404(req) = {
    content = Html(div([
        h1("404 - Not Found"),
        p([a([("href", "/")], "Go Home")])
    ]))
    Server.respond(req.id, 404, [("Content-Type", "text/html")], render(layout("Not Found", content)))
}

# --- Router ---

route(req) = match req.path {
    "/" -> handleHome(req)
    "/users" -> if req.method == "POST" then handleCreateUser(req) else handleUsers(req)
    "/transfer" -> handleTransfer(req)
    _ -> {
        params = Server.matchPath(req.path, "/users/:id")
        if length(params) > 0 then {
            (_, userId) = head(params)
            handleUserDetail(req, userId)
        } else handle404(req)
    }
}

main() = {
    # Initialize connection pool
    init("host=localhost user=postgres password=postgres")
    setupDatabase()

    println("Web App: http://localhost:8080")
    println("Using connection pooling via stdlib.pool")
    serve(8080, route)
}
