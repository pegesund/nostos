# JIT Heartbeat Monitor
# 
# Tests scheduler fairness during JIT-heavy computation:
# - "Heart" sends 100 rapid heartbeats
# - "Beast" computes fib(30) (~1M recursive calls)
# - If JIT blocked everything, no heartbeats until beast finishes
# - Heartbeats flow freely, proving fair scheduling
# 
# Demonstrates that light processes stay responsive during heavy JIT work.

# The beast: heavy JIT-compiled fibonacci
fib(0) = 0
fib(1) = 1
fib(n) = fib(n - 1) + fib(n - 2)

# Heart: sends heartbeats as fast as possible
heart(monitor, 0) = monitor <- 0
heart(monitor, n) = {
    monitor <- 1
    heart(monitor, n - 1)
}

# Beast: does heavy JIT work then reports
beast(monitor) = {
    result = fib(30)  # ~1M calls, pure JIT fury
    monitor <- result
}

# Collect messages and count heartbeats (1s) vs beast result (832040)
collect(0, beats) = beats
collect(n, beats) = {
    msg = receive x -> x end
    new_beats = if msg == 1 then beats + 1 else beats
    collect(n - 1, new_beats)
}

main() = {
    me = self()

    # Unleash the beast (JIT-heavy)
    spawn { beast(me) }

    # Start the heart (rapid-fire messages)
    spawn { heart(me, 100) }

    # Collect 102 messages: 100 heartbeats + 1 final zero + 1 beast result
    beats = collect(102, 0)

    # Report
    println("=== JIT Heartbeat Monitor ===")
    print("Heartbeats received: ")
    println(beats)

    # All 100 heartbeats should arrive (scheduler is fair)
    assert_eq(100, beats)

    println("JIT heartbeat test passed!")
}
