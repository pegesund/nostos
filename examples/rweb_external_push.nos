# RWeb External Push Example
# Demonstrates how external processes can push updates to connected clients
#
# Run with: ./target/release/nostos examples/rweb_external_push.nos
# Then open http://localhost:8080 in a browser
#
# The background pusher will automatically update the page every 2 seconds!

use stdlib.rweb
use stdlib.rweb.{onSessionStartCallback, onSessionEndCallback, rwebTrigger}
use stdlib.rhtml

# Shared MVar to store active writerIds
mvar activeWriters: List[Int] = []

# Shared MVar for the latest push message (all sessions read from this)
mvar latestPushMsg: String = ""

reactive State = { counter: Int, lastPush: String }

# Background pusher - runs independently and sends actions to all connected clients
backgroundPusher(n) = {
    sleep(2000)

    # Get current list of active writers
    writers = activeWriters

    if length(writers) > 0 then {
        # Update the shared message MVar
        msg = "Push #" ++ show(n) ++ " at " ++ show(Time.now())
        latestPushMsg = msg

        # Send trigger to each connected client (they'll respond with _external action)
        writers.each(writerId => rwebTrigger(writerId))
        println("[Pusher] Sent push #" ++ show(n) ++ " to " ++ show(length(writers)) ++ " client(s)")
    } else ()

    backgroundPusher(n + 1)
}

session() = {
    state = State(counter: 0, lastPush: "Waiting for background pusher...")
    (
        () => RHtml(div([
            h1("RWeb External Push Demo"),

            div([
                h3("Local State (click to increment):"),
                p("Counter: " ++ show(state.counter)),
                button("+1", dataAction: "increment")
            ], style: "margin-bottom: 20px; padding: 10px; border: 1px solid #ccc;"),

            div([
                h3("External Push Status:"),
                p(state.lastPush, style: if state.lastPush == "Waiting for background pusher..." then "color: gray;" else "color: lime; font-weight: bold;")
            ], style: "padding: 10px; border: 1px solid #ccc; background: #111;"),

            p("The background process sends 'push' actions every 2 seconds!",
              style: "margin-top: 20px; font-style: italic;")
        ])),
        (action, params) => match action {
            "increment" -> { state.counter = state.counter + 1 }
            "_external" -> {
                # External trigger - read latest message from shared MVar
                msg = latestPushMsg
                if msg != "" then {
                    state.lastPush = "âœ“ " ++ msg
                } else ()
            }
            _ -> ()
        }
    )
}

main() = {
    println("Starting RWeb External Push Demo on http://localhost:8080")
    println("Open in browser to see automatic updates from background pusher!")
    println("")

    # Set up callbacks to track writerIds for external push
    onSessionStartCallback = Some(writerId => {
        activeWriters = activeWriters ++ [writerId]
    })

    onSessionEndCallback = Some(writerId => {
        activeWriters = activeWriters.filter(w => w != writerId)
    })

    # Start background pusher
    spawn { backgroundPusher(1) }

    # Use standard RWeb with callbacks
    startRWeb(8080, "External Push Demo", session)
}
