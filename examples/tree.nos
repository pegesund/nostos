# Binary Tree
# 
# Demonstrates recursive algebraic data types and tree operations:
# - Tree[T] type with Leaf and Node constructors
# - Recursive traversal and aggregation
# - Tree mapping and transformation
# 
# Binary trees are a fundamental data structure in computer science.

type Tree[T] = Leaf | Node(T, Tree[T], Tree[T])

# Calculate tree depth
depth(Leaf) = 0
depth(Node(_, left, right)) = 1 + max(depth(left), depth(right))

max(a, b) = if a > b then a else b

# Sum all values in tree
sum_tree(Leaf) = 0
sum_tree(Node(v, left, right)) = v + sum_tree(left) + sum_tree(right)

# Count nodes
count(Leaf) = 0
count(Node(_, left, right)) = 1 + count(left) + count(right)

# In-order traversal to list
inorder(Leaf) = []
inorder(Node(v, left, right)) = append(inorder(left), [v | inorder(right)])

# Simple append
append([], ys) = ys
append([x | xs], ys) = [x | append(xs, ys)]

# Map a function over tree
map_tree(_, Leaf) = Leaf
map_tree(f, Node(v, left, right)) = Node(f(v), map_tree(f, left), map_tree(f, right))

main() = {
    # Create a balanced binary search tree:
    #       4
    #      / \
    #     2   6
    #    / \ / \
    #   1  3 5  7
    tree = Node(4,
        Node(2, Node(1, Leaf, Leaf), Node(3, Leaf, Leaf)),
        Node(6, Node(5, Leaf, Leaf), Node(7, Leaf, Leaf))
    )

    # Test sum: 1+2+3+4+5+6+7 = 28
    assert_eq(28, sum_tree(tree))

    # Test count: 7 nodes
    assert_eq(7, count(tree))

    # Test depth: 3 levels
    assert_eq(3, depth(tree))

    # Test in-order traversal (gives sorted list for BST)
    assert_eq([1, 2, 3, 4, 5, 6, 7], inorder(tree))

    # Test map_tree
    doubled = map_tree(x => x * 2, tree)
    assert_eq(56, sum_tree(doubled))

    println("Binary tree tests passed!")
    sum_tree(tree)
}
