# Counter Server
use stdlib.server.*

# 
# Demonstrates stateful server processes:
# - counter_loop: maintains state via recursive message handling
# - Inc/Dec/Get/Stop messages for state manipulation
# - Client functions for clean API (increment, decrement, get_value)
# 
# This is the OTP GenServer pattern: state as function arguments.

type Message = Inc(Pid) | Dec(Pid) | Get(Pid) | Stop | Ok(Int) | Value(Int)

# Counter loop with state
counter_loop(state) = receive {
    Inc(sender) -> {
        sender <- Ok(state + 1)
        counter_loop(state + 1)
    }
    Dec(sender) -> {
        sender <- Ok(state - 1)
        counter_loop(state - 1)
    }
    Get(sender) -> {
        sender <- Value(state)
        counter_loop(state)
    }
    Stop -> state
}

# Start a counter with initial value
start_counter(initial) = spawn { counter_loop(initial) }

# Client operations
increment(counter) = {
    counter <- Inc(self())
    receive {
        Ok(val) -> val
    }
}

decrement(counter) = {
    counter <- Dec(self())
    receive {
        Ok(val) -> val
    }
}

get_value(counter) = {
    counter <- Get(self())
    receive {
        Value(val) -> val
    }
}

stop(counter) = {
    counter <- Stop
    ()
}

main() = {
    # Start counter at 0
    c = start_counter(0)
    assert_eq(0, get_value(c))

    # Increment 3 times
    assert_eq(1, increment(c))
    assert_eq(2, increment(c))
    assert_eq(3, increment(c))

    # Verify value
    assert_eq(3, get_value(c))

    # Decrement once
    assert_eq(2, decrement(c))
    assert_eq(2, get_value(c))

    # Start another counter at 100
    c2 = start_counter(100)
    assert_eq(100, get_value(c2))
    assert_eq(99, decrement(c2))

    stop(c)
    stop(c2)

    println("Counter server tests passed!")
    5  # 3 + 2
}
