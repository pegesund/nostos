# HTTP Server
#
# HTTP server with spawn-per-request pattern:
# - /       : Hello message
# - /health : Health check
# - /echo   : Echo request body
# - /work   : CPU-bound work (fib(25))
# - /shutdown: Gracefully shuts down the server
#
# Uses spawn-per-request pattern for scalability and proper memory management.
# Each request is handled in its own spawned process.

# Simulate CPU work - compute fib(n)
fib(0) = 0
fib(1) = 1
fib(n) = fib(n - 1) + fib(n - 2)

# Handle a single request
handleRequest(req, mainPid) = {
  path = req.path

  # Shutdown route
  if path == "/shutdown" then {
    Server.respond(req.id, 200, [("Content-Type", "text/plain")], "Shutting down...")
    mainPid <- "shutdown"
  }
  else {
    (body, status) = if path == "/" then
      ("Hello from Nostos HTTP Server!", 200)
    else if path == "/health" then
      ("OK", 200)
    else if path == "/echo" then
      (req.body, 200)
    else if path == "/work" then
      # Do actual CPU work - should use multiple cores
      (show(fib(25)), 200)
    else
      ("Not Found", 404)

    headers = [("Content-Type", "text/plain")]
    Server.respond(req.id, status, headers, body)
  }
}

# Server loop with spawn-per-request pattern (proper tail recursion)
serverLoop(server, mainPid) = {
  ok = try {
    req = Server.accept(server)
    spawn { handleRequest(req, mainPid) }
    true
  } catch { _ -> false }
  # Tail call is OUTSIDE try-catch - this is important for memory!
  if ok then serverLoop(server, mainPid) else ()
}

# Send shutdown request to terminate the server
sendShutdown() = {
  sleep(100)  # Give server time to start
  try {
    response = Http.get("http://localhost:8080/shutdown")
    ()
  } catch { e -> () }
}

main() = {
  mainPid = self()

  result = try {
    server = Server.bind(8080)
    println("Server started on http://localhost:8080")

    # Spawn server loop
    spawn { serverLoop(server, mainPid) }

    # Spawn a client to test and then shutdown
    spawn { sendShutdown() }

    # Wait for shutdown signal
    receive {
      "shutdown" -> {
        sleep(100)  # Let response complete
        Server.close(server)
        println("Server shutdown complete.")
      }
      after 10000 -> {
        Server.close(server)
        println("Timeout - shutting down.")
      }
    }
  } catch { e ->
    println("Error: Failed to bind server on port 8080: " ++ e)
  }
  result
}
