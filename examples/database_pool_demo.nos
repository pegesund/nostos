# Database Connection Pool Demo
#
# Demonstrates the stdlib/pool.nos connection pool features:
# - Automatic connection management
# - Pool statistics and monitoring
# - Transactions with auto-rollback
# - Concurrent request handling
# - Non-blocking pool access (tryTransaction)
#
# Requires: PostgreSQL at localhost (user: postgres, pw: postgres)
#
# Test:
#   curl http://localhost:8080/               - Pool stats
#   curl http://localhost:8080/products       - List products
#   curl -X POST -d "name=Widget&price=9.99" http://localhost:8080/products
#   curl http://localhost:8080/order?product=Widget&qty=5
#   curl http://localhost:8080/orders         - List orders with products

use stdlib.server.{serve, getParam, respondText, respondJson, respond400, respond404, respond503}
use stdlib.pool.{initPool, initWithMax, query, execute, withConn, transaction, tryTransaction, stats}

# --- Database Setup ---

setupDatabase() = {
    # Products table
    execute("CREATE TABLE IF NOT EXISTS products (
        id SERIAL PRIMARY KEY,
        name TEXT NOT NULL UNIQUE,
        price DECIMAL(10,2) NOT NULL,
        stock INT NOT NULL DEFAULT 100
    )", [])

    # Orders table
    execute("CREATE TABLE IF NOT EXISTS orders (
        id SERIAL PRIMARY KEY,
        product_id INT REFERENCES products(id),
        quantity INT NOT NULL,
        total DECIMAL(10,2) NOT NULL,
        created_at TIMESTAMP DEFAULT NOW()
    )", [])

    # Insert sample data if empty
    rows = query("SELECT COUNT(*) FROM products", [])
    match rows {
        [(count) | _] -> if count == 0 then {
            execute("INSERT INTO products (name, price, stock) VALUES
                ('Widget', 9.99, 100),
                ('Gadget', 19.99, 50),
                ('Gizmo', 29.99, 25)", [])
            println("Inserted sample products")
        } else ()
        _ -> ()
    }
}

# --- Pool Statistics ---

showStats(req) = {
    (active, pooled, total, maxP) = stats()
    json = "{\"active\":" ++ show(active) ++
           ",\"pooled\":" ++ show(pooled) ++
           ",\"total\":" ++ show(total) ++
           ",\"max\":" ++ show(maxP) ++ "}"
    respondJson(req, json)
}

# --- Product Handlers ---

formatProducts(rows) = match rows {
    [] -> "[]"
    _ -> {
        items = rows.map(row => {
            (id, name, price, stock) = row
            "{\"id\":" ++ show(id) ++ ",\"name\":\"" ++ name ++ "\",\"price\":" ++ show(price) ++ ",\"stock\":" ++ show(stock) ++ "}"
        })
        "[" ++ String.join(",", items) ++ "]"
    }
}

listProducts(req) = {
    rows = query("SELECT id, name, price, stock FROM products ORDER BY id", [])
    respondJson(req, formatProducts(rows))
}

createProduct(req) = {
    name = getParam(req.formParams, "name")
    priceStr = getParam(req.formParams, "price")

    if name == "" || priceStr == "" then respond400(req, "name and price required")
    else {
        execute("INSERT INTO products (name, price) VALUES ($1, $2)", [name, priceStr])
        respondJson(req, "{\"status\":\"created\",\"name\":\"" ++ name ++ "\"}")
    }
}

# --- Order Handler with Transaction ---

# Creates an order with stock verification - demonstrates transaction usage
createOrder(req) = {
    productName = getParam(req.queryParams, "product")
    qtyStr = getParam(req.queryParams, "qty")

    if productName == "" || qtyStr == "" then respond400(req, "product and qty required")
    else {
        qty = match String.toInt(qtyStr) {
            Some(n) -> n
            None -> 0
        }

        if qty <= 0 then respond400(req, "qty must be positive")
        else {
            # Use tryTransaction for non-blocking access
            result = tryTransaction(conn => {
                # Check product exists and has enough stock
                rows = Pg.query(conn, "SELECT id, price, stock FROM products WHERE name = $1 FOR UPDATE", [productName])

                match rows {
                    [(id, price, stock) | _] -> {
                        if stock < qty then {
                            throw("insufficient stock: " ++ show(stock) ++ " available")
                        } else {
                            # Calculate total
                            total = price * qty

                            # Decrease stock
                            Pg.execute(conn, "UPDATE products SET stock = stock - $1 WHERE id = $2", [show(qty), show(id)])

                            # Create order
                            Pg.execute(conn, "INSERT INTO orders (product_id, quantity, total) VALUES ($1, $2, $3)", [show(id), show(qty), show(total)])

                            "{\"status\":\"ordered\",\"product\":\"" ++ productName ++ "\",\"qty\":" ++ show(qty) ++ ",\"total\":" ++ show(total) ++ "}"
                        }
                    }
                    [] -> throw("product not found: " ++ productName)
                }
            })

            match result {
                Some(json) -> respondJson(req, json)
                None -> respond503(req, "Pool exhausted - try again later")
            }
        }
    }
}

# --- Order List with Join ---

formatOrders(rows) = match rows {
    [] -> "[]"
    _ -> {
        items = rows.map(row => {
            (orderId, productName, qty, total, createdAt) = row
            "{\"id\":" ++ show(orderId) ++
            ",\"product\":\"" ++ productName ++
            "\",\"qty\":" ++ show(qty) ++
            ",\"total\":" ++ show(total) ++
            ",\"created_at\":\"" ++ createdAt ++ "\"}"
        })
        "[" ++ String.join(",", items) ++ "]"
    }
}

listOrders(req) = {
    rows = query("SELECT o.id, p.name, o.quantity, o.total, o.created_at::text
                  FROM orders o
                  JOIN products p ON o.product_id = p.id
                  ORDER BY o.created_at DESC
                  LIMIT 20", [])
    respondJson(req, formatOrders(rows))
}

# --- Batch Operation Demo ---

# Demonstrates withConn for multiple operations on same connection
resetStock(req) = {
    withConn(conn => {
        Pg.execute(conn, "UPDATE products SET stock = 100 WHERE name = 'Widget'", [])
        Pg.execute(conn, "UPDATE products SET stock = 50 WHERE name = 'Gadget'", [])
        Pg.execute(conn, "UPDATE products SET stock = 25 WHERE name = 'Gizmo'", [])
    })
    respondJson(req, "{\"status\":\"stock reset\"}")
}

# --- Router ---

route(req) = match req.path {
    "/" -> showStats(req)
    "/stats" -> showStats(req)
    "/products" -> if req.method == "POST" then createProduct(req) else listProducts(req)
    "/order" -> createOrder(req)
    "/orders" -> listOrders(req)
    "/reset" -> resetStock(req)
    _ -> respond404(req)
}

main() = {
    println("=== Database Connection Pool Demo ===")
    println("")

    # Initialize pool with custom max connections
    initWithMax("host=localhost user=postgres password=postgres", 10)
    println("Pool initialized (max 10 connections)")

    # Setup database
    try {
        setupDatabase()
        println("Database setup complete")
    } catch {
        e -> {
            println("Database setup failed: " ++ e)
            println("Make sure PostgreSQL is running at localhost")
        }
    }

    println("")
    println("Endpoints:")
    println("  GET  /            - Pool statistics")
    println("  GET  /products    - List products")
    println("  POST /products    - Create product (name, price)")
    println("  GET  /order       - Create order (product, qty)")
    println("  GET  /orders      - List recent orders")
    println("  GET  /reset       - Reset product stock")
    println("")
    println("Server: http://localhost:8080/")
    println("")

    serve(8080, route)
}
